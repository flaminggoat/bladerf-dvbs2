
bladeRF_nios.elf:     file format elf32-littlenios2
bladeRF_nios.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000414c

Program Header:
    LOAD off    0x00001000 vaddr 0x00004000 paddr 0x00004000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00004020 paddr 0x00004020 align 2**12
         filesz 0x00002f7c memsz 0x00002f7c flags r-x
    LOAD off    0x00003f9c vaddr 0x00006f9c paddr 0x00006fb8 align 2**12
         filesz 0x0000001c memsz 0x0000001c flags rw-
    LOAD off    0x00003fd4 vaddr 0x00006fd4 paddr 0x00006fd4 align 2**12
         filesz 0x00000000 memsz 0x00000434 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00004000  00004000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000012c  00004020  00004020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00002dc4  0000414c  0000414c  0000114c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000008c  00006f10  00006f10  00003f10  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000001c  00006f9c  00006fb8  00003f9c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000434  00006fd4  00006fd4  00003fd4  2**2
                  ALLOC, SMALL_DATA
  6 .ram          00000000  00007408  00007408  00003fb8  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  00003fb8  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000428  00000000  00000000  00003fe0  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00006f4a  00000000  00000000  00004408  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 000026b6  00000000  00000000  0000b352  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00002c35  00000000  00000000  0000da08  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000a9c  00000000  00000000  00010640  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001a9c  00000000  00000000  000110dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000049d5  00000000  00000000  00012b78  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000040  00000000  00000000  00017550  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000548  00000000  00000000  00017590  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  00019535  2**0
                  CONTENTS, READONLY
 18 .cpu          00000005  00000000  00000000  00019538  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0001953d  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0001953e  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   00000009  00000000  00000000  0001953f  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    00000009  00000000  00000000  00019548  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   00000009  00000000  00000000  00019551  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 0000000b  00000000  00000000  0001955a  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 00000074  00000000  00000000  00019565  2**0
                  CONTENTS, READONLY
 26 .sopcinfo     0007d5c7  00000000  00000000  000195d9  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00004000 l    d  .entry	00000000 .entry
00004020 l    d  .exceptions	00000000 .exceptions
0000414c l    d  .text	00000000 .text
00006f10 l    d  .rodata	00000000 .rodata
00006f9c l    d  .rwdata	00000000 .rwdata
00006fd4 l    d  .bss	00000000 .bss
00007408 l    d  .ram	00000000 .ram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../bladeRF_nios_bsp//obj/HAL/src/crt0.o
00004184 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00004094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 bladeRF_nios.c
00006f10 l     O .rodata	00000070 pkt_handlers
00000000 l    df *ABS*	00000000 devices.c
0000444c l     F .text	00000038 si5338_complete_transfer
00004484 l     F .text	00000038 command_uart_isr
00004528 l     F .text	00000088 vctcxo_tamer_set_tune_mode.part.0
00004648 l     F .text	00000098 vctcxo_tamer_isr
00000000 l    df *ABS*	00000000 devices_sim.c
00000000 l    df *ABS*	00000000 pkt_32x32.c
00000000 l    df *ABS*	00000000 pkt_8x16.c
00000000 l    df *ABS*	00000000 pkt_8x32.c
00000000 l    df *ABS*	00000000 pkt_8x64.c
00000000 l    df *ABS*	00000000 pkt_8x8.c
00000000 l    df *ABS*	00000000 pkt_legacy.c
000053b0 l     F .text	0000004c lookup_param
00006f80 l     O .rodata	0000001a config_params
00006fac l     O .rwdata	00000004 param.3722
00006fec l     O .bss	00000001 n.3720
00006fa8 l     O .rwdata	00000004 last_param.3723
00006fe4 l     O .bss	00000008 payload.3721
00006fe0 l     O .bss	00000001 n.3763
00006fa4 l     O .rwdata	00000004 param.3764
00006fa0 l     O .rwdata	00000004 last_param.3765
00006fd8 l     O .bss	00000008 payload.3762
00000000 l    df *ABS*	00000000 pkt_retune.c
000058ac l     F .text	00000064 reset_queue
00005910 l     F .text	0000007c retune_isr
0000598c l     F .text	0000002c retune_tx
00007000 l     O .bss	00000184 tx_queue
000059b8 l     F .text	0000002c retune_rx
00007184 l     O .bss	00000184 rx_queue
000059e4 l     F .text	00000118 perform_work
00000000 l    df *ABS*	00000000 band_select.c
00000000 l    df *ABS*	00000000 lms.c
00005fa8 l     F .text	000000cc vtune_low_to_norm
00006074 l     F .text	000000d8 vtune_high_to_norm
0000614c l     F .text	00000108 wait_for_vtune_value
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00006d4c g     F .text	0000002c alt_main
00007308 g     O .bss	00000100 alt_irq
00006fb8 g       *ABS*	00000000 __flash_rwdata_start
00004b34 g     F .text	0000000c tx_trigger_ctl_read
00004758 g     F .text	000000cc bladerf_nios_init
00006fb4 g     O .rwdata	00000004 jtag_uart
00006f08 g     F .text	00000008 altera_nios2_gen2_irq_init
00004000 g     F .entry	0000000c __reset
00004020 g       *ABS*	00000000 __flash_exceptions_start
00006ff8 g     O .bss	00000004 alt_argv
0000ef9c g       *ABS*	00000000 _gp
00006d78 g     F .text	00000004 usleep
000062a4 g     F .text	00000084 lms_select_pa
00006b30 g     F .text	00000028 memcpy
00006a4c g     F .text	00000064 .hidden __udivsi3
000044bc g     F .text	0000002c vctcxo_tamer_enable_isr
00004b50 g     F .text	0000000c rx_trigger_ctl_read
000053fc g     F .text	000004b0 pkt_legacy
00004000 g       *ABS*	00000000 __alt_mem_ram
00006fd4 g     O .bss	00000001 vctcxo_tamer_ctrl_reg
00007408 g       *ABS*	00000000 __bss_end
00006c04 g     F .text	00000068 alt_iic_isr_register
000051e4 g     F .text	000001cc pkt_8x8
00004afc g     F .text	00000028 iqbal_set_phase
00006bec g     F .text	00000018 alt_ic_irq_enabled
00006ff0 g     O .bss	00000004 alt_irq_active
000044e8 g     F .text	00000014 vctcxo_tamer_clear_isr
000040ec g     F .exceptions	00000060 alt_irq_handler
000045e0 g     F .text	00000068 vctcxo_tamer_read_count
000048ec g     F .text	0000008c si5338_write
00006f00 g     F .text	00000004 alt_dcache_flush_all
00004a4c g     F .text	00000054 adf4351_write
00006fb8 g       *ABS*	00000000 __ram_rwdata_end
000046e0 g     F .text	00000014 vctcxo_tamer_read
00006f9c g       *ABS*	00000000 __ram_rodata_end
00006914 g     F .text	00000040 .hidden __lshrdi3
00006ab0 g     F .text	00000058 .hidden __umodsi3
000049c0 g     F .text	0000008c vctcxo_trim_dac_read
00004ae0 g     F .text	0000001c iqbal_get_phase
00007408 g       *ABS*	00000000 end
00008000 g       *ABS*	00000000 __alt_stack_pointer
00004824 g     F .text	00000014 lms6_read
0000414c g     F .text	0000003c _start
00006da0 g     F .text	000000e8 alt_avalon_spi_command
00006d9c g     F .text	00000004 alt_sys_init
00006f9c g     O .rwdata	00000002 vctcxo_trim_dac_value
00006328 g     F .text	000000e0 lms_get_loopback_mode
000064a0 g     F .text	00000474 lms_set_precalculated_frequency
00006b08 g     F .text	00000028 .hidden __mulsi3
00006f9c g       *ABS*	00000000 __ram_rwdata_start
00006f10 g       *ABS*	00000000 __ram_rodata_start
000044fc g     F .text	0000002c vctcxo_tamer_reset_counters
00006e88 g     F .text	00000078 alt_busy_sleep
00007408 g       *ABS*	00000000 __alt_stack_base
000045b0 g     F .text	00000010 vctcxo_tamer_set_tune_mode
00006254 g     F .text	00000050 lms_select_lna
00004708 g     F .text	00000050 tamer_schedule
00006fd4 g       *ABS*	00000000 __bss_start
00006b58 g     F .text	00000020 memset
00004188 g     F .text	000002c4 main
00006ff4 g     O .bss	00000004 alt_envp
00004b5c g     F .text	0000007c time_tamer_read
0000484c g     F .text	000000a0 si5338_read
00006954 g     F .text	00000084 .hidden __divsi3
0000508c g     F .text	00000158 pkt_8x64
00006f10 g       *ABS*	00000000 __flash_rodata_start
00006d7c g     F .text	00000020 alt_irq_init
00004d5c g     F .text	000001d4 pkt_8x16
00005b90 g     F .text	000003a0 pkt_retune
00006ffc g     O .bss	00000004 alt_argc
00006408 g     F .text	00000098 lms_select_band
00004020 g       .exceptions	00000000 alt_irq_entry
000046f4 g     F .text	00000014 vctcxo_tamer_write
00004020 g       *ABS*	00000000 __ram_exceptions_start
00005afc g     F .text	00000064 pkt_retune_init
00006b78 g     F .text	00000004 alt_ic_isr_register
00006fb8 g       *ABS*	00000000 _edata
00004b40 g     F .text	00000010 rx_trigger_ctl_write
00007408 g       *ABS*	00000000 _end
0000414c g       *ABS*	00000000 __ram_exceptions_end
00006bb4 g     F .text	00000038 alt_ic_irq_disable
00004aa0 g     F .text	00000018 iqbal_get_gain
00004f30 g     F .text	0000015c pkt_8x32
000069d8 g     F .text	00000074 .hidden __modsi3
00008000 g       *ABS*	00000000 __alt_data_end
00004020 g     F .exceptions	00000000 alt_exception
00004b24 g     F .text	00000010 tx_trigger_ctl_write
0000400c g       .entry	00000000 _exit
00004838 g     F .text	00000014 lms6_write
00004bd8 g     F .text	00000184 pkt_32x32
00006f04 g     F .text	00000004 alt_icache_flush_all
00006fb0 g     O .rwdata	00000004 alt_priority_mask
00005f30 g     F .text	00000078 band_select
00004978 g     F .text	00000048 vctcxo_trim_dac_write
00006b7c g     F .text	00000038 alt_ic_irq_enable
000045c0 g     F .text	00000020 vctcxo_tamer_get_tune_mode
00005b60 g     F .text	00000030 pkt_retune_work
00004ab8 g     F .text	00000028 iqbal_set_gain
00006c6c g     F .text	000000e0 alt_load



Disassembly of section .entry:

00004000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
    4000:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
    4004:	08505314 	ori	at,at,16716
    jmp r1
    4008:	0800683a 	jmp	at

0000400c <_exit>:
	...

Disassembly of section .exceptions:

00004020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
    4020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
    4024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
    4028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
    402c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
    4030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
    4034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
    4038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
    403c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
    4040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
    4044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
    4048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
    404c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
    4050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
    4054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
    4058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
    405c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
    4060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
    4064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
    4068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
    406c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
    4070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
    4074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
    4078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
    407c:	10000326 	beq	r2,zero,408c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
    4080:	20000226 	beq	r4,zero,408c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
    4084:	00040ec0 	call	40ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
    4088:	00000306 	br	4098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
    408c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
    4090:	e8bfff17 	ldw	r2,-4(ea)

00004094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
    4094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
    4098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
    409c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
    40a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
    40a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
    40a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
    40ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
    40b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
    40b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
    40b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
    40bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
    40c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
    40c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
    40c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
    40cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
    40d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
    40d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
    40d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
    40dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
    40e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
    40e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
    40e8:	ef80083a 	eret

000040ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
    40ec:	defffe04 	addi	sp,sp,-8
    40f0:	dfc00115 	stw	ra,4(sp)
    40f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
    40f8:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
    40fc:	04000034 	movhi	r16,0
    4100:	841cc204 	addi	r16,r16,29448

  active = alt_irq_pending ();

  do
  {
    i = 0;
    4104:	0005883a 	mov	r2,zero
    mask = 1;
    4108:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
    410c:	20ca703a 	and	r5,r4,r3
    4110:	28000b26 	beq	r5,zero,4140 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
    4114:	100490fa 	slli	r2,r2,3
    4118:	8085883a 	add	r2,r16,r2
    411c:	10c00017 	ldw	r3,0(r2)
    4120:	11000117 	ldw	r4,4(r2)
    4124:	183ee83a 	callr	r3
    4128:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
    412c:	203ff51e 	bne	r4,zero,4104 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
    4130:	dfc00117 	ldw	ra,4(sp)
    4134:	dc000017 	ldw	r16,0(sp)
    4138:	dec00204 	addi	sp,sp,8
    413c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
    4140:	18c7883a 	add	r3,r3,r3
      i++;
    4144:	10800044 	addi	r2,r2,1

    } while (1);
    4148:	003ff006 	br	410c <alt_irq_handler+0x20>

Disassembly of section .text:

0000414c <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
    414c:	06c00034 	movhi	sp,0
    ori sp, sp, %lo(__alt_stack_pointer)
    4150:	dee00014 	ori	sp,sp,32768
    movhi gp, %hi(_gp)
    4154:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
    4158:	d6bbe714 	ori	gp,gp,61340
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
    415c:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
    4160:	109bf514 	ori	r2,r2,28628

    movhi r3, %hi(__bss_end)
    4164:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
    4168:	18dd0214 	ori	r3,r3,29704

    beq r2, r3, 1f
    416c:	10c00326 	beq	r2,r3,417c <_start+0x30>

0:
    stw zero, (r2)
    4170:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
    4174:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
    4178:	10fffd36 	bltu	r2,r3,4170 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
    417c:	0006c6c0 	call	6c6c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
    4180:	0006d4c0 	call	6d4c <alt_main>

00004184 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
    4184:	003fff06 	br	4184 <alt_after_alt_main>

00004188 <main>:
    FINE_TUNE,
    DO_NOTHING
} state_t;

int main(void)
{
    4188:	deffe404 	addi	sp,sp,-112
    trimdac_cal_line.y_intercept = 0;

    /* Sanity check */
    ASSERT(PKT_MAGIC_IDX == 0);

    memset(&pkt, 0, sizeof(pkt));
    418c:	01800844 	movi	r6,33
    4190:	000b883a 	mov	r5,zero
    4194:	d809883a 	mov	r4,sp
    FINE_TUNE,
    DO_NOTHING
} state_t;

int main(void)
{
    4198:	dfc01b15 	stw	ra,108(sp)
    419c:	dc801415 	stw	r18,80(sp)
    41a0:	dc401315 	stw	r17,76(sp)
    41a4:	dc001215 	stw	r16,72(sp)
    41a8:	df001a15 	stw	fp,104(sp)
    41ac:	ddc01915 	stw	r23,100(sp)
    41b0:	dd801815 	stw	r22,96(sp)
    41b4:	dd401715 	stw	r21,92(sp)
    41b8:	dd001615 	stw	r20,88(sp)
    41bc:	dcc01515 	stw	r19,84(sp)

    /* Marked volatile to ensure we actually read the byte populated by
     * the UART ISR */
    const volatile uint8_t *magic = &pkt.req[PKT_MAGIC_IDX];

    volatile bool have_request = false;
    41c0:	d8001005 	stb	zero,64(sp)
    trimdac_cal_line.y_intercept = 0;

    /* Sanity check */
    ASSERT(PKT_MAGIC_IDX == 0);

    memset(&pkt, 0, sizeof(pkt));
    41c4:	0006b580 	call	6b58 <memset>
    pkt.ready = false;
    bladerf_nios_init(&pkt, &vctcxo_tamer_pkt);
    41c8:	d9400904 	addi	r5,sp,36
    41cc:	d809883a 	mov	r4,sp
    41d0:	04000034 	movhi	r16,0

    /* Sanity check */
    ASSERT(PKT_MAGIC_IDX == 0);

    memset(&pkt, 0, sizeof(pkt));
    pkt.ready = false;
    41d4:	d8000805 	stb	zero,32(sp)
    41d8:	841bc504 	addi	r16,r16,28436
    bladerf_nios_init(&pkt, &vctcxo_tamer_pkt);
    41dc:	00047580 	call	4758 <bladerf_nios_init>

    /* Initialize packet handlers */
    for (i = 0; i < ARRAY_SIZE(pkt_handlers); i++) {
    41e0:	0023883a 	mov	r17,zero
    41e4:	048001c4 	movi	r18,7
        if (pkt_handlers[i].init != NULL) {
    41e8:	80800017 	ldw	r2,0(r16)
    41ec:	10000126 	beq	r2,zero,41f4 <main+0x6c>
            pkt_handlers[i].init();
    41f0:	103ee83a 	callr	r2
    memset(&pkt, 0, sizeof(pkt));
    pkt.ready = false;
    bladerf_nios_init(&pkt, &vctcxo_tamer_pkt);

    /* Initialize packet handlers */
    for (i = 0; i < ARRAY_SIZE(pkt_handlers); i++) {
    41f4:	88800044 	addi	r2,r17,1
    41f8:	1023883a 	mov	r17,r2
    41fc:	10803fcc 	andi	r2,r2,255
    4200:	84000404 	addi	r16,r16,16
    4204:	14bff81e 	bne	r2,r18,41e8 <main+0x60>
    4208:	04c00034 	movhi	r19,0

INLINE void command_uart_write_response(uint8_t *resp) {
    int i ;
    uint32_t val ;
    for( i = 0 ; i < 16 ; i+=4 ) {
        val = ((uint32_t)resp[i+0]) | (((uint32_t)resp[i+1])<<8) | (((uint32_t)resp[i+2])<<16) | (((uint32_t)resp[i+3])<<24) ;
    420c:	053ffff4 	movhi	r20,65535
    4210:	057ffff4 	movhi	r21,65535
    4214:	05bffff4 	movhi	r22,65535
    4218:	0023883a 	mov	r17,zero
    421c:	0025883a 	mov	r18,zero
    4220:	0021883a 	mov	r16,zero
    4224:	9cdbc404 	addi	r19,r19,28432
    4228:	a51bbc44 	addi	r20,r20,28401
    422c:	ad5bbc84 	addi	r21,r21,28402
    4230:	b59bbc04 	addi	r22,r22,28400
            pkt_handlers[i].init();
        }
    }

    while (run_nios) {
        have_request = HAVE_REQUEST();
    4234:	d8800803 	ldbu	r2,32(sp)
    4238:	d8801005 	stb	r2,64(sp)

        /* We have a command in the UART */
        if (have_request) {
    423c:	d8801003 	ldbu	r2,64(sp)
    4240:	10803fcc 	andi	r2,r2,255
    4244:	10002926 	beq	r2,zero,42ec <main+0x164>
            pkt.ready = false;
    4248:	d8000805 	stb	zero,32(sp)
    424c:	0007883a 	mov	r3,zero
            handler = NULL;
    4250:	000b883a 	mov	r5,zero

            /* Determine which packet handler should receive this message */
            for (i = 0; i < ARRAY_SIZE(pkt_handlers); i++) {
    4254:	01801c04 	movi	r6,112
    4258:	1cc5883a 	add	r2,r3,r19
                if (pkt_handlers[i].magic == *magic) {
    425c:	d9000003 	ldbu	r4,0(sp)
    4260:	11c00003 	ldbu	r7,0(r2)
    4264:	21003fcc 	andi	r4,r4,255
    4268:	39000126 	beq	r7,r4,4270 <main+0xe8>
    426c:	2805883a 	mov	r2,r5
    4270:	18c00404 	addi	r3,r3,16
        if (have_request) {
            pkt.ready = false;
            handler = NULL;

            /* Determine which packet handler should receive this message */
            for (i = 0; i < ARRAY_SIZE(pkt_handlers); i++) {
    4274:	19800226 	beq	r3,r6,4280 <main+0xf8>
    4278:	100b883a 	mov	r5,r2
    427c:	003ff606 	br	4258 <main+0xd0>
                if (pkt_handlers[i].magic == *magic) {
                    handler = &pkt_handlers[i];
                }
            }

            if (handler == NULL) {
    4280:	103fec26 	beq	r2,zero,4234 <main+0xac>
            /* If building with RESET_RESPONSE_BUF defined, reset response buffer
             * contents to ensure unused values are known values. */
            RESET_RESPONSE_BUF();

            /* Process data and execute requested actions */
            handler->exec(&pkt);
    4284:	10800217 	ldw	r2,8(r2)
    4288:	d809883a 	mov	r4,sp
    428c:	103ee83a 	callr	r2
    4290:	01fffff4 	movhi	r7,65535
    4294:	00e44814 	movui	r3,37152
    4298:	39dbbcc4 	addi	r7,r7,28403
}

INLINE void command_uart_write_response(uint8_t *resp) {
    int i ;
    uint32_t val ;
    for( i = 0 ; i < 16 ; i+=4 ) {
    429c:	01a44c14 	movui	r6,37168
    42a0:	d8c5883a 	add	r2,sp,r3
        val = ((uint32_t)resp[i+0]) | (((uint32_t)resp[i+1])<<8) | (((uint32_t)resp[i+2])<<16) | (((uint32_t)resp[i+3])<<24) ;
    42a4:	1509883a 	add	r4,r2,r20
        IOWR_32DIRECT(COMMAND_UART_BASE, i, val) ;
    42a8:	21000003 	ldbu	r4,0(r4)
    42ac:	200a923a 	slli	r5,r4,8

INLINE void command_uart_write_response(uint8_t *resp) {
    int i ;
    uint32_t val ;
    for( i = 0 ; i < 16 ; i+=4 ) {
        val = ((uint32_t)resp[i+0]) | (((uint32_t)resp[i+1])<<8) | (((uint32_t)resp[i+2])<<16) | (((uint32_t)resp[i+3])<<24) ;
    42b0:	1549883a 	add	r4,r2,r21
        IOWR_32DIRECT(COMMAND_UART_BASE, i, val) ;
    42b4:	21000003 	ldbu	r4,0(r4)
    42b8:	2008943a 	slli	r4,r4,16
    42bc:	2908b03a 	or	r4,r5,r4

INLINE void command_uart_write_response(uint8_t *resp) {
    int i ;
    uint32_t val ;
    for( i = 0 ; i < 16 ; i+=4 ) {
        val = ((uint32_t)resp[i+0]) | (((uint32_t)resp[i+1])<<8) | (((uint32_t)resp[i+2])<<16) | (((uint32_t)resp[i+3])<<24) ;
    42c0:	158b883a 	add	r5,r2,r22
    42c4:	11c5883a 	add	r2,r2,r7
        IOWR_32DIRECT(COMMAND_UART_BASE, i, val) ;
    42c8:	10800003 	ldbu	r2,0(r2)
    42cc:	29400003 	ldbu	r5,0(r5)
    42d0:	1004963a 	slli	r2,r2,24
    42d4:	2148b03a 	or	r4,r4,r5
    42d8:	2084b03a 	or	r2,r4,r2
    42dc:	18800035 	stwio	r2,0(r3)
    42e0:	18c00104 	addi	r3,r3,4
}

INLINE void command_uart_write_response(uint8_t *resp) {
    int i ;
    uint32_t val ;
    for( i = 0 ; i < 16 ; i+=4 ) {
    42e4:	19bfee1e 	bne	r3,r6,42a0 <main+0x118>
    42e8:	003fd206 	br	4234 <main+0xac>
            /* Write response to host */
            command_uart_write_response(pkt.resp);
        } else {

            /* Temporarily putting the VCTCXO Calibration stuff here. */
            if( vctcxo_tamer_pkt.ready ) {
    42ec:	d8800903 	ldbu	r2,36(sp)
    42f0:	10803fcc 	andi	r2,r2,255
    42f4:	10004626 	beq	r2,zero,4410 <main+0x288>

                vctcxo_tamer_pkt.ready = false;
    42f8:	d8000905 	stb	zero,36(sp)

                switch(tune_state) {
    42fc:	05c00044 	movi	r23,1
    4300:	85c00b26 	beq	r16,r23,4330 <main+0x1a8>
    4304:	80000526 	beq	r16,zero,431c <main+0x194>
    4308:	00800084 	movi	r2,2
    430c:	80800e26 	beq	r16,r2,4348 <main+0x1c0>
    4310:	008000c4 	movi	r2,3
    4314:	80801b26 	beq	r16,r2,4384 <main+0x1fc>
    4318:	00003906 	br	4400 <main+0x278>

                case COARSE_TUNE_MIN:

                    /* Tune to the minimum DAC value */
                    vctcxo_trim_dac_write( 0x08, trimdac_min );
    431c:	014a3d44 	movi	r5,10485
    4320:	01000204 	movi	r4,8
    4324:	00049780 	call	4978 <vctcxo_trim_dac_write>

                    /* State to enter upon the next interrupt */
                    tune_state = COARSE_TUNE_MAX;
    4328:	b821883a 	mov	r16,r23

                    break;
    432c:	00003406 	br	4400 <main+0x278>
                    /* We have the error from the minimum DAC setting, store it
                     * as the 'x' coordinate for the first point */
                    trimdac_cal_line.point[0].x = vctcxo_tamer_pkt.pps_1s_error;

                    /* Tune to the maximum DAC value */
                    vctcxo_trim_dac_write( 0x08, trimdac_max );
    4330:	017d70d4 	movui	r5,62915
    4334:	01000204 	movi	r4,8

                case COARSE_TUNE_MAX:

                    /* We have the error from the minimum DAC setting, store it
                     * as the 'x' coordinate for the first point */
                    trimdac_cal_line.point[0].x = vctcxo_tamer_pkt.pps_1s_error;
    4338:	dc800a17 	ldw	r18,40(sp)

                    /* Tune to the maximum DAC value */
                    vctcxo_trim_dac_write( 0x08, trimdac_max );

                    /* State to enter upon the next interrupt */
                    tune_state = COARSE_TUNE_DONE;
    433c:	04000084 	movi	r16,2
                    /* We have the error from the minimum DAC setting, store it
                     * as the 'x' coordinate for the first point */
                    trimdac_cal_line.point[0].x = vctcxo_tamer_pkt.pps_1s_error;

                    /* Tune to the maximum DAC value */
                    vctcxo_trim_dac_write( 0x08, trimdac_max );
    4340:	00049780 	call	4978 <vctcxo_trim_dac_write>

                    /* State to enter upon the next interrupt */
                    tune_state = COARSE_TUNE_DONE;

                    break;
    4344:	00002e06 	br	4400 <main+0x278>

                case COARSE_TUNE_DONE:

                    /* We have the error from the maximum DAC setting, store it
                     * as the 'x' coordinate for the second point */
                    trimdac_cal_line.point[1].x = vctcxo_tamer_pkt.pps_1s_error;
    4348:	d9400a17 	ldw	r5,40(sp)

                    /* We now have two points, so we can calculate the equation
                     * for a line plotted with DAC counts on the Y axis and
                     * error on the X axis. We want a PPM of zero, which ideally
                     * corresponds to the y-intercept of the line. */
                    trimdac_cal_line.slope = ( (trimdac_cal_line.point[1].y - trimdac_cal_line.point[0].y) /
    434c:	01333394 	movui	r4,52430

                    /* Set the trim DAC count to the y-intercept */
                    vctcxo_trim_dac_write( 0x08, trimdac_cal_line.y_intercept );

                    /* State to enter upon the next interrupt */
                    tune_state = FINE_TUNE;
    4350:	040000c4 	movi	r16,3

                    /* We now have two points, so we can calculate the equation
                     * for a line plotted with DAC counts on the Y axis and
                     * error on the X axis. We want a PPM of zero, which ideally
                     * corresponds to the y-intercept of the line. */
                    trimdac_cal_line.slope = ( (trimdac_cal_line.point[1].y - trimdac_cal_line.point[0].y) /
    4354:	2c8bc83a 	sub	r5,r5,r18
    4358:	00069540 	call	6954 <__divsi3>
                                               (trimdac_cal_line.point[1].x - trimdac_cal_line.point[0].x) );
                    trimdac_cal_line.y_intercept = ( trimdac_cal_line.point[0].y -
                                                     (trimdac_cal_line.slope * trimdac_cal_line.point[0].x) );

                    /* Set the trim DAC count to the y-intercept */
                    vctcxo_trim_dac_write( 0x08, trimdac_cal_line.y_intercept );
    435c:	900b883a 	mov	r5,r18
    4360:	1009883a 	mov	r4,r2

                    /* We now have two points, so we can calculate the equation
                     * for a line plotted with DAC counts on the Y axis and
                     * error on the X axis. We want a PPM of zero, which ideally
                     * corresponds to the y-intercept of the line. */
                    trimdac_cal_line.slope = ( (trimdac_cal_line.point[1].y - trimdac_cal_line.point[0].y) /
    4364:	1023883a 	mov	r17,r2
                                               (trimdac_cal_line.point[1].x - trimdac_cal_line.point[0].x) );
                    trimdac_cal_line.y_intercept = ( trimdac_cal_line.point[0].y -
                                                     (trimdac_cal_line.slope * trimdac_cal_line.point[0].x) );

                    /* Set the trim DAC count to the y-intercept */
                    vctcxo_trim_dac_write( 0x08, trimdac_cal_line.y_intercept );
    4368:	0006b080 	call	6b08 <__mulsi3>
    436c:	014a3d44 	movi	r5,10485
    4370:	288bc83a 	sub	r5,r5,r2
    4374:	297fffcc 	andi	r5,r5,65535
    4378:	01000204 	movi	r4,8
    437c:	00049780 	call	4978 <vctcxo_trim_dac_write>

                    /* State to enter upon the next interrupt */
                    tune_state = FINE_TUNE;

                    break;
    4380:	00001f06 	br	4400 <main+0x278>
                    /* Check the magnitude of the errors starting with the
                     * one second count. If an error is greater than the maxium
                     * tolerated error, adjust the trim DAC by the error (Hz)
                     * multiplied by the slope (in counts/Hz) and scale the
                     * result by the precision interval (e.g. 1s, 10s, 100s). */
                    if( vctcxo_tamer_pkt.pps_1s_error_flag ) {
    4384:	d8800b03 	ldbu	r2,44(sp)
    4388:	10803fcc 	andi	r2,r2,255
    438c:	10000626 	beq	r2,zero,43a8 <main+0x220>
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
                            ((vctcxo_tamer_pkt.pps_1s_error * trimdac_cal_line.slope)/1)) );
    4390:	d9000a17 	ldw	r4,40(sp)
                     * one second count. If an error is greater than the maxium
                     * tolerated error, adjust the trim DAC by the error (Hz)
                     * multiplied by the slope (in counts/Hz) and scale the
                     * result by the precision interval (e.g. 1s, 10s, 100s). */
                    if( vctcxo_tamer_pkt.pps_1s_error_flag ) {
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
    4394:	880b883a 	mov	r5,r17
    4398:	0006b080 	call	6b08 <__mulsi3>
    439c:	d160000b 	ldhu	r5,-32768(gp)
    43a0:	288bc83a 	sub	r5,r5,r2
    43a4:	00001306 	br	43f4 <main+0x26c>
                            ((vctcxo_tamer_pkt.pps_1s_error * trimdac_cal_line.slope)/1)) );
                    } else if( vctcxo_tamer_pkt.pps_10s_error_flag ) {
    43a8:	d8800d03 	ldbu	r2,52(sp)
    43ac:	10803fcc 	andi	r2,r2,255
    43b0:	10000526 	beq	r2,zero,43c8 <main+0x240>
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
                            ((vctcxo_tamer_pkt.pps_10s_error * trimdac_cal_line.slope)/10)) );
    43b4:	d9400c17 	ldw	r5,48(sp)
                     * result by the precision interval (e.g. 1s, 10s, 100s). */
                    if( vctcxo_tamer_pkt.pps_1s_error_flag ) {
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
                            ((vctcxo_tamer_pkt.pps_1s_error * trimdac_cal_line.slope)/1)) );
                    } else if( vctcxo_tamer_pkt.pps_10s_error_flag ) {
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
    43b8:	8809883a 	mov	r4,r17
    43bc:	0006b080 	call	6b08 <__mulsi3>
    43c0:	017ffd84 	movi	r5,-10
    43c4:	00000706 	br	43e4 <main+0x25c>
                            ((vctcxo_tamer_pkt.pps_10s_error * trimdac_cal_line.slope)/10)) );
                    } else if( vctcxo_tamer_pkt.pps_100s_error_flag ) {
    43c8:	d8800f03 	ldbu	r2,60(sp)
    43cc:	10803fcc 	andi	r2,r2,255
    43d0:	10000b26 	beq	r2,zero,4400 <main+0x278>
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
                            ((vctcxo_tamer_pkt.pps_100s_error * trimdac_cal_line.slope)/100)) );
    43d4:	d9400e17 	ldw	r5,56(sp)
                            ((vctcxo_tamer_pkt.pps_1s_error * trimdac_cal_line.slope)/1)) );
                    } else if( vctcxo_tamer_pkt.pps_10s_error_flag ) {
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
                            ((vctcxo_tamer_pkt.pps_10s_error * trimdac_cal_line.slope)/10)) );
                    } else if( vctcxo_tamer_pkt.pps_100s_error_flag ) {
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
    43d8:	8809883a 	mov	r4,r17
    43dc:	0006b080 	call	6b08 <__mulsi3>
    43e0:	017fe704 	movi	r5,-100
    43e4:	1009883a 	mov	r4,r2
    43e8:	00069540 	call	6954 <__divsi3>
    43ec:	d160000b 	ldhu	r5,-32768(gp)
    43f0:	114b883a 	add	r5,r2,r5
    43f4:	297fffcc 	andi	r5,r5,65535
    43f8:	01000204 	movi	r4,8
    43fc:	00049780 	call	4978 <vctcxo_trim_dac_write>
                    break;

                } /* switch */

                /* Take PPS counters out of reset */
                vctcxo_tamer_reset_counters( false );
    4400:	0009883a 	mov	r4,zero
    4404:	00044fc0 	call	44fc <vctcxo_tamer_reset_counters>

                /* Enable interrupts */
                vctcxo_tamer_enable_isr( true );
    4408:	01000044 	movi	r4,1
    440c:	00044bc0 	call	44bc <vctcxo_tamer_enable_isr>
    4410:	05c00034 	movhi	r23,0
    4414:	bddbc704 	addi	r23,r23,28444

            } /* VCTCXO Tamer interrupt */

            for (i = 0; i < ARRAY_SIZE(pkt_handlers); i++) {
    4418:	0039883a 	mov	fp,zero
    441c:	00c001c4 	movi	r3,7
                if (pkt_handlers[i].do_work != NULL) {
    4420:	b8800017 	ldw	r2,0(r23)
    4424:	10000326 	beq	r2,zero,4434 <main+0x2ac>
                    pkt_handlers[i].do_work();
    4428:	d8c01115 	stw	r3,68(sp)
    442c:	103ee83a 	callr	r2
    4430:	d8c01117 	ldw	r3,68(sp)
                /* Enable interrupts */
                vctcxo_tamer_enable_isr( true );

            } /* VCTCXO Tamer interrupt */

            for (i = 0; i < ARRAY_SIZE(pkt_handlers); i++) {
    4434:	e0800044 	addi	r2,fp,1
    4438:	1039883a 	mov	fp,r2
    443c:	10803fcc 	andi	r2,r2,255
    4440:	bdc00404 	addi	r23,r23,16
    4444:	10fff61e 	bne	r2,r3,4420 <main+0x298>
    4448:	003f7a06 	br	4234 <main+0xac>

0000444c <si5338_complete_transfer>:
    alt_ic_irq_enable(VCTCXO_TAMER_0_IRQ_INTERRUPT_CONTROLLER_ID, VCTCXO_TAMER_0_IRQ);
}

static void si5338_complete_transfer(uint8_t check_rxack)
{
    if ((IORD_8DIRECT(I2C, OC_I2C_CMD_STATUS) & OC_I2C_TIP) == 0) {
    444c:	00a43d14 	movui	r2,37108
    4450:	10c00023 	ldbuio	r3,0(r2)
    4454:	18c0008c 	andi	r3,r3,2
    4458:	183ffd26 	beq	r3,zero,4450 <si5338_complete_transfer+0x4>
        while ( (IORD_8DIRECT(I2C, OC_I2C_CMD_STATUS) & OC_I2C_TIP) == 0);
    }

    while (IORD_8DIRECT(I2C, OC_I2C_CMD_STATUS) & OC_I2C_TIP);
    445c:	10c00023 	ldbuio	r3,0(r2)
    4460:	18c0008c 	andi	r3,r3,2
    4464:	183ffd1e 	bne	r3,zero,445c <si5338_complete_transfer+0x10>

    while (check_rxack && (IORD_8DIRECT(I2C, OC_I2C_CMD_STATUS) & OC_I2C_RXACK));
    4468:	21003fcc 	andi	r4,r4,255
    446c:	00e43d14 	movui	r3,37108
    4470:	20000326 	beq	r4,zero,4480 <si5338_complete_transfer+0x34>
    4474:	18800023 	ldbuio	r2,0(r3)
    4478:	1080200c 	andi	r2,r2,128
    447c:	103ffc1e 	bne	r2,zero,4470 <si5338_complete_transfer+0x24>
    4480:	f800283a 	ret

00004484 <command_uart_isr>:
    uint32_t val = enable ? 1 : 0 ;
    IOWR_32DIRECT(COMMAND_UART_BASE, 16, val) ;
    return ;
}

static void command_uart_isr(void *context) {
    4484:	2005883a 	mov	r2,r4
    struct pkt_buf *pkt = (struct pkt_buf *)context ;

    /* Reading the request should clear the interrupt */
    command_uart_read_request((uint8_t *)pkt->req) ;
    4488:	00e44814 	movui	r3,37152
}

INLINE void command_uart_read_request(uint8_t *req) {
    int i, x ;
    uint32_t val ;
    for( x = 0 ; x < 16 ; x+=4 ) {
    448c:	01a44c14 	movui	r6,37168
        val = IORD_32DIRECT(COMMAND_UART_BASE, x) ;
    4490:	19400037 	ldwio	r5,0(r3)
    4494:	11c00104 	addi	r7,r2,4
        for( i = 0 ; i < 4 ; i++ ) {
            req[x+i] = val&0xff ;
    4498:	11400005 	stb	r5,0(r2)
    449c:	10800044 	addi	r2,r2,1
            val >>= 8 ;
    44a0:	280ad23a 	srli	r5,r5,8
INLINE void command_uart_read_request(uint8_t *req) {
    int i, x ;
    uint32_t val ;
    for( x = 0 ; x < 16 ; x+=4 ) {
        val = IORD_32DIRECT(COMMAND_UART_BASE, x) ;
        for( i = 0 ; i < 4 ; i++ ) {
    44a4:	11fffc1e 	bne	r2,r7,4498 <command_uart_isr+0x14>
    44a8:	18c00104 	addi	r3,r3,4
}

INLINE void command_uart_read_request(uint8_t *req) {
    int i, x ;
    uint32_t val ;
    for( x = 0 ; x < 16 ; x+=4 ) {
    44ac:	19bff81e 	bne	r3,r6,4490 <command_uart_isr+0xc>

    /* Tell the main loop that there is a request pending */
    pkt->ready = true ;
    44b0:	00800044 	movi	r2,1
    44b4:	20800805 	stb	r2,32(r4)
    44b8:	f800283a 	ret

000044bc <vctcxo_tamer_enable_isr>:

    return;
}

void vctcxo_tamer_enable_isr(bool enable) {
    if( enable ) {
    44bc:	21003fcc 	andi	r4,r4,255
    44c0:	d0a00e03 	ldbu	r2,-32712(gp)
    44c4:	20000226 	beq	r4,zero,44d0 <vctcxo_tamer_enable_isr+0x14>
        vctcxo_tamer_ctrl_reg |= VT_CTRL_IRQ_EN;
    44c8:	10800414 	ori	r2,r2,16
    44cc:	00000106 	br	44d4 <vctcxo_tamer_enable_isr+0x18>
    } else {
        vctcxo_tamer_ctrl_reg &= ~VT_CTRL_IRQ_EN;
    44d0:	10803bcc 	andi	r2,r2,239
    44d4:	d0a00e05 	stb	r2,-32712(gp)
uint8_t vctcxo_tamer_read(uint8_t addr) {
    return (uint8_t)IORD_8DIRECT(VCTCXO_TAMER_0_BASE, addr);
}

void vctcxo_tamer_write(uint8_t addr, uint8_t data) {
    IOWR_8DIRECT(VCTCXO_TAMER_0_BASE, addr, data);
    44d8:	d0e00e03 	ldbu	r3,-32712(gp)
    44dc:	00a4c014 	movui	r2,37632
    44e0:	10c00025 	stbio	r3,0(r2)
    44e4:	f800283a 	ret

000044e8 <vctcxo_tamer_clear_isr>:
    44e8:	d0a00e03 	ldbu	r2,-32712(gp)
    44ec:	00e4c014 	movui	r3,37632
    44f0:	10800814 	ori	r2,r2,32
    44f4:	18800025 	stbio	r2,0(r3)
    44f8:	f800283a 	ret

000044fc <vctcxo_tamer_reset_counters>:
    vctcxo_tamer_write(VT_CTRL_ADDR, vctcxo_tamer_ctrl_reg | VT_CTRL_IRQ_CLR);
    return;
}

void vctcxo_tamer_reset_counters(bool reset) {
    if( reset ) {
    44fc:	21003fcc 	andi	r4,r4,255
    4500:	d0a00e03 	ldbu	r2,-32712(gp)
    4504:	20000226 	beq	r4,zero,4510 <vctcxo_tamer_reset_counters+0x14>
        vctcxo_tamer_ctrl_reg |= VT_CTRL_RESET;
    4508:	10800054 	ori	r2,r2,1
    450c:	00000106 	br	4514 <vctcxo_tamer_reset_counters+0x18>
    } else {
        vctcxo_tamer_ctrl_reg &= ~VT_CTRL_RESET;
    4510:	10803f8c 	andi	r2,r2,254
    4514:	d0a00e05 	stb	r2,-32712(gp)
uint8_t vctcxo_tamer_read(uint8_t addr) {
    return (uint8_t)IORD_8DIRECT(VCTCXO_TAMER_0_BASE, addr);
}

void vctcxo_tamer_write(uint8_t addr, uint8_t data) {
    IOWR_8DIRECT(VCTCXO_TAMER_0_BASE, addr, data);
    4518:	d0e00e03 	ldbu	r3,-32712(gp)
    451c:	00a4c014 	movui	r2,37632
    4520:	10c00025 	stbio	r3,0(r2)
    4524:	f800283a 	ret

00004528 <vctcxo_tamer_set_tune_mode.part.0>:

    vctcxo_tamer_write(VT_CTRL_ADDR, vctcxo_tamer_ctrl_reg);
    return;
}

void vctcxo_tamer_set_tune_mode(bladerf_vctcxo_tamer_mode mode) {
    4528:	defffd04 	addi	sp,sp,-12
    452c:	dc000015 	stw	r16,0(sp)
    4530:	2021883a 	mov	r16,r4

    switch (mode) {
        case BLADERF_VCTCXO_TAMER_DISABLED:
        case BLADERF_VCTCXO_TAMER_1_PPS:
        case BLADERF_VCTCXO_TAMER_10_MHZ:
            vctcxo_tamer_enable_isr(false);
    4534:	0009883a 	mov	r4,zero

    vctcxo_tamer_write(VT_CTRL_ADDR, vctcxo_tamer_ctrl_reg);
    return;
}

void vctcxo_tamer_set_tune_mode(bladerf_vctcxo_tamer_mode mode) {
    4538:	dfc00215 	stw	ra,8(sp)
    453c:	dc400115 	stw	r17,4(sp)

    switch (mode) {
        case BLADERF_VCTCXO_TAMER_DISABLED:
        case BLADERF_VCTCXO_TAMER_1_PPS:
        case BLADERF_VCTCXO_TAMER_10_MHZ:
            vctcxo_tamer_enable_isr(false);
    4540:	00044bc0 	call	44bc <vctcxo_tamer_enable_isr>
            return;
    }

    /* Set tuning mode */
    vctcxo_tamer_ctrl_reg &= ~VT_CTRL_TUNE_MODE;
    vctcxo_tamer_ctrl_reg |= (((uint8_t) mode) << 6);
    4544:	80803fcc 	andi	r2,r16,255
    4548:	100691ba 	slli	r3,r2,6
    454c:	d0a00e03 	ldbu	r2,-32712(gp)
    4550:	10800fcc 	andi	r2,r2,63
    4554:	1884b03a 	or	r2,r3,r2
    4558:	d0a00e05 	stb	r2,-32712(gp)
uint8_t vctcxo_tamer_read(uint8_t addr) {
    return (uint8_t)IORD_8DIRECT(VCTCXO_TAMER_0_BASE, addr);
}

void vctcxo_tamer_write(uint8_t addr, uint8_t data) {
    IOWR_8DIRECT(VCTCXO_TAMER_0_BASE, addr, data);
    455c:	00e4c014 	movui	r3,37632
    4560:	18800025 	stbio	r2,0(r3)
    vctcxo_tamer_ctrl_reg &= ~VT_CTRL_TUNE_MODE;
    vctcxo_tamer_ctrl_reg |= (((uint8_t) mode) << 6);
    vctcxo_tamer_write(VT_CTRL_ADDR, vctcxo_tamer_ctrl_reg);

    /* Reset the counters */
    vctcxo_tamer_reset_counters( true );
    4564:	04400044 	movi	r17,1
    4568:	8809883a 	mov	r4,r17
    456c:	00044fc0 	call	44fc <vctcxo_tamer_reset_counters>

    /* Take counters out of reset if tuning mode is not DISABLED */
    if( mode != 0x00 ) {
    4570:	80000a26 	beq	r16,zero,459c <vctcxo_tamer_set_tune_mode.part.0+0x74>
        vctcxo_tamer_reset_counters( false );
    4574:	0009883a 	mov	r4,zero
    }

    switch (mode) {
    4578:	843fffc4 	addi	r16,r16,-1
    /* Reset the counters */
    vctcxo_tamer_reset_counters( true );

    /* Take counters out of reset if tuning mode is not DISABLED */
    if( mode != 0x00 ) {
        vctcxo_tamer_reset_counters( false );
    457c:	00044fc0 	call	44fc <vctcxo_tamer_reset_counters>
    }

    switch (mode) {
    4580:	8c000636 	bltu	r17,r16,459c <vctcxo_tamer_set_tune_mode.part.0+0x74>
        case BLADERF_VCTCXO_TAMER_1_PPS:
        case BLADERF_VCTCXO_TAMER_10_MHZ:
            vctcxo_tamer_enable_isr(true);
    4584:	8809883a 	mov	r4,r17
            /* Leave ISR disabled otherwise */
            break;
    }

    return;
}
    4588:	dfc00217 	ldw	ra,8(sp)
    458c:	dc400117 	ldw	r17,4(sp)
    4590:	dc000017 	ldw	r16,0(sp)
    4594:	dec00304 	addi	sp,sp,12
    }

    switch (mode) {
        case BLADERF_VCTCXO_TAMER_1_PPS:
        case BLADERF_VCTCXO_TAMER_10_MHZ:
            vctcxo_tamer_enable_isr(true);
    4598:	00044bc1 	jmpi	44bc <vctcxo_tamer_enable_isr>
            /* Leave ISR disabled otherwise */
            break;
    }

    return;
}
    459c:	dfc00217 	ldw	ra,8(sp)
    45a0:	dc400117 	ldw	r17,4(sp)
    45a4:	dc000017 	ldw	r16,0(sp)
    45a8:	dec00304 	addi	sp,sp,12
    45ac:	f800283a 	ret

000045b0 <vctcxo_tamer_set_tune_mode>:
    return;
}

void vctcxo_tamer_set_tune_mode(bladerf_vctcxo_tamer_mode mode) {

    switch (mode) {
    45b0:	00800084 	movi	r2,2
    45b4:	11000136 	bltu	r2,r4,45bc <vctcxo_tamer_set_tune_mode+0xc>
            /* Leave ISR disabled otherwise */
            break;
    }

    return;
}
    45b8:	00045281 	jmpi	4528 <vctcxo_tamer_set_tune_mode.part.0>
    45bc:	f800283a 	ret

000045c0 <vctcxo_tamer_get_tune_mode>:

    return value;
}

uint8_t vctcxo_tamer_read(uint8_t addr) {
    return (uint8_t)IORD_8DIRECT(VCTCXO_TAMER_0_BASE, addr);
    45c0:	00a4c014 	movui	r2,37632
    45c4:	10800023 	ldbuio	r2,0(r2)
bladerf_vctcxo_tamer_mode vctcxo_tamer_get_tune_mode()
{
    uint8_t tmp = vctcxo_tamer_read(VT_CTRL_ADDR);
    tmp = (tmp & VT_CTRL_TUNE_MODE) >> 6;

    switch (tmp) {
    45c8:	00c00084 	movi	r3,2
}

bladerf_vctcxo_tamer_mode vctcxo_tamer_get_tune_mode()
{
    uint8_t tmp = vctcxo_tamer_read(VT_CTRL_ADDR);
    tmp = (tmp & VT_CTRL_TUNE_MODE) >> 6;
    45cc:	10803fcc 	andi	r2,r2,255

    switch (tmp) {
    45d0:	1004d1ba 	srli	r2,r2,6
    45d4:	1880012e 	bgeu	r3,r2,45dc <vctcxo_tamer_get_tune_mode+0x1c>
        case BLADERF_VCTCXO_TAMER_1_PPS:
        case BLADERF_VCTCXO_TAMER_10_MHZ:
            return (bladerf_vctcxo_tamer_mode) tmp;

        default:
            return BLADERF_VCTCXO_TAMER_INVALID;
    45d8:	00bfffc4 	movi	r2,-1
    }
}
    45dc:	f800283a 	ret

000045e0 <vctcxo_tamer_read_count>:
int32_t vctcxo_tamer_read_count(uint8_t addr) {
    uint32_t base = VCTCXO_TAMER_0_BASE;
    uint8_t offset = addr;
    int32_t value = 0;

    value  = IORD_8DIRECT(base, offset++);
    45e0:	20803fcc 	andi	r2,r4,255
    45e4:	0164c014 	movui	r5,37632
    45e8:	1145883a 	add	r2,r2,r5
    45ec:	10800023 	ldbuio	r2,0(r2)
    45f0:	11803fcc 	andi	r6,r2,255
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 8;
    45f4:	20800044 	addi	r2,r4,1
    45f8:	10803fcc 	andi	r2,r2,255
    45fc:	1145883a 	add	r2,r2,r5
    4600:	10800023 	ldbuio	r2,0(r2)
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 16;
    4604:	20c00084 	addi	r3,r4,2
    4608:	18c03fcc 	andi	r3,r3,255
    uint32_t base = VCTCXO_TAMER_0_BASE;
    uint8_t offset = addr;
    int32_t value = 0;

    value  = IORD_8DIRECT(base, offset++);
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 8;
    460c:	10803fcc 	andi	r2,r2,255
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 16;
    4610:	1947883a 	add	r3,r3,r5
    4614:	18c00023 	ldbuio	r3,0(r3)
    4618:	18c03fcc 	andi	r3,r3,255
    461c:	1806943a 	slli	r3,r3,16
    4620:	1004923a 	slli	r2,r2,8
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 24;
    4624:	210000c4 	addi	r4,r4,3
    4628:	21003fcc 	andi	r4,r4,255
    uint8_t offset = addr;
    int32_t value = 0;

    value  = IORD_8DIRECT(base, offset++);
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 8;
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 16;
    462c:	10c4b03a 	or	r2,r2,r3
    4630:	1184b03a 	or	r2,r2,r6
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 24;
    4634:	2149883a 	add	r4,r4,r5
    4638:	20c00023 	ldbuio	r3,0(r4)

    return value;
    463c:	1806963a 	slli	r3,r3,24
}
    4640:	1884b03a 	or	r2,r3,r2
    4644:	f800283a 	ret

00004648 <vctcxo_tamer_isr>:
    pkt->ready = true ;

    return ;
}

static void vctcxo_tamer_isr(void *context) {
    4648:	defffd04 	addi	sp,sp,-12
    464c:	dc000015 	stw	r16,0(sp)
    4650:	2021883a 	mov	r16,r4
    struct vctcxo_tamer_pkt_buf *pkt = (struct vctcxo_tamer_pkt_buf *)context;
    uint8_t error_status = 0x00;

    /* Disable interrupts */
    vctcxo_tamer_enable_isr( false );
    4654:	0009883a 	mov	r4,zero
    pkt->ready = true ;

    return ;
}

static void vctcxo_tamer_isr(void *context) {
    4658:	dfc00215 	stw	ra,8(sp)
    465c:	dc400115 	stw	r17,4(sp)
    struct vctcxo_tamer_pkt_buf *pkt = (struct vctcxo_tamer_pkt_buf *)context;
    uint8_t error_status = 0x00;

    /* Disable interrupts */
    vctcxo_tamer_enable_isr( false );
    4660:	00044bc0 	call	44bc <vctcxo_tamer_enable_isr>

    /* Reset (stop) the counters */
    vctcxo_tamer_reset_counters( true );
    4664:	04400044 	movi	r17,1
    4668:	8809883a 	mov	r4,r17
    466c:	00044fc0 	call	44fc <vctcxo_tamer_reset_counters>

    /* Read the current count values */
    pkt->pps_1s_error   = vctcxo_tamer_read_count(VT_ERR_1S_ADDR);
    4670:	01000104 	movi	r4,4
    4674:	00045e00 	call	45e0 <vctcxo_tamer_read_count>
    4678:	80800115 	stw	r2,4(r16)
    pkt->pps_10s_error  = vctcxo_tamer_read_count(VT_ERR_10S_ADDR);
    467c:	01000304 	movi	r4,12
    4680:	00045e00 	call	45e0 <vctcxo_tamer_read_count>
    4684:	80800315 	stw	r2,12(r16)
    pkt->pps_100s_error = vctcxo_tamer_read_count(VT_ERR_100S_ADDR);
    4688:	01000504 	movi	r4,20
    468c:	00045e00 	call	45e0 <vctcxo_tamer_read_count>
    4690:	80800515 	stw	r2,20(r16)

    return value;
}

uint8_t vctcxo_tamer_read(uint8_t addr) {
    return (uint8_t)IORD_8DIRECT(VCTCXO_TAMER_0_BASE, addr);
    4694:	00a4c054 	movui	r2,37633
    4698:	10c00023 	ldbuio	r3,0(r2)
    469c:	18c03fcc 	andi	r3,r3,255
    46a0:	18803fcc 	andi	r2,r3,255

    /* Read the error status register */
    error_status = vctcxo_tamer_read(VT_STAT_ADDR);

    /* Set the appropriate flags in the packet buffer */
    pkt->pps_1s_error_flag   = (error_status & VT_STAT_ERR_1S)   ? true : false;
    46a4:	1c46703a 	and	r3,r3,r17
    46a8:	80c00205 	stb	r3,8(r16)
    pkt->pps_10s_error_flag  = (error_status & VT_STAT_ERR_10S)  ? true : false;
    46ac:	1446d83a 	srl	r3,r2,r17
    pkt->pps_100s_error_flag = (error_status & VT_STAT_ERR_100S) ? true : false;
    46b0:	1004d0ba 	srli	r2,r2,2
    /* Read the error status register */
    error_status = vctcxo_tamer_read(VT_STAT_ADDR);

    /* Set the appropriate flags in the packet buffer */
    pkt->pps_1s_error_flag   = (error_status & VT_STAT_ERR_1S)   ? true : false;
    pkt->pps_10s_error_flag  = (error_status & VT_STAT_ERR_10S)  ? true : false;
    46b4:	1c46703a 	and	r3,r3,r17
    46b8:	80c00405 	stb	r3,16(r16)
    pkt->pps_100s_error_flag = (error_status & VT_STAT_ERR_100S) ? true : false;
    46bc:	1444703a 	and	r2,r2,r17
    46c0:	80800605 	stb	r2,24(r16)

    /* Clear interrupt */
    vctcxo_tamer_clear_isr();
    46c4:	00044e80 	call	44e8 <vctcxo_tamer_clear_isr>

    /* Tell the main loop that there is a request pending */
    pkt->ready = true;
    46c8:	84400005 	stb	r17,0(r16)

    return;
}
    46cc:	dfc00217 	ldw	ra,8(sp)
    46d0:	dc400117 	ldw	r17,4(sp)
    46d4:	dc000017 	ldw	r16,0(sp)
    46d8:	dec00304 	addi	sp,sp,12
    46dc:	f800283a 	ret

000046e0 <vctcxo_tamer_read>:

    return value;
}

uint8_t vctcxo_tamer_read(uint8_t addr) {
    return (uint8_t)IORD_8DIRECT(VCTCXO_TAMER_0_BASE, addr);
    46e0:	00a4c014 	movui	r2,37632
    46e4:	21003fcc 	andi	r4,r4,255
    46e8:	2089883a 	add	r4,r4,r2
}
    46ec:	20800023 	ldbuio	r2,0(r4)
    46f0:	f800283a 	ret

000046f4 <vctcxo_tamer_write>:

void vctcxo_tamer_write(uint8_t addr, uint8_t data) {
    IOWR_8DIRECT(VCTCXO_TAMER_0_BASE, addr, data);
    46f4:	00a4c014 	movui	r2,37632
    46f8:	21003fcc 	andi	r4,r4,255
    46fc:	2089883a 	add	r4,r4,r2
    4700:	21400025 	stbio	r5,0(r4)
    4704:	f800283a 	ret

00004708 <tamer_schedule>:
}

void tamer_schedule(bladerf_module m, uint64_t time) {
    uint32_t base = (m == BLADERF_MODULE_RX) ? RX_TAMER_BASE : TX_TAMER_BASE ;
    4708:	20000226 	beq	r4,zero,4714 <tamer_schedule+0xc>
    470c:	00a45014 	movui	r2,37184
    4710:	00000106 	br	4718 <tamer_schedule+0x10>
    4714:	00a45814 	movui	r2,37216

    /* Set the holding time */
    IOWR_8DIRECT(base, 0, (time>> 0)&0xff) ;
    4718:	11400025 	stbio	r5,0(r2)
    IOWR_8DIRECT(base, 1, (time>> 8)&0xff) ;
    471c:	2806d23a 	srli	r3,r5,8
    4720:	10c00065 	stbio	r3,1(r2)
    IOWR_8DIRECT(base, 2, (time>>16)&0xff) ;
    4724:	2806d43a 	srli	r3,r5,16
    4728:	10c000a5 	stbio	r3,2(r2)
    IOWR_8DIRECT(base, 3, (time>>24)&0xff) ;
    472c:	280ad63a 	srli	r5,r5,24
    4730:	114000e5 	stbio	r5,3(r2)
    IOWR_8DIRECT(base, 4, (time>>32)&0xff) ;
    4734:	11800125 	stbio	r6,4(r2)
    IOWR_8DIRECT(base, 5, (time>>40)&0xff) ;
    4738:	3006d23a 	srli	r3,r6,8
    473c:	10c00165 	stbio	r3,5(r2)
    IOWR_8DIRECT(base, 6, (time>>48)&0xff) ;
    4740:	3006d43a 	srli	r3,r6,16
    4744:	10c001a5 	stbio	r3,6(r2)
    IOWR_8DIRECT(base, 7, (time>>54)&0xff) ;
    4748:	300cd5ba 	srli	r6,r6,22
    474c:	118001e5 	stbio	r6,7(r2)

    /* Commit it and arm the comparison */
    IOWR_8DIRECT(base, 8, 0) ;
    4750:	10000225 	stbio	zero,8(r2)
    4754:	f800283a 	ret

00004758 <bladerf_nios_init>:

    return ;
}

void bladerf_nios_init(struct pkt_buf *pkt, struct vctcxo_tamer_pkt_buf *vctcxo_tamer_pkt) {
    4758:	defffc04 	addi	sp,sp,-16
    475c:	dc400215 	stw	r17,8(sp)
    4760:	dfc00315 	stw	ra,12(sp)
    4764:	dc000115 	stw	r16,4(sp)
    4768:	2823883a 	mov	r17,r5
    /* Set the prescaler for 400kHz with an 80MHz clock:
     *      (prescaler = clock / (5*desired) - 1)
     */
    IOWR_16DIRECT(I2C, OC_I2C_PRESCALER, 39);
    476c:	00a43c14 	movui	r2,37104
    4770:	00c009c4 	movi	r3,39
    4774:	10c0002d 	sthio	r3,0(r2)
    IOWR_8DIRECT(I2C, OC_I2C_CTRL, OC_I2C_ENABLE);
    4778:	00a43c94 	movui	r2,37106
    477c:	00ffe004 	movi	r3,-128
    4780:	10c00025 	stbio	r3,0(r2)

    /* Set the IQ Correction parameters to 0 */
    IOWR_ALTERA_AVALON_PIO_DATA(IQ_CORR_RX_PHASE_GAIN_BASE, DEFAULT_CORRECTION);
    4784:	00840004 	movi	r2,4096
    4788:	00e43414 	movui	r3,37072
    478c:	18800035 	stwio	r2,0(r3)
    IOWR_ALTERA_AVALON_PIO_DATA(IQ_CORR_TX_PHASE_GAIN_BASE, DEFAULT_CORRECTION);
    4790:	00e43014 	movui	r3,37056
    4794:	18800035 	stwio	r2,0(r3)

    /* Disable all triggering */
    IOWR_ALTERA_AVALON_PIO_DATA(TX_TRIGGER_CTL_BASE, 0x00);
    4798:	0005883a 	mov	r2,zero
    479c:	00e50814 	movui	r3,37920
    47a0:	18800035 	stwio	r2,0(r3)
    IOWR_ALTERA_AVALON_PIO_DATA(RX_TRIGGER_CTL_BASE, 0x00);
    47a4:	00e50014 	movui	r3,37888
    47a8:	18800035 	stwio	r2,0(r3)

    /* Register Command UART ISR */
    alt_ic_isr_register(
    47ac:	040001c4 	movi	r16,7
    47b0:	01800034 	movhi	r6,0
    47b4:	200f883a 	mov	r7,r4
    47b8:	800b883a 	mov	r5,r16
    47bc:	d8000015 	stw	zero,0(sp)
    47c0:	31912104 	addi	r6,r6,17540
    47c4:	0009883a 	mov	r4,zero
    47c8:	0006b780 	call	6b78 <alt_ic_isr_register>
        pkt,
        NULL
    ) ;

    /* Register the VCTCXO Tamer ISR */
    alt_ic_isr_register(
    47cc:	01800034 	movhi	r6,0
    47d0:	880f883a 	mov	r7,r17
    47d4:	31919204 	addi	r6,r6,17992
    47d8:	000b883a 	mov	r5,zero
    47dc:	d8000015 	stw	zero,0(sp)
    47e0:	0009883a 	mov	r4,zero
    47e4:	0006b780 	call	6b78 <alt_ic_isr_register>
    47e8:	0009883a 	mov	r4,zero
    47ec:	00045280 	call	4528 <vctcxo_tamer_set_tune_mode.part.0>
/* Define a cached version of the VCTCXO tamer control register */
uint8_t vctcxo_tamer_ctrl_reg = 0x00;

static void command_uart_enable_isr(bool enable) {
    uint32_t val = enable ? 1 : 0 ;
    IOWR_32DIRECT(COMMAND_UART_BASE, 16, val) ;
    47f0:	00a44c14 	movui	r2,37168
    47f4:	00c00044 	movi	r3,1
    47f8:	10c00035 	stwio	r3,0(r2)
    /* Default VCTCXO Tamer and its interrupts to be disabled. */
    vctcxo_tamer_set_tune_mode(BLADERF_VCTCXO_TAMER_DISABLED);

    /* Enable interrupts */
    command_uart_enable_isr(true) ;
    alt_ic_irq_enable(COMMAND_UART_IRQ_INTERRUPT_CONTROLLER_ID, COMMAND_UART_IRQ);
    47fc:	800b883a 	mov	r5,r16
    4800:	0009883a 	mov	r4,zero
    4804:	0006b7c0 	call	6b7c <alt_ic_irq_enable>
    alt_ic_irq_enable(VCTCXO_TAMER_0_IRQ_INTERRUPT_CONTROLLER_ID, VCTCXO_TAMER_0_IRQ);
    4808:	000b883a 	mov	r5,zero
    480c:	0009883a 	mov	r4,zero
}
    4810:	dfc00317 	ldw	ra,12(sp)
    4814:	dc400217 	ldw	r17,8(sp)
    4818:	dc000117 	ldw	r16,4(sp)
    481c:	dec00404 	addi	sp,sp,16
    vctcxo_tamer_set_tune_mode(BLADERF_VCTCXO_TAMER_DISABLED);

    /* Enable interrupts */
    command_uart_enable_isr(true) ;
    alt_ic_irq_enable(COMMAND_UART_IRQ_INTERRUPT_CONTROLLER_ID, COMMAND_UART_IRQ);
    alt_ic_irq_enable(VCTCXO_TAMER_0_IRQ_INTERRUPT_CONTROLLER_ID, VCTCXO_TAMER_0_IRQ);
    4820:	0006b7c1 	jmpi	6b7c <alt_ic_irq_enable>

00004824 <lms6_read>:

uint8_t lms6_read(uint8_t addr)
{
    uint8_t data;

    data = IORD_8DIRECT(LMS_SPI_BASE, addr);
    4824:	00a48014 	movui	r2,37376
    4828:	21003fcc 	andi	r4,r4,255
    482c:	2089883a 	add	r4,r4,r2

    return data;
}
    4830:	20800023 	ldbuio	r2,0(r4)
    4834:	f800283a 	ret

00004838 <lms6_write>:

void lms6_write(uint8_t addr, uint8_t data)
{
    IOWR_8DIRECT(LMS_SPI_BASE, addr, data);
    4838:	00a48014 	movui	r2,37376
    483c:	21003fcc 	andi	r4,r4,255
    4840:	2089883a 	add	r4,r4,r2
    4844:	21400025 	stbio	r5,0(r4)
    4848:	f800283a 	ret

0000484c <si5338_read>:
}

uint8_t si5338_read(uint8_t addr)
{
    484c:	defffa04 	addi	sp,sp,-24
    4850:	dd000415 	stw	r20,16(sp)
    4854:	dc000015 	stw	r16,0(sp)
    4858:	dfc00515 	stw	ra,20(sp)
    485c:	dcc00315 	stw	r19,12(sp)
    4860:	dc800215 	stw	r18,8(sp)
    4864:	dc400115 	stw	r17,4(sp)
    4868:	2029883a 	mov	r20,r4
    uint8_t data;

    /* Set the address to the Si5338 */
    IOWR_8DIRECT(I2C, OC_I2C_DATA, SI5338_I2C);
    486c:	04243cd4 	movui	r16,37107
    4870:	00bff804 	movi	r2,-32
    4874:	80800025 	stbio	r2,0(r16)
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_STA | OC_I2C_WR);
    4878:	04ffe404 	movi	r19,-112
    487c:	04643d14 	movui	r17,37108
    4880:	8cc00025 	stbio	r19,0(r17)
    si5338_complete_transfer(1);
    4884:	04800044 	movi	r18,1
    4888:	9009883a 	mov	r4,r18
    488c:	000444c0 	call	444c <si5338_complete_transfer>

    IOWR_8DIRECT(I2C, OC_I2C_DATA, addr);
    4890:	85000025 	stbio	r20,0(r16)
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_WR | OC_I2C_STO);
    4894:	00801404 	movi	r2,80
    4898:	88800025 	stbio	r2,0(r17)
    si5338_complete_transfer(1) ;
    489c:	9009883a 	mov	r4,r18
    48a0:	000444c0 	call	444c <si5338_complete_transfer>

    /* Next transfer is a read operation, so '1' in the read/write bit */
    IOWR_8DIRECT(I2C, OC_I2C_DATA, SI5338_I2C | 1);
    48a4:	00bff844 	movi	r2,-31
    48a8:	80800025 	stbio	r2,0(r16)
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_STA | OC_I2C_WR);
    48ac:	8cc00025 	stbio	r19,0(r17)
    si5338_complete_transfer(1) ;
    48b0:	9009883a 	mov	r4,r18
    48b4:	000444c0 	call	444c <si5338_complete_transfer>

    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_RD | OC_I2C_NACK | OC_I2C_STO);
    48b8:	00801a04 	movi	r2,104
    48bc:	88800025 	stbio	r2,0(r17)
    si5338_complete_transfer(0);
    48c0:	0009883a 	mov	r4,zero
    48c4:	000444c0 	call	444c <si5338_complete_transfer>

    data = IORD_8DIRECT(I2C, OC_I2C_DATA);
    return data;
}
    48c8:	80800023 	ldbuio	r2,0(r16)
    48cc:	dfc00517 	ldw	ra,20(sp)
    48d0:	dd000417 	ldw	r20,16(sp)
    48d4:	dcc00317 	ldw	r19,12(sp)
    48d8:	dc800217 	ldw	r18,8(sp)
    48dc:	dc400117 	ldw	r17,4(sp)
    48e0:	dc000017 	ldw	r16,0(sp)
    48e4:	dec00604 	addi	sp,sp,24
    48e8:	f800283a 	ret

000048ec <si5338_write>:

void si5338_write(uint8_t addr, uint8_t data)
{
    48ec:	defffa04 	addi	sp,sp,-24
    48f0:	dd000415 	stw	r20,16(sp)
    48f4:	dcc00315 	stw	r19,12(sp)
    48f8:	dc400115 	stw	r17,4(sp)
    48fc:	dfc00515 	stw	ra,20(sp)
    4900:	dc800215 	stw	r18,8(sp)
    4904:	dc000015 	stw	r16,0(sp)
    4908:	2029883a 	mov	r20,r4
    490c:	2827883a 	mov	r19,r5
    /* Set the address to the Si5338 */
    IOWR_8DIRECT(I2C, OC_I2C_DATA, SI5338_I2C) ;
    4910:	04643cd4 	movui	r17,37107
    4914:	00bff804 	movi	r2,-32
    4918:	88800025 	stbio	r2,0(r17)
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_STA | OC_I2C_WR);
    491c:	04243d14 	movui	r16,37108
    4920:	00bfe404 	movi	r2,-112
    4924:	80800025 	stbio	r2,0(r16)
    si5338_complete_transfer(1);
    4928:	04800044 	movi	r18,1
    492c:	9009883a 	mov	r4,r18
    4930:	000444c0 	call	444c <si5338_complete_transfer>

    IOWR_8DIRECT(I2C, OC_I2C_DATA, addr);
    4934:	8d000025 	stbio	r20,0(r17)
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_CMD_STATUS | OC_I2C_WR);
    4938:	00800504 	movi	r2,20
    493c:	80800025 	stbio	r2,0(r16)
    si5338_complete_transfer(1);
    4940:	9009883a 	mov	r4,r18
    4944:	000444c0 	call	444c <si5338_complete_transfer>

    IOWR_8DIRECT(I2C, OC_I2C_DATA, data);
    4948:	8cc00025 	stbio	r19,0(r17)
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_WR | OC_I2C_STO);
    494c:	00801404 	movi	r2,80
    4950:	80800025 	stbio	r2,0(r16)
    si5338_complete_transfer(0);
    4954:	0009883a 	mov	r4,zero
}
    4958:	dfc00517 	ldw	ra,20(sp)
    495c:	dd000417 	ldw	r20,16(sp)
    4960:	dcc00317 	ldw	r19,12(sp)
    4964:	dc800217 	ldw	r18,8(sp)
    4968:	dc400117 	ldw	r17,4(sp)
    496c:	dc000017 	ldw	r16,0(sp)
    4970:	dec00604 	addi	sp,sp,24
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_CMD_STATUS | OC_I2C_WR);
    si5338_complete_transfer(1);

    IOWR_8DIRECT(I2C, OC_I2C_DATA, data);
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_WR | OC_I2C_STO);
    si5338_complete_transfer(0);
    4974:	000444c1 	jmpi	444c <si5338_complete_transfer>

00004978 <vctcxo_trim_dac_write>:
}

void vctcxo_trim_dac_write(uint8_t cmd, uint16_t val)
{
    uint8_t data[3] = {
    4978:	2804d23a 	srli	r2,r5,8
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_WR | OC_I2C_STO);
    si5338_complete_transfer(0);
}

void vctcxo_trim_dac_write(uint8_t cmd, uint16_t val)
{
    497c:	defffb04 	addi	sp,sp,-20
    uint8_t data[3] = {
    4980:	d9000305 	stb	r4,12(sp)
    4984:	d9400385 	stb	r5,14(sp)
        (val >> 8) & 0xff,
        val & 0xff,
    };

    /* Update cached value of trim DAC setting */
    vctcxo_trim_dac_value = val;
    4988:	d160000d 	sth	r5,-32768(gp)

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 3, data, 0, 0, 0) ;
    498c:	d8000215 	stw	zero,8(sp)
    4990:	d8000115 	stw	zero,4(sp)
    4994:	d8000015 	stw	zero,0(sp)
    4998:	d9c00304 	addi	r7,sp,12
    499c:	018000c4 	movi	r6,3
    49a0:	000b883a 	mov	r5,zero
    49a4:	01241814 	movui	r4,36960
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_WR | OC_I2C_STO);
    si5338_complete_transfer(0);
}

void vctcxo_trim_dac_write(uint8_t cmd, uint16_t val)
{
    49a8:	dfc00415 	stw	ra,16(sp)
    uint8_t data[3] = {
    49ac:	d8800345 	stb	r2,13(sp)
    };

    /* Update cached value of trim DAC setting */
    vctcxo_trim_dac_value = val;

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 3, data, 0, 0, 0) ;
    49b0:	0006da00 	call	6da0 <alt_avalon_spi_command>
}
    49b4:	dfc00417 	ldw	ra,16(sp)
    49b8:	dec00504 	addi	sp,sp,20
    49bc:	f800283a 	ret

000049c0 <vctcxo_trim_dac_read>:

void vctcxo_trim_dac_read(uint8_t cmd, uint16_t *val)
{
    49c0:	defff804 	addi	sp,sp,-32
    49c4:	dc000515 	stw	r16,20(sp)
    uint8_t data[2];

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 1, &cmd, 0, 0, ALT_AVALON_SPI_COMMAND_MERGE);
    49c8:	01800044 	movi	r6,1
    49cc:	04241814 	movui	r16,36960

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 3, data, 0, 0, 0) ;
}

void vctcxo_trim_dac_read(uint8_t cmd, uint16_t *val)
{
    49d0:	dc400615 	stw	r17,24(sp)
    49d4:	d9000405 	stb	r4,16(sp)
    49d8:	2823883a 	mov	r17,r5
    uint8_t data[2];

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 1, &cmd, 0, 0, ALT_AVALON_SPI_COMMAND_MERGE);
    49dc:	d9800215 	stw	r6,8(sp)
    49e0:	d9c00404 	addi	r7,sp,16
    49e4:	8009883a 	mov	r4,r16
    49e8:	d8000115 	stw	zero,4(sp)
    49ec:	d8000015 	stw	zero,0(sp)
    49f0:	000b883a 	mov	r5,zero

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 3, data, 0, 0, 0) ;
}

void vctcxo_trim_dac_read(uint8_t cmd, uint16_t *val)
{
    49f4:	dfc00715 	stw	ra,28(sp)
    uint8_t data[2];

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 1, &cmd, 0, 0, ALT_AVALON_SPI_COMMAND_MERGE);
    49f8:	0006da00 	call	6da0 <alt_avalon_spi_command>
    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 0, 0, 2, &data, 0);
    49fc:	d8800304 	addi	r2,sp,12
    4a00:	d8800115 	stw	r2,4(sp)
    4a04:	00800084 	movi	r2,2
    4a08:	d8000215 	stw	zero,8(sp)
    4a0c:	d8800015 	stw	r2,0(sp)
    4a10:	000f883a 	mov	r7,zero
    4a14:	000d883a 	mov	r6,zero
    4a18:	000b883a 	mov	r5,zero
    4a1c:	8009883a 	mov	r4,r16
    4a20:	0006da00 	call	6da0 <alt_avalon_spi_command>

    *val = (data[0] << 8) | data[1];
    4a24:	d8800303 	ldbu	r2,12(sp)
    4a28:	1006923a 	slli	r3,r2,8
    4a2c:	d8800343 	ldbu	r2,13(sp)
    4a30:	1884b03a 	or	r2,r3,r2
    4a34:	8880000d 	sth	r2,0(r17)
}
    4a38:	dfc00717 	ldw	ra,28(sp)
    4a3c:	dc400617 	ldw	r17,24(sp)
    4a40:	dc000517 	ldw	r16,20(sp)
    4a44:	dec00804 	addi	sp,sp,32
    4a48:	f800283a 	ret

00004a4c <adf4351_write>:

void adf4351_write(uint32_t val)
{
    4a4c:	defffb04 	addi	sp,sp,-20
        uint32_t val;
        uint8_t byte[4];
    } sval;

    uint8_t t;
    sval.val = val;
    4a50:	d9000315 	stw	r4,12(sp)

    t = sval.byte[0];
    sval.byte[0] = sval.byte[3];
    4a54:	d88003c3 	ldbu	r2,15(sp)
    sval.byte[3] = t;

    t = sval.byte[1];
    sval.byte[1] = sval.byte[2];
    4a58:	d8c00383 	ldbu	r3,14(sp)
    uint8_t t;
    sval.val = val;

    t = sval.byte[0];
    sval.byte[0] = sval.byte[3];
    sval.byte[3] = t;
    4a5c:	d90003c5 	stb	r4,15(sp)

    uint8_t t;
    sval.val = val;

    t = sval.byte[0];
    sval.byte[0] = sval.byte[3];
    4a60:	d8800305 	stb	r2,12(sp)
    sval.byte[3] = t;

    t = sval.byte[1];
    4a64:	d8800343 	ldbu	r2,13(sp)
    sval.byte[1] = sval.byte[2];
    sval.byte[2] = t;

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 1, 4, (uint8_t*)&sval.val, 0, 0, 0);
    4a68:	d8000215 	stw	zero,8(sp)
    4a6c:	d8000115 	stw	zero,4(sp)
    4a70:	d8000015 	stw	zero,0(sp)
    4a74:	d9c00304 	addi	r7,sp,12
    4a78:	01800104 	movi	r6,4
    4a7c:	01400044 	movi	r5,1
    4a80:	01241814 	movui	r4,36960

    *val = (data[0] << 8) | data[1];
}

void adf4351_write(uint32_t val)
{
    4a84:	dfc00415 	stw	ra,16(sp)
    t = sval.byte[0];
    sval.byte[0] = sval.byte[3];
    sval.byte[3] = t;

    t = sval.byte[1];
    sval.byte[1] = sval.byte[2];
    4a88:	d8c00345 	stb	r3,13(sp)
    sval.byte[2] = t;
    4a8c:	d8800385 	stb	r2,14(sp)

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 1, 4, (uint8_t*)&sval.val, 0, 0, 0);
    4a90:	0006da00 	call	6da0 <alt_avalon_spi_command>
}
    4a94:	dfc00417 	ldw	ra,16(sp)
    4a98:	dec00504 	addi	sp,sp,20
    4a9c:	f800283a 	ret

00004aa0 <iqbal_get_gain>:

static inline uint32_t module_to_iqcorr_base(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
    4aa0:	20000226 	beq	r4,zero,4aac <iqbal_get_gain+0xc>
        return IQ_CORR_RX_PHASE_GAIN_BASE;
    } else {
        return IQ_CORR_TX_PHASE_GAIN_BASE;
    4aa4:	00a43014 	movui	r2,37056
    4aa8:	00000106 	br	4ab0 <iqbal_get_gain+0x10>
}

static inline uint32_t module_to_iqcorr_base(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
        return IQ_CORR_RX_PHASE_GAIN_BASE;
    4aac:	00a43414 	movui	r2,37072
uint16_t iqbal_get_gain(bladerf_module m)
{
    const uint32_t base = module_to_iqcorr_base(m);
    const uint32_t regval = IORD_ALTERA_AVALON_PIO_DATA(base);
    return (uint16_t) regval;
}
    4ab0:	10800037 	ldwio	r2,0(r2)
    4ab4:	f800283a 	ret

00004ab8 <iqbal_set_gain>:
    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 1, 4, (uint8_t*)&sval.val, 0, 0, 0);
}

static inline uint32_t module_to_iqcorr_base(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
    4ab8:	20000226 	beq	r4,zero,4ac4 <iqbal_set_gain+0xc>
        return IQ_CORR_RX_PHASE_GAIN_BASE;
    } else {
        return IQ_CORR_TX_PHASE_GAIN_BASE;
    4abc:	00e43014 	movui	r3,37056
    4ac0:	00000106 	br	4ac8 <iqbal_set_gain+0x10>
}

static inline uint32_t module_to_iqcorr_base(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
        return IQ_CORR_RX_PHASE_GAIN_BASE;
    4ac4:	00e43414 	movui	r3,37072
}

void iqbal_set_gain(bladerf_module m, uint16_t value)
{
    const uint32_t base = module_to_iqcorr_base(m);
    uint32_t regval = IORD_ALTERA_AVALON_PIO_DATA(base);
    4ac8:	18800037 	ldwio	r2,0(r3)

    regval &= 0xffff0000;
    4acc:	10bfffec 	andhi	r2,r2,65535
    regval |= value;

    IOWR_ALTERA_AVALON_PIO_DATA(base, regval);
    4ad0:	297fffcc 	andi	r5,r5,65535
    4ad4:	288ab03a 	or	r5,r5,r2
    4ad8:	19400035 	stwio	r5,0(r3)
    4adc:	f800283a 	ret

00004ae0 <iqbal_get_phase>:

uint16_t iqbal_get_phase(bladerf_module m)
{
    uint32_t regval;

    if (m == BLADERF_MODULE_RX) {
    4ae0:	2000021e 	bne	r4,zero,4aec <iqbal_get_phase+0xc>
        regval = IORD_ALTERA_AVALON_PIO_DATA(IQ_CORR_RX_PHASE_GAIN_BASE);
    4ae4:	00a43414 	movui	r2,37072
    4ae8:	00000106 	br	4af0 <iqbal_get_phase+0x10>
    } else {
        regval = IORD_ALTERA_AVALON_PIO_DATA(IQ_CORR_TX_PHASE_GAIN_BASE);
    4aec:	00a43014 	movui	r2,37056
    4af0:	10800037 	ldwio	r2,0(r2)
    }

    return (uint16_t) (regval >> 16);
}
    4af4:	1004d43a 	srli	r2,r2,16
    4af8:	f800283a 	ret

00004afc <iqbal_set_phase>:
    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 1, 4, (uint8_t*)&sval.val, 0, 0, 0);
}

static inline uint32_t module_to_iqcorr_base(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
    4afc:	20000226 	beq	r4,zero,4b08 <iqbal_set_phase+0xc>
        return IQ_CORR_RX_PHASE_GAIN_BASE;
    } else {
        return IQ_CORR_TX_PHASE_GAIN_BASE;
    4b00:	00e43014 	movui	r3,37056
    4b04:	00000106 	br	4b0c <iqbal_set_phase+0x10>
}

static inline uint32_t module_to_iqcorr_base(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
        return IQ_CORR_RX_PHASE_GAIN_BASE;
    4b08:	00e43414 	movui	r3,37072
}

void iqbal_set_phase(bladerf_module m, uint16_t value)
{
    const uint32_t base = module_to_iqcorr_base(m);
    uint32_t regval = IORD_ALTERA_AVALON_PIO_DATA(base);
    4b0c:	18800037 	ldwio	r2,0(r3)

    regval &= 0x0000ffff;
    regval |= ((uint32_t) value) << 16;

    IOWR_ALTERA_AVALON_PIO_DATA(base, regval);
    4b10:	280a943a 	slli	r5,r5,16
void iqbal_set_phase(bladerf_module m, uint16_t value)
{
    const uint32_t base = module_to_iqcorr_base(m);
    uint32_t regval = IORD_ALTERA_AVALON_PIO_DATA(base);

    regval &= 0x0000ffff;
    4b14:	10bfffcc 	andi	r2,r2,65535
    regval |= ((uint32_t) value) << 16;

    IOWR_ALTERA_AVALON_PIO_DATA(base, regval);
    4b18:	288ab03a 	or	r5,r5,r2
    4b1c:	19400035 	stwio	r5,0(r3)
    4b20:	f800283a 	ret

00004b24 <tx_trigger_ctl_write>:
}

void tx_trigger_ctl_write(uint8_t data)
{
  IOWR_ALTERA_AVALON_PIO_DATA(TX_TRIGGER_CTL_BASE, data);
    4b24:	21003fcc 	andi	r4,r4,255
    4b28:	00a50814 	movui	r2,37920
    4b2c:	11000035 	stwio	r4,0(r2)
    4b30:	f800283a 	ret

00004b34 <tx_trigger_ctl_read>:
}

uint8_t tx_trigger_ctl_read(void)
{
  return IORD_ALTERA_AVALON_PIO_DATA(TX_TRIGGER_CTL_BASE);
}
    4b34:	00a50814 	movui	r2,37920
    4b38:	10800037 	ldwio	r2,0(r2)
    4b3c:	f800283a 	ret

00004b40 <rx_trigger_ctl_write>:

void rx_trigger_ctl_write(uint8_t data)
{
  IOWR_ALTERA_AVALON_PIO_DATA(RX_TRIGGER_CTL_BASE, data);
    4b40:	21003fcc 	andi	r4,r4,255
    4b44:	00a50014 	movui	r2,37888
    4b48:	11000035 	stwio	r4,0(r2)
    4b4c:	f800283a 	ret

00004b50 <rx_trigger_ctl_read>:
}

uint8_t rx_trigger_ctl_read(void)
{
  return IORD_ALTERA_AVALON_PIO_DATA(RX_TRIGGER_CTL_BASE);
}
    4b50:	00a50014 	movui	r2,37888
    4b54:	10800037 	ldwio	r2,0(r2)
    4b58:	f800283a 	ret

00004b5c <time_tamer_read>:

uint64_t time_tamer_read(bladerf_module m)
{
    uint32_t base = (m == BLADERF_MODULE_RX) ? RX_TAMER_BASE : TX_TAMER_BASE ;
    4b5c:	20000226 	beq	r4,zero,4b68 <time_tamer_read+0xc>
    4b60:	01245014 	movui	r4,37184
    4b64:	00000106 	br	4b6c <time_tamer_read+0x10>
    4b68:	01245814 	movui	r4,37216
    uint8_t offset = 0;
    uint64_t value = 0;

    value  = IORD_8DIRECT(base, offset++);
    4b6c:	20c00023 	ldbuio	r3,0(r4)
    4b70:	19403fcc 	andi	r5,r3,255
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 8;
    4b74:	20c00063 	ldbuio	r3,1(r4)
    4b78:	18c03fcc 	andi	r3,r3,255
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 16;
    4b7c:	208000a3 	ldbuio	r2,2(r4)
    4b80:	10803fcc 	andi	r2,r2,255
    4b84:	1806923a 	slli	r3,r3,8
    4b88:	1004943a 	slli	r2,r2,16
    4b8c:	1884b03a 	or	r2,r3,r2
    4b90:	1146b03a 	or	r3,r2,r5
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 24;
    4b94:	208000e3 	ldbuio	r2,3(r4)
    4b98:	1004963a 	slli	r2,r2,24
    4b9c:	10c4b03a 	or	r2,r2,r3
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 32;
    4ba0:	21800123 	ldbuio	r6,4(r4)
    4ba4:	31c03fcc 	andi	r7,r6,255
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 40;
    4ba8:	21400163 	ldbuio	r5,5(r4)
    4bac:	29403fcc 	andi	r5,r5,255
    4bb0:	280a923a 	slli	r5,r5,8
    4bb4:	29ccb03a 	or	r6,r5,r7
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 48;
    4bb8:	214001a3 	ldbuio	r5,6(r4)
    4bbc:	29403fcc 	andi	r5,r5,255
    4bc0:	280a943a 	slli	r5,r5,16
    4bc4:	298ab03a 	or	r5,r5,r6
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 56;
    4bc8:	20c001e3 	ldbuio	r3,7(r4)

    return value;
    4bcc:	1806963a 	slli	r3,r3,24
}
    4bd0:	1946b03a 	or	r3,r3,r5
    4bd4:	f800283a 	ret

00004bd8 <pkt_32x32>:

    return true;
}

void pkt_32x32(struct pkt_buf *b)
{
    4bd8:	20800143 	ldbu	r2,5(r4)
    4bdc:	21400183 	ldbu	r5,6(r4)
    4be0:	21800103 	ldbu	r6,4(r4)
    4be4:	1004923a 	slli	r2,r2,8
    4be8:	280a943a 	slli	r5,r5,16
    4bec:	21c00203 	ldbu	r7,8(r4)
    4bf0:	1186b03a 	or	r3,r2,r6
    4bf4:	28c4b03a 	or	r2,r5,r3
    4bf8:	214001c3 	ldbu	r5,7(r4)
    4bfc:	20c00243 	ldbu	r3,9(r4)
    4c00:	22000083 	ldbu	r8,2(r4)
    4c04:	280a963a 	slli	r5,r5,24
    4c08:	1806923a 	slli	r3,r3,8
static inline void nios_pkt_32x32_unpack(const uint8_t *buf, uint8_t *target,
                                        bool *write, uint32_t *addr,
                                        uint32_t *data)
{
    if (target != NULL) {
        *target = buf[NIOS_PKT_32x32_IDX_TARGET_ID];
    4c0c:	22800043 	ldbu	r10,1(r4)
    4c10:	288ab03a 	or	r5,r5,r2
    4c14:	20800283 	ldbu	r2,10(r4)
    4c18:	19ccb03a 	or	r6,r3,r7
    4c1c:	1004943a 	slli	r2,r2,16
    4c20:	1186b03a 	or	r3,r2,r6
    4c24:	208002c3 	ldbu	r2,11(r4)
    bool is_write;
    bool success;

    nios_pkt_32x32_unpack(b->req, &id, &is_write, &addr, &data);

    if (is_write) {
    4c28:	4180004c 	andi	r6,r8,1
    4c2c:	1004963a 	slli	r2,r2,24
    4c30:	10c4b03a 	or	r2,r2,r3
    4c34:	50c03fcc 	andi	r3,r10,255
    4c38:	30001a26 	beq	r6,zero,4ca4 <pkt_32x32+0xcc>
#include "devices.h"
#include "debug.h"

static inline bool perform_write(uint8_t id, uint32_t addr, uint32_t data)
{
    switch (id) {
    4c3c:	18000326 	beq	r3,zero,4c4c <pkt_32x32+0x74>
    4c40:	01c00044 	movi	r7,1
    4c44:	19c00c26 	beq	r3,r7,4c78 <pkt_32x32+0xa0>
    4c48:	00002206 	br	4cd4 <pkt_32x32+0xfc>
        /* The address is used as a bitmask for the expansion IO registers.
         * We'll skip RMWs if all bits are being written */
        case NIOS_PKT_32x32_TARGET_EXP:
            if (addr != 0xffffffff) {
    4c4c:	00ffffc4 	movi	r3,-1
    4c50:	01e42c14 	movui	r7,37040
    4c54:	28c00626 	beq	r5,r3,4c70 <pkt_32x32+0x98>
    IOWR_ALTERA_AVALON_PIO_DATA(CONTROL_BASE, value);
}

static inline uint32_t expansion_port_read(void)
{
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE);
    4c58:	38c00037 	ldwio	r3,0(r7)
}

INLINE void expansion_port_write(uint32_t value)
{
    IOWR_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE, value);
    4c5c:	10d0f03a 	xor	r8,r2,r3
    4c60:	4150703a 	and	r8,r8,r5
    4c64:	40c6f03a 	xor	r3,r8,r3
    4c68:	38c00035 	stwio	r3,0(r7)
    4c6c:	00001706 	br	4ccc <pkt_32x32+0xf4>
    4c70:	38800035 	stwio	r2,0(r7)
    4c74:	00001506 	br	4ccc <pkt_32x32+0xf4>
                expansion_port_write(data);
            }
            break;

        case NIOS_PKT_32x32_TARGET_EXP_DIR:
            if (addr != 0xffffffff) {
    4c78:	01ffffc4 	movi	r7,-1
    4c7c:	02242814 	movui	r8,37024
    4c80:	29c00626 	beq	r5,r7,4c9c <pkt_32x32+0xc4>
}

INLINE uint32_t expansion_port_get_direction()
{
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_DIR_BASE);
    4c84:	41c00037 	ldwio	r7,0(r8)
}

INLINE void expansion_port_set_direction(uint32_t dir)
{
    IOWR_ALTERA_AVALON_PIO_DATA(XB_GPIO_DIR_BASE, dir);
    4c88:	11d2f03a 	xor	r9,r2,r7
    4c8c:	4952703a 	and	r9,r9,r5
    4c90:	49cef03a 	xor	r7,r9,r7
    4c94:	41c00035 	stwio	r7,0(r8)
    4c98:	00000f06 	br	4cd8 <pkt_32x32+0x100>
    4c9c:	40800035 	stwio	r2,0(r8)
    4ca0:	00000d06 	br	4cd8 <pkt_32x32+0x100>
    return true;
}

static inline bool perform_read(uint8_t id, uint32_t addr, uint32_t *data)
{
    switch (id) {
    4ca4:	18000626 	beq	r3,zero,4cc0 <pkt_32x32+0xe8>
    4ca8:	01c00044 	movi	r7,1
    4cac:	19c0091e 	bne	r3,r7,4cd4 <pkt_32x32+0xfc>
    IOWR_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE, value);
}

INLINE uint32_t expansion_port_get_direction()
{
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_DIR_BASE);
    4cb0:	00a42814 	movui	r2,37024
    4cb4:	10800037 	ldwio	r2,0(r2)
        case NIOS_PKT_32x32_TARGET_EXP:
            *data = expansion_port_read() & addr;
            break;

        case NIOS_PKT_32x32_TARGET_EXP_DIR:
            *data = expansion_port_get_direction() & addr;
    4cb8:	1144703a 	and	r2,r2,r5
    4cbc:	00000606 	br	4cd8 <pkt_32x32+0x100>
    IOWR_ALTERA_AVALON_PIO_DATA(CONTROL_BASE, value);
}

static inline uint32_t expansion_port_read(void)
{
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE);
    4cc0:	00a42c14 	movui	r2,37040
    4cc4:	10800037 	ldwio	r2,0(r2)
static inline bool perform_read(uint8_t id, uint32_t addr, uint32_t *data)
{
    switch (id) {
        /* The address is used as a bitmask for the expansion IO registers */
        case NIOS_PKT_32x32_TARGET_EXP:
            *data = expansion_port_read() & addr;
    4cc8:	1144703a 	and	r2,r2,r5
        default:
            DBG("Invalid ID: 0x%02x\n", id);
            return false;
    }

    return true;
    4ccc:	00c00044 	movi	r3,1
    4cd0:	00000106 	br	4cd8 <pkt_32x32+0x100>

        */

        default:
            DBG("Invalid ID: 0x%02x\n", id);
            return false;
    4cd4:	0007883a 	mov	r3,zero

/* Pack the request buffer */
static inline void nios_pkt_32x32_pack(uint8_t *buf, uint8_t target, bool write,
                                       uint32_t addr, uint32_t data)
{
    buf[NIOS_PKT_32x32_IDX_MAGIC]     = NIOS_PKT_32x32_MAGIC;
    4cd8:	01c012c4 	movi	r7,75
    4cdc:	21c00405 	stb	r7,16(r4)
    buf[NIOS_PKT_32x32_IDX_TARGET_ID] = target;
    4ce0:	22800445 	stb	r10,17(r4)

    if (write) {
    4ce4:	30000326 	beq	r6,zero,4cf4 <pkt_32x32+0x11c>
        buf[NIOS_PKT_32x32_IDX_FLAGS] = NIOS_PKT_32x32_FLAG_WRITE;
    4ce8:	01800044 	movi	r6,1
    4cec:	21800485 	stb	r6,18(r4)
    4cf0:	00000106 	br	4cf8 <pkt_32x32+0x120>
    } else {
        buf[NIOS_PKT_32x32_IDX_FLAGS] = 0x00;
    4cf4:	20000485 	stb	zero,18(r4)
    }

    buf[NIOS_PKT_32x32_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_32x32_IDX_ADDR + 0] = (addr >> 0);
    buf[NIOS_PKT_32x32_IDX_ADDR + 1] = (addr >> 8);
    4cf8:	280cd23a 	srli	r6,r5,8
        buf[NIOS_PKT_32x32_IDX_FLAGS] = 0x00;
    }

    buf[NIOS_PKT_32x32_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_32x32_IDX_ADDR + 0] = (addr >> 0);
    4cfc:	21400505 	stb	r5,20(r4)
    buf[NIOS_PKT_32x32_IDX_ADDR + 1] = (addr >> 8);
    buf[NIOS_PKT_32x32_IDX_ADDR + 2] = (addr >> 16);
    buf[NIOS_PKT_32x32_IDX_ADDR + 3] = (addr >> 24);

    buf[NIOS_PKT_32x32_IDX_DATA + 0] = (data >> 0);
    4d00:	20800605 	stb	r2,24(r4)
    }

    buf[NIOS_PKT_32x32_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_32x32_IDX_ADDR + 0] = (addr >> 0);
    buf[NIOS_PKT_32x32_IDX_ADDR + 1] = (addr >> 8);
    4d04:	21800545 	stb	r6,21(r4)
    buf[NIOS_PKT_32x32_IDX_ADDR + 2] = (addr >> 16);
    4d08:	280cd43a 	srli	r6,r5,16
    buf[NIOS_PKT_32x32_IDX_ADDR + 3] = (addr >> 24);
    4d0c:	280ad63a 	srli	r5,r5,24
        buf[NIOS_PKT_32x32_IDX_FLAGS] = NIOS_PKT_32x32_FLAG_WRITE;
    } else {
        buf[NIOS_PKT_32x32_IDX_FLAGS] = 0x00;
    }

    buf[NIOS_PKT_32x32_IDX_RESV1] = 0x00;
    4d10:	200004c5 	stb	zero,19(r4)

    buf[NIOS_PKT_32x32_IDX_ADDR + 0] = (addr >> 0);
    buf[NIOS_PKT_32x32_IDX_ADDR + 1] = (addr >> 8);
    buf[NIOS_PKT_32x32_IDX_ADDR + 2] = (addr >> 16);
    4d14:	21800585 	stb	r6,22(r4)
    buf[NIOS_PKT_32x32_IDX_ADDR + 3] = (addr >> 24);
    4d18:	214005c5 	stb	r5,23(r4)

    buf[NIOS_PKT_32x32_IDX_DATA + 0] = (data >> 0);
    buf[NIOS_PKT_32x32_IDX_DATA + 1] = (data >> 8);
    4d1c:	100ad23a 	srli	r5,r2,8
    buf[NIOS_PKT_32x32_IDX_DATA + 2] = (data >> 16);
    buf[NIOS_PKT_32x32_IDX_DATA + 3] = (data >> 24);

    buf[NIOS_PKT_32x32_IDX_RESV2 + 0] = 0x00;
    4d20:	20000705 	stb	zero,28(r4)
    buf[NIOS_PKT_32x32_IDX_RESV2 + 1] = 0x00;
    4d24:	20000745 	stb	zero,29(r4)
    buf[NIOS_PKT_32x32_IDX_ADDR + 1] = (addr >> 8);
    buf[NIOS_PKT_32x32_IDX_ADDR + 2] = (addr >> 16);
    buf[NIOS_PKT_32x32_IDX_ADDR + 3] = (addr >> 24);

    buf[NIOS_PKT_32x32_IDX_DATA + 0] = (data >> 0);
    buf[NIOS_PKT_32x32_IDX_DATA + 1] = (data >> 8);
    4d28:	21400645 	stb	r5,25(r4)
    buf[NIOS_PKT_32x32_IDX_DATA + 2] = (data >> 16);
    4d2c:	100ad43a 	srli	r5,r2,16
    buf[NIOS_PKT_32x32_IDX_DATA + 3] = (data >> 24);
    4d30:	1004d63a 	srli	r2,r2,24

    buf[NIOS_PKT_32x32_IDX_RESV2 + 0] = 0x00;
    buf[NIOS_PKT_32x32_IDX_RESV2 + 1] = 0x00;
    buf[NIOS_PKT_32x32_IDX_RESV2 + 2] = 0x00;
    4d34:	20000785 	stb	zero,30(r4)
    buf[NIOS_PKT_32x32_IDX_ADDR + 2] = (addr >> 16);
    buf[NIOS_PKT_32x32_IDX_ADDR + 3] = (addr >> 24);

    buf[NIOS_PKT_32x32_IDX_DATA + 0] = (data >> 0);
    buf[NIOS_PKT_32x32_IDX_DATA + 1] = (data >> 8);
    buf[NIOS_PKT_32x32_IDX_DATA + 2] = (data >> 16);
    4d38:	21400685 	stb	r5,26(r4)
    buf[NIOS_PKT_32x32_IDX_DATA + 3] = (data >> 24);
    4d3c:	208006c5 	stb	r2,27(r4)

    buf[NIOS_PKT_32x32_IDX_RESV2 + 0] = 0x00;
    buf[NIOS_PKT_32x32_IDX_RESV2 + 1] = 0x00;
    buf[NIOS_PKT_32x32_IDX_RESV2 + 2] = 0x00;
    buf[NIOS_PKT_32x32_IDX_RESV2 + 3] = 0x00;
    4d40:	200007c5 	stb	zero,31(r4)
                                            bool write, uint32_t addr,
                                            uint32_t data, bool success)
{
    nios_pkt_32x32_pack(buf, target, write, addr, data);

    if (success) {
    4d44:	18c03fcc 	andi	r3,r3,255
    4d48:	18000326 	beq	r3,zero,4d58 <pkt_32x32+0x180>
        buf[NIOS_PKT_32x32_IDX_FLAGS] |= NIOS_PKT_32x32_FLAG_SUCCESS;
    4d4c:	20800483 	ldbu	r2,18(r4)
    4d50:	10800094 	ori	r2,r2,2
    4d54:	20800485 	stb	r2,18(r4)
    4d58:	f800283a 	ret

00004d5c <pkt_8x16>:

    return true;
}

void pkt_8x16(struct pkt_buf *b)
{
    4d5c:	defff804 	addi	sp,sp,-32
    4d60:	dc400215 	stw	r17,8(sp)
    4d64:	dc000115 	stw	r16,4(sp)
    4d68:	dfc00715 	stw	ra,28(sp)
    4d6c:	dd400615 	stw	r21,24(sp)
    4d70:	dd000515 	stw	r20,20(sp)
    4d74:	dcc00415 	stw	r19,16(sp)
    4d78:	dc800315 	stw	r18,12(sp)
    if (addr != NULL) {
        *addr   = buf[NIOS_PKT_8x16_IDX_ADDR];
    }

    if (data != NULL) {
        *data   = (buf[NIOS_PKT_8x16_IDX_DATA + 0] << 0) |
    4d7c:	21400183 	ldbu	r5,6(r4)
    4d80:	20800143 	ldbu	r2,5(r4)
    4d84:	25400083 	ldbu	r21,2(r4)
    4d88:	280a923a 	slli	r5,r5,8
static inline void nios_pkt_8x16_unpack(const uint8_t *buf, uint8_t *target,
                                       bool *write, uint8_t *addr,
                                       uint16_t *data)
{
    if (target != NULL) {
        *target = buf[NIOS_PKT_8x16_IDX_TARGET_ID];
    4d8c:	25000043 	ldbu	r20,1(r4)
    bool is_write;
    bool success;

    nios_pkt_8x16_unpack(b->req, &id, &is_write, &addr, &data);

    if (is_write) {
    4d90:	ad40004c 	andi	r21,r21,1
    if (addr != NULL) {
        *addr   = buf[NIOS_PKT_8x16_IDX_ADDR];
    }

    if (data != NULL) {
        *data   = (buf[NIOS_PKT_8x16_IDX_DATA + 0] << 0) |
    4d94:	288ab03a 	or	r5,r5,r2
    4d98:	d940000d 	sth	r5,0(sp)

    return true;
}

void pkt_8x16(struct pkt_buf *b)
{
    4d9c:	2023883a 	mov	r17,r4
    if (write != NULL) {
        *write  = (buf[NIOS_PKT_8x16_IDX_FLAGS] & NIOS_PKT_8x16_FLAG_WRITE) != 0;
    }

    if (addr != NULL) {
        *addr   = buf[NIOS_PKT_8x16_IDX_ADDR];
    4da0:	24800103 	ldbu	r18,4(r4)
    4da4:	a4003fcc 	andi	r16,r20,255
    bool is_write;
    bool success;

    nios_pkt_8x16_unpack(b->req, &id, &is_write, &addr, &data);

    if (is_write) {
    4da8:	a8001e26 	beq	r21,zero,4e24 <pkt_8x16+0xc8>
}


static inline bool perform_write(uint8_t id, uint8_t addr, uint16_t data)
{
    switch (id) {
    4dac:	80000326 	beq	r16,zero,4dbc <pkt_8x16+0x60>
    4db0:	00800044 	movi	r2,1
    4db4:	80800526 	beq	r16,r2,4dcc <pkt_8x16+0x70>
    4db8:	00003706 	br	4e98 <pkt_8x16+0x13c>
        case NIOS_PKT_8x16_TARGET_VCTCXO_DAC:
            vctcxo_trim_dac_write(addr, data);
    4dbc:	297fffcc 	andi	r5,r5,65535
    4dc0:	91003fcc 	andi	r4,r18,255
    4dc4:	00049780 	call	4978 <vctcxo_trim_dac_write>
    4dc8:	00001d06 	br	4e40 <pkt_8x16+0xe4>
    return true;
}

static inline bool iq_corr_write(uint8_t addr, uint16_t data)
{
    switch (addr) {
    4dcc:	94c03fcc 	andi	r19,r18,255
    4dd0:	9c000c26 	beq	r19,r16,4e04 <pkt_8x16+0xa8>
    4dd4:	98000826 	beq	r19,zero,4df8 <pkt_8x16+0x9c>
    4dd8:	00800084 	movi	r2,2
    4ddc:	98800d26 	beq	r19,r2,4e14 <pkt_8x16+0xb8>
    4de0:	008000c4 	movi	r2,3
    4de4:	98802d1e 	bne	r19,r2,4e9c <pkt_8x16+0x140>
        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_GAIN:
            iqbal_set_gain(BLADERF_MODULE_TX, data);
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_PHASE:
            iqbal_set_phase(BLADERF_MODULE_TX, data);
    4de8:	297fffcc 	andi	r5,r5,65535
    4dec:	8009883a 	mov	r4,r16
    4df0:	0004afc0 	call	4afc <iqbal_set_phase>
    4df4:	00002906 	br	4e9c <pkt_8x16+0x140>

static inline bool iq_corr_write(uint8_t addr, uint16_t data)
{
    switch (addr) {
        case NIOS_PKT_8x16_ADDR_IQ_CORR_RX_GAIN:
            iqbal_set_gain(BLADERF_MODULE_RX, data);
    4df8:	297fffcc 	andi	r5,r5,65535
    4dfc:	0009883a 	mov	r4,zero
    4e00:	00000606 	br	4e1c <pkt_8x16+0xc0>
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_RX_PHASE:
            iqbal_set_phase(BLADERF_MODULE_RX, data);
    4e04:	297fffcc 	andi	r5,r5,65535
    4e08:	0009883a 	mov	r4,zero
    4e0c:	0004afc0 	call	4afc <iqbal_set_phase>
    4e10:	00000b06 	br	4e40 <pkt_8x16+0xe4>
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_GAIN:
            iqbal_set_gain(BLADERF_MODULE_TX, data);
    4e14:	297fffcc 	andi	r5,r5,65535
    4e18:	8009883a 	mov	r4,r16
    4e1c:	0004ab80 	call	4ab8 <iqbal_set_gain>
    4e20:	00001e06 	br	4e9c <pkt_8x16+0x140>

static inline bool perform_read(uint8_t id, uint8_t addr, uint16_t *data)
{
    bool success = true;

    switch (id) {
    4e24:	80000326 	beq	r16,zero,4e34 <pkt_8x16+0xd8>
    4e28:	00800044 	movi	r2,1
    4e2c:	80800626 	beq	r16,r2,4e48 <pkt_8x16+0xec>
    4e30:	00001906 	br	4e98 <pkt_8x16+0x13c>
        case NIOS_PKT_8x16_TARGET_VCTCXO_DAC:
            vctcxo_trim_dac_read(addr, data);
    4e34:	d80b883a 	mov	r5,sp
    4e38:	91003fcc 	andi	r4,r18,255
    4e3c:	00049c00 	call	49c0 <vctcxo_trim_dac_read>
        default:
            DBG("%s: Invalid ID: 0x%02x\n", __FUNCTION__, id);
            return false;
    }

    return success;
    4e40:	04000044 	movi	r16,1
    4e44:	00001506 	br	4e9c <pkt_8x16+0x140>
#include "devices.h"
#include "debug.h"

static inline bool iq_corr_read(uint8_t addr, uint16_t *data)
{
    switch (addr) {
    4e48:	94c03fcc 	andi	r19,r18,255
    4e4c:	9c000a26 	beq	r19,r16,4e78 <pkt_8x16+0x11c>
    4e50:	98000726 	beq	r19,zero,4e70 <pkt_8x16+0x114>
    4e54:	00800084 	movi	r2,2
    4e58:	98800b26 	beq	r19,r2,4e88 <pkt_8x16+0x12c>
    4e5c:	008000c4 	movi	r2,3
    4e60:	98800e1e 	bne	r19,r2,4e9c <pkt_8x16+0x140>
        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_GAIN:
            *data = iqbal_get_gain(BLADERF_MODULE_TX);
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_PHASE:
            *data = iqbal_get_phase(BLADERF_MODULE_TX);
    4e64:	8009883a 	mov	r4,r16
    4e68:	0004ae00 	call	4ae0 <iqbal_get_phase>
    4e6c:	00000806 	br	4e90 <pkt_8x16+0x134>

static inline bool iq_corr_read(uint8_t addr, uint16_t *data)
{
    switch (addr) {
        case NIOS_PKT_8x16_ADDR_IQ_CORR_RX_GAIN:
            *data = iqbal_get_gain(BLADERF_MODULE_RX);
    4e70:	0009883a 	mov	r4,zero
    4e74:	00000506 	br	4e8c <pkt_8x16+0x130>
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_RX_PHASE:
            *data = iqbal_get_phase(BLADERF_MODULE_RX);
    4e78:	0009883a 	mov	r4,zero
    4e7c:	0004ae00 	call	4ae0 <iqbal_get_phase>
    4e80:	d880000d 	sth	r2,0(sp)
    4e84:	003fee06 	br	4e40 <pkt_8x16+0xe4>
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_GAIN:
            *data = iqbal_get_gain(BLADERF_MODULE_TX);
    4e88:	8009883a 	mov	r4,r16
    4e8c:	0004aa00 	call	4aa0 <iqbal_get_gain>
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_PHASE:
            *data = iqbal_get_phase(BLADERF_MODULE_TX);
    4e90:	d880000d 	sth	r2,0(sp)
    4e94:	00000106 	br	4e9c <pkt_8x16+0x140>

        */

        default:
            DBG("%s: Invalid ID: 0x%02x\n", __FUNCTION__, id);
            return false;
    4e98:	0021883a 	mov	r16,zero

/* Pack the request buffer */
static inline void nios_pkt_8x16_pack(uint8_t *buf, uint8_t target, bool write,
                                      uint8_t addr, uint16_t data)
{
    buf[NIOS_PKT_8x16_IDX_MAGIC]     = NIOS_PKT_8x16_MAGIC;
    4e9c:	00c01084 	movi	r3,66
    4ea0:	88c00405 	stb	r3,16(r17)
    buf[NIOS_PKT_8x16_IDX_TARGET_ID] = target;
    4ea4:	8d000445 	stb	r20,17(r17)
        success = perform_write(id, addr, data);
    } else {
        success = perform_read(id, addr, &data);
    }

    nios_pkt_8x16_resp_pack(b->resp, id, is_write, addr, data, success);
    4ea8:	d880000b 	ldhu	r2,0(sp)

    if (write) {
    4eac:	a8000326 	beq	r21,zero,4ebc <pkt_8x16+0x160>
        buf[NIOS_PKT_8x16_IDX_FLAGS] = NIOS_PKT_8x16_FLAG_WRITE;
    4eb0:	00c00044 	movi	r3,1
    4eb4:	88c00485 	stb	r3,18(r17)
    4eb8:	00000106 	br	4ec0 <pkt_8x16+0x164>
    } else {
        buf[NIOS_PKT_8x16_IDX_FLAGS] = 0x00;
    4ebc:	88000485 	stb	zero,18(r17)

    buf[NIOS_PKT_8x16_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x16_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x16_IDX_DATA]     = data & 0xff;
    4ec0:	88800545 	stb	r2,21(r17)
    buf[NIOS_PKT_8x16_IDX_DATA + 1] = (data >> 8);
    4ec4:	1004d23a 	srli	r2,r2,8
        buf[NIOS_PKT_8x16_IDX_FLAGS] = NIOS_PKT_8x16_FLAG_WRITE;
    } else {
        buf[NIOS_PKT_8x16_IDX_FLAGS] = 0x00;
    }

    buf[NIOS_PKT_8x16_IDX_RESV1] = 0x00;
    4ec8:	880004c5 	stb	zero,19(r17)

    buf[NIOS_PKT_8x16_IDX_ADDR] = addr;
    4ecc:	8c800505 	stb	r18,20(r17)

    buf[NIOS_PKT_8x16_IDX_DATA]     = data & 0xff;
    buf[NIOS_PKT_8x16_IDX_DATA + 1] = (data >> 8);
    4ed0:	88800585 	stb	r2,22(r17)

    buf[NIOS_PKT_8x16_IDX_RESV2 + 0] = 0x00;
    4ed4:	880005c5 	stb	zero,23(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 1] = 0x00;
    4ed8:	88000605 	stb	zero,24(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 2] = 0x00;
    4edc:	88000645 	stb	zero,25(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 3] = 0x00;
    4ee0:	88000685 	stb	zero,26(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 4] = 0x00;
    4ee4:	880006c5 	stb	zero,27(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 5] = 0x00;
    4ee8:	88000705 	stb	zero,28(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 6] = 0x00;
    4eec:	88000745 	stb	zero,29(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 7] = 0x00;
    4ef0:	88000785 	stb	zero,30(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 8] = 0x00;
    4ef4:	880007c5 	stb	zero,31(r17)
                                           bool write, uint8_t addr,
                                           uint16_t data, bool success)
{
    nios_pkt_8x16_pack(buf, target, write, addr, data);

    if (success) {
    4ef8:	84003fcc 	andi	r16,r16,255
    4efc:	80000326 	beq	r16,zero,4f0c <pkt_8x16+0x1b0>
        buf[NIOS_PKT_8x16_IDX_FLAGS] |= NIOS_PKT_8x16_FLAG_SUCCESS;
    4f00:	88800483 	ldbu	r2,18(r17)
    4f04:	10800094 	ori	r2,r2,2
    4f08:	88800485 	stb	r2,18(r17)
}
    4f0c:	dfc00717 	ldw	ra,28(sp)
    4f10:	dd400617 	ldw	r21,24(sp)
    4f14:	dd000517 	ldw	r20,20(sp)
    4f18:	dcc00417 	ldw	r19,16(sp)
    4f1c:	dc800317 	ldw	r18,12(sp)
    4f20:	dc400217 	ldw	r17,8(sp)
    4f24:	dc000117 	ldw	r16,4(sp)
    4f28:	dec00804 	addi	sp,sp,32
    4f2c:	f800283a 	ret

00004f30 <pkt_8x32>:

    return true;
}

void pkt_8x32(struct pkt_buf *b)
{
    4f30:	defff904 	addi	sp,sp,-28
    4f34:	dc000015 	stw	r16,0(sp)
    4f38:	dfc00615 	stw	ra,24(sp)
    4f3c:	dd400515 	stw	r21,20(sp)
    4f40:	dd000415 	stw	r20,16(sp)
    4f44:	dcc00315 	stw	r19,12(sp)
    4f48:	dc800215 	stw	r18,8(sp)
    4f4c:	dc400115 	stw	r17,4(sp)
    4f50:	24800083 	ldbu	r18,2(r4)
static inline void nios_pkt_8x32_unpack(const uint8_t *buf, uint8_t *target,
                                        bool *write, uint8_t *addr,
                                        uint32_t *data)
{
    if (target != NULL) {
        *target = buf[NIOS_PKT_8x32_IDX_TARGET_ID];
    4f54:	24c00043 	ldbu	r19,1(r4)
    4f58:	2021883a 	mov	r16,r4
    bool is_write;
    bool success;

    nios_pkt_8x32_unpack(b->req, &id, &is_write, &addr, &data);

    if (is_write) {
    4f5c:	9480004c 	andi	r18,r18,1
    if (write != NULL) {
        *write  = (buf[NIOS_PKT_8x32_IDX_FLAGS] & NIOS_PKT_8x32_FLAG_WRITE) != 0;
    }

    if (addr != NULL) {
        *addr   = buf[NIOS_PKT_8x32_IDX_ADDR];
    4f60:	25400103 	ldbu	r21,4(r4)
    4f64:	99403fcc 	andi	r5,r19,255
    4f68:	90001526 	beq	r18,zero,4fc0 <pkt_8x32+0x90>
    4f6c:	80800183 	ldbu	r2,6(r16)
    4f70:	844001c3 	ldbu	r17,7(r16)
    4f74:	21000143 	ldbu	r4,5(r4)
    4f78:	1004923a 	slli	r2,r2,8
    4f7c:	8822943a 	slli	r17,r17,16
    return true;
}

static inline bool perform_write(uint8_t id, uint8_t addr, uint32_t data)
{
    switch (id) {
    4f80:	05000044 	movi	r20,1
    4f84:	1106b03a 	or	r3,r2,r4
    4f88:	88c4b03a 	or	r2,r17,r3
    4f8c:	84400203 	ldbu	r17,8(r16)
    4f90:	8822963a 	slli	r17,r17,24
    4f94:	88a2b03a 	or	r17,r17,r2
    4f98:	2d000626 	beq	r5,r20,4fb4 <pkt_8x32+0x84>
    4f9c:	00800084 	movi	r2,2
    4fa0:	2880101e 	bne	r5,r2,4fe4 <pkt_8x32+0xb4>
        case NIOS_PKT_8x32_TARGET_CONTROL:
            control_reg_write(data);
            break;

        case NIOS_PKT_8x32_TARGET_ADF4351:
            adf4351_write(data);
    4fa4:	8809883a 	mov	r4,r17
    4fa8:	0004a4c0 	call	4a4c <adf4351_write>
        default:
            DBG("Invalid id: 0x%02x\n", id);
            return false;
    }

    return true;
    4fac:	a005883a 	mov	r2,r20
    4fb0:	00001006 	br	4ff4 <pkt_8x32+0xc4>
    return IORD_ALTERA_AVALON_PIO_DATA(CONTROL_BASE);
}

static inline void control_reg_write(uint32_t value)
{
    IOWR_ALTERA_AVALON_PIO_DATA(CONTROL_BASE, value);
    4fb4:	00a41014 	movui	r2,36928
    4fb8:	14400035 	stwio	r17,0(r2)
    4fbc:	00000706 	br	4fdc <pkt_8x32+0xac>
#include "devices.h"
#include "debug.h"

static inline bool perform_read(uint8_t id, uint8_t addr, uint32_t *data)
{
    switch (id) {
    4fc0:	28000a26 	beq	r5,zero,4fec <pkt_8x32+0xbc>
    4fc4:	00800044 	movi	r2,1
    4fc8:	28800226 	beq	r5,r2,4fd4 <pkt_8x32+0xa4>
            *data = control_reg_read();
            break;

        case NIOS_PKT_8x32_TARGET_ADF4351:
            DBG("Illegal read from ADF4351.\n");
            *data = 0x00;
    4fcc:	0023883a 	mov	r17,zero
    4fd0:	00000406 	br	4fe4 <pkt_8x32+0xb4>
#include <stdbool.h>


static inline uint32_t control_reg_read(void)
{
    return IORD_ALTERA_AVALON_PIO_DATA(CONTROL_BASE);
    4fd4:	00a41014 	movui	r2,36928
    4fd8:	14400037 	ldwio	r17,0(r2)
            DBG("Invalid id: 0x%02x\n", id);
            *data = 0x00;
            return false;
    }

    return true;
    4fdc:	2805883a 	mov	r2,r5
    4fe0:	00000406 	br	4ff4 <pkt_8x32+0xc4>
static inline bool perform_write(uint8_t id, uint8_t addr, uint32_t data)
{
    switch (id) {
        case NIOS_PKT_8x32_TARGET_VERSION:
            DBG("Invalid write to version register.\n");
            return false;
    4fe4:	0005883a 	mov	r2,zero
    4fe8:	00000206 	br	4ff4 <pkt_8x32+0xc4>

static inline bool perform_read(uint8_t id, uint8_t addr, uint32_t *data)
{
    switch (id) {
        case NIOS_PKT_8x32_TARGET_VERSION:
            *data = fpga_version();
    4fec:	04418004 	movi	r17,1536
            DBG("Invalid id: 0x%02x\n", id);
            *data = 0x00;
            return false;
    }

    return true;
    4ff0:	00800044 	movi	r2,1

/* Pack the request buffer */
static inline void nios_pkt_8x32_pack(uint8_t *buf, uint8_t target, bool write,
                                      uint8_t addr, uint32_t data)
{
    buf[NIOS_PKT_8x32_IDX_MAGIC]     = NIOS_PKT_8x32_MAGIC;
    4ff4:	00c010c4 	movi	r3,67
    4ff8:	80c00405 	stb	r3,16(r16)
    buf[NIOS_PKT_8x32_IDX_TARGET_ID] = target;
    4ffc:	84c00445 	stb	r19,17(r16)

    if (write) {
    5000:	90000326 	beq	r18,zero,5010 <pkt_8x32+0xe0>
        buf[NIOS_PKT_8x32_IDX_FLAGS] = NIOS_PKT_8x32_FLAG_WRITE;
    5004:	00c00044 	movi	r3,1
    5008:	80c00485 	stb	r3,18(r16)
    500c:	00000106 	br	5014 <pkt_8x32+0xe4>
    } else {
        buf[NIOS_PKT_8x32_IDX_FLAGS] = 0x00;
    5010:	80000485 	stb	zero,18(r16)
    buf[NIOS_PKT_8x32_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x32_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x32_IDX_DATA + 0] = data & 0xff;
    buf[NIOS_PKT_8x32_IDX_DATA + 1] = (data >> 8);
    5014:	8806d23a 	srli	r3,r17,8

    buf[NIOS_PKT_8x32_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x32_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x32_IDX_DATA + 0] = data & 0xff;
    5018:	84400545 	stb	r17,21(r16)
        buf[NIOS_PKT_8x32_IDX_FLAGS] = NIOS_PKT_8x32_FLAG_WRITE;
    } else {
        buf[NIOS_PKT_8x32_IDX_FLAGS] = 0x00;
    }

    buf[NIOS_PKT_8x32_IDX_RESV1] = 0x00;
    501c:	800004c5 	stb	zero,19(r16)

    buf[NIOS_PKT_8x32_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x32_IDX_DATA + 0] = data & 0xff;
    buf[NIOS_PKT_8x32_IDX_DATA + 1] = (data >> 8);
    5020:	80c00585 	stb	r3,22(r16)
    buf[NIOS_PKT_8x32_IDX_DATA + 2] = (data >> 16);
    5024:	8806d43a 	srli	r3,r17,16
    buf[NIOS_PKT_8x32_IDX_DATA + 3] = (data >> 24);
    5028:	8822d63a 	srli	r17,r17,24
        buf[NIOS_PKT_8x32_IDX_FLAGS] = 0x00;
    }

    buf[NIOS_PKT_8x32_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x32_IDX_ADDR] = addr;
    502c:	85400505 	stb	r21,20(r16)

    buf[NIOS_PKT_8x32_IDX_DATA + 0] = data & 0xff;
    buf[NIOS_PKT_8x32_IDX_DATA + 1] = (data >> 8);
    buf[NIOS_PKT_8x32_IDX_DATA + 2] = (data >> 16);
    5030:	80c005c5 	stb	r3,23(r16)
    buf[NIOS_PKT_8x32_IDX_DATA + 3] = (data >> 24);
    5034:	84400605 	stb	r17,24(r16)

    buf[NIOS_PKT_8x32_IDX_RESV2 + 0] = 0x00;
    5038:	80000645 	stb	zero,25(r16)
    buf[NIOS_PKT_8x32_IDX_RESV2 + 1] = 0x00;
    503c:	80000685 	stb	zero,26(r16)
    buf[NIOS_PKT_8x32_IDX_RESV2 + 2] = 0x00;
    5040:	800006c5 	stb	zero,27(r16)
    buf[NIOS_PKT_8x32_IDX_RESV2 + 3] = 0x00;
    5044:	80000705 	stb	zero,28(r16)
    buf[NIOS_PKT_8x32_IDX_RESV2 + 4] = 0x00;
    5048:	80000745 	stb	zero,29(r16)
    buf[NIOS_PKT_8x32_IDX_RESV2 + 5] = 0x00;
    504c:	80000785 	stb	zero,30(r16)
    buf[NIOS_PKT_8x32_IDX_RESV2 + 6] = 0x00;
    5050:	800007c5 	stb	zero,31(r16)
                                           bool write, uint8_t addr,
                                           uint32_t data, bool success)
{
    nios_pkt_8x32_pack(buf, target, write, addr, data);

    if (success) {
    5054:	10803fcc 	andi	r2,r2,255
    5058:	10000326 	beq	r2,zero,5068 <pkt_8x32+0x138>
        buf[NIOS_PKT_8x32_IDX_FLAGS] |= NIOS_PKT_8x32_FLAG_SUCCESS;
    505c:	80800483 	ldbu	r2,18(r16)
    5060:	10800094 	ori	r2,r2,2
    5064:	80800485 	stb	r2,18(r16)
    } else {
        success = perform_read(id, addr, &data);
    }

    nios_pkt_8x32_resp_pack(b->resp, id, is_write, addr, data, success);
}
    5068:	dfc00617 	ldw	ra,24(sp)
    506c:	dd400517 	ldw	r21,20(sp)
    5070:	dd000417 	ldw	r20,16(sp)
    5074:	dcc00317 	ldw	r19,12(sp)
    5078:	dc800217 	ldw	r18,8(sp)
    507c:	dc400117 	ldw	r17,4(sp)
    5080:	dc000017 	ldw	r16,0(sp)
    5084:	dec00704 	addi	sp,sp,28
    5088:	f800283a 	ret

0000508c <pkt_8x64>:

    return success;
}

void pkt_8x64(struct pkt_buf *b)
{
    508c:	defffa04 	addi	sp,sp,-24
    5090:	dc000015 	stw	r16,0(sp)
    5094:	dfc00515 	stw	ra,20(sp)
    5098:	dd000415 	stw	r20,16(sp)
    509c:	dcc00315 	stw	r19,12(sp)
    50a0:	dc800215 	stw	r18,8(sp)
    50a4:	dc400115 	stw	r17,4(sp)
    50a8:	2021883a 	mov	r16,r4
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 1] << 8)  |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 2] << 16) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 3] << 24) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 4] << 32) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 5] << 40) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 6] << 48) |
    50ac:	20c00183 	ldbu	r3,6(r4)
    50b0:	808001c3 	ldbu	r2,7(r16)
    50b4:	21400143 	ldbu	r5,5(r4)
    50b8:	1806923a 	slli	r3,r3,8
    50bc:	1004943a 	slli	r2,r2,16
    50c0:	25000083 	ldbu	r20,2(r4)
static inline void nios_pkt_8x64_unpack(const uint8_t *buf, uint8_t *target,
                                        bool *write, uint8_t *addr,
                                        uint64_t *data)
{
    if (target != NULL) {
        *target = buf[NIOS_PKT_8x64_IDX_TARGET_ID];
    50c4:	24800043 	ldbu	r18,1(r4)
    if (write != NULL) {
        *write  = (buf[NIOS_PKT_8x64_IDX_FLAGS] & NIOS_PKT_8x64_FLAG_WRITE) != 0;
    }

    if (addr != NULL) {
        *addr   = buf[NIOS_PKT_8x64_IDX_ADDR];
    50c8:	24400103 	ldbu	r17,4(r4)
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 1] << 8)  |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 2] << 16) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 3] << 24) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 4] << 32) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 5] << 40) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 6] << 48) |
    50cc:	1948b03a 	or	r4,r3,r5
    50d0:	1106b03a 	or	r3,r2,r4
    50d4:	80800203 	ldbu	r2,8(r16)
    50d8:	81000283 	ldbu	r4,10(r16)
    50dc:	81800243 	ldbu	r6,9(r16)
    50e0:	1004963a 	slli	r2,r2,24
    50e4:	2008923a 	slli	r4,r4,8
    bool    is_write;
    bool    success;

    nios_pkt_8x64_unpack(b->req, &id, &is_write, &addr, &data);

    if (is_write) {
    50e8:	a500004c 	andi	r20,r20,1
    50ec:	10c4b03a 	or	r2,r2,r3
    50f0:	80c002c3 	ldbu	r3,11(r16)
    50f4:	218ab03a 	or	r5,r4,r6
    50f8:	1806943a 	slli	r3,r3,16
    50fc:	1948b03a 	or	r4,r3,r5
    5100:	80c00303 	ldbu	r3,12(r16)
    5104:	1806963a 	slli	r3,r3,24
    5108:	1906b03a 	or	r3,r3,r4
    510c:	a0000c1e 	bne	r20,zero,5140 <pkt_8x64+0xb4>

static inline bool perform_read(uint8_t id, uint8_t addr, uint64_t *data)
{
    bool success;

    switch (id) {
    5110:	91003fcc 	andi	r4,r18,255
    5114:	20000a1e 	bne	r4,zero,5140 <pkt_8x64+0xb4>
    }
}

static inline bool read_timestamp(uint8_t addr, uint64_t *data)
{
    switch (addr) {
    5118:	8cc03fcc 	andi	r19,r17,255
    511c:	98000426 	beq	r19,zero,5130 <pkt_8x64+0xa4>
    5120:	01000044 	movi	r4,1
    5124:	9900061e 	bne	r19,r4,5140 <pkt_8x64+0xb4>
        case NIOS_PKT_8x64_TIMESTAMP_RX:
            *data = time_tamer_read(BLADERF_MODULE_RX);
            break;

        case NIOS_PKT_8x64_TIMESTAMP_TX:
            *data = time_tamer_read(BLADERF_MODULE_TX);
    5128:	9809883a 	mov	r4,r19
    512c:	00000106 	br	5134 <pkt_8x64+0xa8>

static inline bool read_timestamp(uint8_t addr, uint64_t *data)
{
    switch (addr) {
        case NIOS_PKT_8x64_TIMESTAMP_RX:
            *data = time_tamer_read(BLADERF_MODULE_RX);
    5130:	0009883a 	mov	r4,zero
    5134:	0004b5c0 	call	4b5c <time_tamer_read>
        default:
            DBG("Invalid addr: 0x%02x\n", addr);
            return false;
    }

    return true;
    5138:	01000044 	movi	r4,1
    513c:	00000106 	br	5144 <pkt_8x64+0xb8>
            *data = time_tamer_read(BLADERF_MODULE_TX);
            break;

        default:
            DBG("Invalid addr: 0x%02x\n", addr);
            return false;
    5140:	0009883a 	mov	r4,zero

/* Pack the request buffer */
static inline void nios_pkt_8x64_pack(uint8_t *buf, uint8_t target, bool write,
                                      uint8_t addr, uint64_t data)
{
    buf[NIOS_PKT_8x64_IDX_MAGIC]     = NIOS_PKT_8x64_MAGIC;
    5144:	01401104 	movi	r5,68
    5148:	81400405 	stb	r5,16(r16)
    buf[NIOS_PKT_8x64_IDX_TARGET_ID] = target;
    514c:	84800445 	stb	r18,17(r16)

    if (write) {
    5150:	a0000326 	beq	r20,zero,5160 <pkt_8x64+0xd4>
        buf[NIOS_PKT_8x64_IDX_FLAGS] = NIOS_PKT_8x64_FLAG_WRITE;
    5154:	01400044 	movi	r5,1
    5158:	81400485 	stb	r5,18(r16)
    515c:	00000106 	br	5164 <pkt_8x64+0xd8>
    } else {
        buf[NIOS_PKT_8x64_IDX_FLAGS] = 0x00;
    5160:	80000485 	stb	zero,18(r16)
    buf[NIOS_PKT_8x64_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x64_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x64_IDX_DATA + 0] = (data >> 0)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    5164:	100ad23a 	srli	r5,r2,8

    buf[NIOS_PKT_8x64_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x64_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x64_IDX_DATA + 0] = (data >> 0)  & 0xff;
    5168:	80800545 	stb	r2,21(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 2] = (data >> 16) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 3] = (data >> 24) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 4] = (data >> 32) & 0xff;
    516c:	80c00645 	stb	r3,25(r16)
    buf[NIOS_PKT_8x64_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x64_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x64_IDX_DATA + 0] = (data >> 0)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    5170:	81400585 	stb	r5,22(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 2] = (data >> 16) & 0xff;
    5174:	100ad43a 	srli	r5,r2,16
    buf[NIOS_PKT_8x64_IDX_DATA + 3] = (data >> 24) & 0xff;
    5178:	1004d63a 	srli	r2,r2,24
        buf[NIOS_PKT_8x64_IDX_FLAGS] = NIOS_PKT_8x64_FLAG_WRITE;
    } else {
        buf[NIOS_PKT_8x64_IDX_FLAGS] = 0x00;
    }

    buf[NIOS_PKT_8x64_IDX_RESV1] = 0x00;
    517c:	800004c5 	stb	zero,19(r16)

    buf[NIOS_PKT_8x64_IDX_ADDR] = addr;
    5180:	84400505 	stb	r17,20(r16)

    buf[NIOS_PKT_8x64_IDX_DATA + 0] = (data >> 0)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 2] = (data >> 16) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 3] = (data >> 24) & 0xff;
    5184:	80800605 	stb	r2,24(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 4] = (data >> 32) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 5] = (data >> 40) & 0xff;
    5188:	1804d23a 	srli	r2,r3,8

    buf[NIOS_PKT_8x64_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x64_IDX_DATA + 0] = (data >> 0)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 2] = (data >> 16) & 0xff;
    518c:	814005c5 	stb	r5,23(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 4] = (data >> 32) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 5] = (data >> 40) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 6] = (data >> 48) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 7] = (data >> 56) & 0xff;

    buf[NIOS_PKT_8x64_IDX_RESV2 + 0] = 0x00;
    5190:	80000745 	stb	zero,29(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 0] = (data >> 0)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 2] = (data >> 16) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 3] = (data >> 24) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 4] = (data >> 32) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 5] = (data >> 40) & 0xff;
    5194:	80800685 	stb	r2,26(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 6] = (data >> 48) & 0xff;
    5198:	1804d43a 	srli	r2,r3,16
    buf[NIOS_PKT_8x64_IDX_DATA + 7] = (data >> 56) & 0xff;
    519c:	1806d63a 	srli	r3,r3,24

    buf[NIOS_PKT_8x64_IDX_RESV2 + 0] = 0x00;
    buf[NIOS_PKT_8x64_IDX_RESV2 + 1] = 0x00;
    51a0:	80000785 	stb	zero,30(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 2] = (data >> 16) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 3] = (data >> 24) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 4] = (data >> 32) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 5] = (data >> 40) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 6] = (data >> 48) & 0xff;
    51a4:	808006c5 	stb	r2,27(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 7] = (data >> 56) & 0xff;
    51a8:	80c00705 	stb	r3,28(r16)

    buf[NIOS_PKT_8x64_IDX_RESV2 + 0] = 0x00;
    buf[NIOS_PKT_8x64_IDX_RESV2 + 1] = 0x00;
    buf[NIOS_PKT_8x64_IDX_RESV2 + 2] = 0x00;
    51ac:	800007c5 	stb	zero,31(r16)
                                           bool write, uint8_t addr,
                                           uint64_t data, bool success)
{
    nios_pkt_8x64_pack(buf, target, write, addr, data);

    if (success) {
    51b0:	21003fcc 	andi	r4,r4,255
    51b4:	20000326 	beq	r4,zero,51c4 <pkt_8x64+0x138>
        buf[NIOS_PKT_8x64_IDX_FLAGS] |= NIOS_PKT_8x64_FLAG_SUCCESS;
    51b8:	80800483 	ldbu	r2,18(r16)
    51bc:	10800094 	ori	r2,r2,2
    51c0:	80800485 	stb	r2,18(r16)
    } else {
        success = perform_read(id, addr, &data);
    }

    nios_pkt_8x64_resp_pack(b->resp, id, is_write, addr, data, success);
}
    51c4:	dfc00517 	ldw	ra,20(sp)
    51c8:	dd000417 	ldw	r20,16(sp)
    51cc:	dcc00317 	ldw	r19,12(sp)
    51d0:	dc800217 	ldw	r18,8(sp)
    51d4:	dc400117 	ldw	r17,4(sp)
    51d8:	dc000017 	ldw	r16,0(sp)
    51dc:	dec00604 	addi	sp,sp,24
    51e0:	f800283a 	ret

000051e4 <pkt_8x8>:

    return true;
}

void pkt_8x8(struct pkt_buf *b)
{
    51e4:	defffa04 	addi	sp,sp,-24
    51e8:	dc000015 	stw	r16,0(sp)
    51ec:	dfc00515 	stw	ra,20(sp)
    51f0:	dd000415 	stw	r20,16(sp)
    51f4:	dcc00315 	stw	r19,12(sp)
    51f8:	dc800215 	stw	r18,8(sp)
    51fc:	dc400115 	stw	r17,4(sp)
    5200:	24c00083 	ldbu	r19,2(r4)
static inline void nios_pkt_8x8_unpack(const uint8_t *buf, uint8_t *target,
                                       bool *write, uint8_t *addr,
                                       uint8_t *data)
{
    if (target != NULL) {
        *target = buf[NIOS_PKT_8x8_IDX_TARGET_ID];
    5204:	25000043 	ldbu	r20,1(r4)
    5208:	2021883a 	mov	r16,r4
    bool    is_write;
    bool    success;

    nios_pkt_8x8_unpack(b->req, &id, &is_write, &addr, &data);

    if (is_write) {
    520c:	9cc0004c 	andi	r19,r19,1
    if (write != NULL) {
        *write  = (buf[NIOS_PKT_8x8_IDX_FLAGS] & NIOS_PKT_8x8_FLAG_WRITE) != 0;
    }

    if (addr != NULL) {
        *addr   = buf[NIOS_PKT_8x8_IDX_ADDR];
    5210:	24800103 	ldbu	r18,4(r4)
    5214:	a0803fcc 	andi	r2,r20,255
    5218:	00c00104 	movi	r3,4
    521c:	98002126 	beq	r19,zero,52a4 <pkt_8x8+0xc0>
    }

    if (data != NULL) {
        *data   = buf[NIOS_PKT_8x8_IDX_DATA];
    5220:	24400143 	ldbu	r17,5(r4)
    return true;
}

static inline bool perform_write(uint8_t id, uint8_t addr, uint8_t data)
{
    switch (id) {
    5224:	18803c36 	bltu	r3,r2,5318 <pkt_8x8+0x134>
    5228:	100490ba 	slli	r2,r2,2
    522c:	00c00034 	movhi	r3,0
    5230:	18d49004 	addi	r3,r3,21056
    5234:	10c5883a 	add	r2,r2,r3
    5238:	10800017 	ldw	r2,0(r2)
    523c:	1000683a 	jmp	r2
    5240:	00005254 	movui	zero,329
    5244:	00005264 	muli	zero,zero,329
    5248:	00005274 	movhi	zero,329
    524c:	0000528c 	andi	zero,zero,330
    5250:	00005298 	cmpnei	zero,zero,330
        case NIOS_PKT_8x8_TARGET_LMS6:
            lms6_write(addr, data);
    5254:	89403fcc 	andi	r5,r17,255
    5258:	91003fcc 	andi	r4,r18,255
    525c:	00048380 	call	4838 <lms6_write>
    5260:	00003006 	br	5324 <pkt_8x8+0x140>
            break;

        case NIOS_PKT_8x8_TARGET_SI5338:
            si5338_write(addr, data);
    5264:	89403fcc 	andi	r5,r17,255
    5268:	91003fcc 	andi	r4,r18,255
    526c:	00048ec0 	call	48ec <si5338_write>
    5270:	00002c06 	br	5324 <pkt_8x8+0x140>
            break;

        case NIOS_PKT_8x8_TARGET_VCTCXO_TAMER:
            switch (addr) {
    5274:	90803fcc 	andi	r2,r18,255
    5278:	00c03fc4 	movi	r3,255
    527c:	10c0291e 	bne	r2,r3,5324 <pkt_8x8+0x140>
                /* Using 0xff for mode selection operation so that we can
                 * reserve lower values for register-level access */
                case 0xff:
                    vctcxo_tamer_set_tune_mode((bladerf_vctcxo_tamer_mode) data);
    5280:	89003fcc 	andi	r4,r17,255
    5284:	00045b00 	call	45b0 <vctcxo_tamer_set_tune_mode>
    5288:	00002606 	br	5324 <pkt_8x8+0x140>
                    break;
            }
            break;

        case NIOS_PKT_8x8_TX_TRIGGER_CTL:
            tx_trigger_ctl_write(data);
    528c:	89003fcc 	andi	r4,r17,255
    5290:	0004b240 	call	4b24 <tx_trigger_ctl_write>
    5294:	00002306 	br	5324 <pkt_8x8+0x140>
            break;

        case NIOS_PKT_8x8_RX_TRIGGER_CTL:
            rx_trigger_ctl_write(data);
    5298:	89003fcc 	andi	r4,r17,255
    529c:	0004b400 	call	4b40 <rx_trigger_ctl_write>
    52a0:	00002006 	br	5324 <pkt_8x8+0x140>
#include "devices.h"
#include "debug.h"

static inline bool perform_read(uint8_t id, uint8_t addr, uint8_t *data)
{
    switch (id) {
    52a4:	18801b36 	bltu	r3,r2,5314 <pkt_8x8+0x130>
    52a8:	100490ba 	slli	r2,r2,2
    52ac:	00c00034 	movhi	r3,0
    52b0:	18d4b004 	addi	r3,r3,21184
    52b4:	10c5883a 	add	r2,r2,r3
    52b8:	10800017 	ldw	r2,0(r2)
    52bc:	1000683a 	jmp	r2
    52c0:	000052d4 	movui	zero,331
    52c4:	000052e0 	cmpeqi	zero,zero,331
    52c8:	000052ec 	andhi	zero,zero,331
    52cc:	00005300 	call	530 <__alt_mem_ram-0x3ad0>
    52d0:	00005308 	cmpgei	zero,zero,332
        case NIOS_PKT_8x8_TARGET_LMS6:
            *data = lms6_read(addr);
    52d4:	91003fcc 	andi	r4,r18,255
    52d8:	00048240 	call	4824 <lms6_read>
    52dc:	00000b06 	br	530c <pkt_8x8+0x128>
            break;

        case NIOS_PKT_8x8_TARGET_SI5338:
            *data = si5338_read(addr);
    52e0:	91003fcc 	andi	r4,r18,255
    52e4:	000484c0 	call	484c <si5338_read>
    52e8:	00000806 	br	530c <pkt_8x8+0x128>
            break;

        case NIOS_PKT_8x8_TARGET_VCTCXO_TAMER:
            switch (addr) {
    52ec:	90803fcc 	andi	r2,r18,255
    52f0:	00c03fc4 	movi	r3,255
    52f4:	10c00a1e 	bne	r2,r3,5320 <pkt_8x8+0x13c>
                /* Using 0xff for mode selection operation so that we can
                 * reserve lower values for register-level access */
                case 0xff:
                    *data = (uint8_t) vctcxo_tamer_get_tune_mode();
    52f8:	00045c00 	call	45c0 <vctcxo_tamer_get_tune_mode>
    52fc:	00000306 	br	530c <pkt_8x8+0x128>
                    *data = 0x00;
            }
            break;

        case NIOS_PKT_8x8_TX_TRIGGER_CTL:
            *data = tx_trigger_ctl_read();
    5300:	0004b340 	call	4b34 <tx_trigger_ctl_read>
    5304:	00000106 	br	530c <pkt_8x8+0x128>
            break;

        case NIOS_PKT_8x8_RX_TRIGGER_CTL:
            *data = rx_trigger_ctl_read();
    5308:	0004b500 	call	4b50 <rx_trigger_ctl_read>
    530c:	1023883a 	mov	r17,r2
    5310:	00000406 	br	5324 <pkt_8x8+0x140>

        */

        default:
            DBG("%s: Invalid ID: 0x%02x\n", __FUNCTION__, id);
            *data = 0xff;
    5314:	047fffc4 	movi	r17,-1
            return false;
    5318:	0007883a 	mov	r3,zero
    531c:	00000206 	br	5328 <pkt_8x8+0x144>
                case 0xff:
                    *data = (uint8_t) vctcxo_tamer_get_tune_mode();
                    break;

                default:
                    *data = 0x00;
    5320:	0023883a 	mov	r17,zero
            DBG("%s: Invalid ID: 0x%02x\n", __FUNCTION__, id);
            *data = 0xff;
            return false;
    }

    return true;
    5324:	00c00044 	movi	r3,1

/* Pack the request buffer */
static inline void nios_pkt_8x8_pack(uint8_t *buf, uint8_t target, bool write,
                                     uint8_t addr, uint8_t data)
{
    buf[NIOS_PKT_8x8_IDX_MAGIC]     = NIOS_PKT_8x8_MAGIC;
    5328:	00801044 	movi	r2,65
    532c:	80800405 	stb	r2,16(r16)
    buf[NIOS_PKT_8x8_IDX_TARGET_ID] = target;
    5330:	85000445 	stb	r20,17(r16)

    if (write) {
    5334:	98000326 	beq	r19,zero,5344 <pkt_8x8+0x160>
        buf[NIOS_PKT_8x8_IDX_FLAGS] = NIOS_PKT_8x8_FLAG_WRITE;
    5338:	00800044 	movi	r2,1
    533c:	80800485 	stb	r2,18(r16)
    5340:	00000106 	br	5348 <pkt_8x8+0x164>
    } else {
        buf[NIOS_PKT_8x8_IDX_FLAGS] = 0x00;
    5344:	80000485 	stb	zero,18(r16)
    }

    buf[NIOS_PKT_8x8_IDX_RESV1] = 0x00;
    5348:	800004c5 	stb	zero,19(r16)

    buf[NIOS_PKT_8x8_IDX_ADDR] = addr;
    534c:	84800505 	stb	r18,20(r16)
    buf[NIOS_PKT_8x8_IDX_DATA] = data;
    5350:	84400545 	stb	r17,21(r16)

    buf[NIOS_PKT_8x8_IDX_RESV2 + 0] = 0x00;
    5354:	80000585 	stb	zero,22(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 1] = 0x00;
    5358:	800005c5 	stb	zero,23(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 2] = 0x00;
    535c:	80000605 	stb	zero,24(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 3] = 0x00;
    5360:	80000645 	stb	zero,25(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 4] = 0x00;
    5364:	80000685 	stb	zero,26(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 5] = 0x00;
    5368:	800006c5 	stb	zero,27(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 6] = 0x00;
    536c:	80000705 	stb	zero,28(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 7] = 0x00;
    5370:	80000745 	stb	zero,29(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 8] = 0x00;
    5374:	80000785 	stb	zero,30(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 9] = 0x00;
    5378:	800007c5 	stb	zero,31(r16)
                                          bool write, uint8_t addr,
                                          uint8_t data, bool success)
{
    nios_pkt_8x8_pack(buf, target, write, addr, data);

    if (success) {
    537c:	18c03fcc 	andi	r3,r3,255
    5380:	18000326 	beq	r3,zero,5390 <pkt_8x8+0x1ac>
        buf[NIOS_PKT_8x8_IDX_FLAGS] |= NIOS_PKT_8x8_FLAG_SUCCESS;
    5384:	80800483 	ldbu	r2,18(r16)
    5388:	10800094 	ori	r2,r2,2
    538c:	80800485 	stb	r2,18(r16)
    } else {
        success = perform_read(id, addr, &data);
    }

    nios_pkt_8x8_resp_pack(b->resp, id, is_write, addr, data, success);
}
    5390:	dfc00517 	ldw	ra,20(sp)
    5394:	dd000417 	ldw	r20,16(sp)
    5398:	dcc00317 	ldw	r19,12(sp)
    539c:	dc800217 	ldw	r18,8(sp)
    53a0:	dc400117 	ldw	r17,4(sp)
    53a4:	dc000017 	ldw	r16,0(sp)
    53a8:	dec00604 	addi	sp,sp,24
    53ac:	f800283a 	ret

000053b0 <lookup_param>:

    [CONFIG_UNKNOWN]          = { 255, 0 },
};

static inline enum config_param lookup_param(uint8_t addr)
{
    53b0:	01400034 	movhi	r5,0
    53b4:	295be044 	addi	r5,r5,28545
    uint8_t i;

    DBG("Perip lookup for addr=%d\n", addr);

    for (i = 0; i < ARRAY_SIZE(config_params); i++) {
    53b8:	0005883a 	mov	r2,zero
        if (config_params[i].start <= addr &&
    53bc:	21003fcc 	andi	r4,r4,255
{
    uint8_t i;

    DBG("Perip lookup for addr=%d\n", addr);

    for (i = 0; i < ARRAY_SIZE(config_params); i++) {
    53c0:	01800344 	movi	r6,13
        if (config_params[i].start <= addr &&
    53c4:	28ffffc3 	ldbu	r3,-1(r5)
    53c8:	20c00536 	bltu	r4,r3,53e0 <lookup_param+0x30>
    53cc:	29c00003 	ldbu	r7,0(r5)
    53d0:	38c7883a 	add	r3,r7,r3
    53d4:	20c0020e 	bge	r4,r3,53e0 <lookup_param+0x30>
            (config_params[i].start + config_params[i].len) > addr) {
            DBG("Found match at entry %d\n", i);
            return (enum config_param) i;
    53d8:	10803fcc 	andi	r2,r2,255
    53dc:	f800283a 	ret
{
    uint8_t i;

    DBG("Perip lookup for addr=%d\n", addr);

    for (i = 0; i < ARRAY_SIZE(config_params); i++) {
    53e0:	10c00044 	addi	r3,r2,1
    53e4:	1805883a 	mov	r2,r3
    53e8:	18c03fcc 	andi	r3,r3,255
    53ec:	29400084 	addi	r5,r5,2
    53f0:	19bff41e 	bne	r3,r6,53c4 <lookup_param+0x14>
            return (enum config_param) i;
        }
    }

    DBG("UNKNOWN PARAM.\n");
    return CONFIG_UNKNOWN;
    53f4:	00800304 	movi	r2,12
}
    53f8:	f800283a 	ret

000053fc <pkt_legacy>:
            break;
    }
}

void pkt_legacy(struct pkt_buf *b)
{
    53fc:	defff504 	addi	sp,sp,-44
    5400:	dc400215 	stw	r17,8(sp)
    5404:	dc000115 	stw	r16,4(sp)
    5408:	dfc00a15 	stw	ra,40(sp)
    540c:	df000915 	stw	fp,36(sp)
    5410:	ddc00815 	stw	r23,32(sp)
    5414:	dd800715 	stw	r22,28(sp)
    5418:	dd400615 	stw	r21,24(sp)
    541c:	dd000515 	stw	r20,20(sp)
    5420:	dcc00415 	stw	r19,16(sp)
    5424:	dc800315 	stw	r18,12(sp)
    /* Parse configuration word */
    const uint8_t cfg = b->req[PKT_CFG_IDX];
    5428:	20c00043 	ldbu	r3,1(r4)
            break;
    }
}

void pkt_legacy(struct pkt_buf *b)
{
    542c:	2021883a 	mov	r16,r4
    const bool is_write = (cfg & (NIOS_PKT_LEGACY_MODE_DIR_WRITE)) != 0;
    const uint8_t dev_id = (cfg & NIOS_PKT_LEGACY_MODE_DEV_MASK);
    const uint8_t count = (cfg & NIOS_PKT_LEGACY_MODE_CNT_MASK);

    /* Response must start with same magic value and config word */
    b->resp[PKT_MAGIC_IDX] = b->req[PKT_MAGIC_IDX];
    5430:	81400003 	ldbu	r5,0(r16)
    5434:	1900100c 	andi	r4,r3,64
{
    /* Parse configuration word */
    const uint8_t cfg = b->req[PKT_CFG_IDX];
    const bool is_read = (cfg & (NIOS_PKT_LEGACY_MODE_DIR_READ)) != 0;
    const bool is_write = (cfg & (NIOS_PKT_LEGACY_MODE_DIR_WRITE)) != 0;
    const uint8_t dev_id = (cfg & NIOS_PKT_LEGACY_MODE_DEV_MASK);
    5438:	18800c0c 	andi	r2,r3,48
    const uint8_t count = (cfg & NIOS_PKT_LEGACY_MODE_CNT_MASK);
    543c:	1c4001cc 	andi	r17,r3,7

    /* Response must start with same magic value and config word */
    b->resp[PKT_MAGIC_IDX] = b->req[PKT_MAGIC_IDX];
    b->resp[PKT_CFG_IDX]   = b->req[PKT_CFG_IDX];
    5440:	80c00445 	stb	r3,17(r16)

    DBG("%s: read=%s, write=%s, dev_id=0x%x, cfg=%x, count=%d\n", __FUNCTION__,
        is_read ? "true" : "false", is_write ? "true" : "false", dev_id, cfg, count);

    if (is_read) {
    5444:	18c03fcc 	andi	r3,r3,255
    5448:	18c0201c 	xori	r3,r3,128
    const bool is_write = (cfg & (NIOS_PKT_LEGACY_MODE_DIR_WRITE)) != 0;
    const uint8_t dev_id = (cfg & NIOS_PKT_LEGACY_MODE_DEV_MASK);
    const uint8_t count = (cfg & NIOS_PKT_LEGACY_MODE_CNT_MASK);

    /* Response must start with same magic value and config word */
    b->resp[PKT_MAGIC_IDX] = b->req[PKT_MAGIC_IDX];
    544c:	81400405 	stb	r5,16(r16)
    b->resp[PKT_CFG_IDX]   = b->req[PKT_CFG_IDX];

    DBG("%s: read=%s, write=%s, dev_id=0x%x, cfg=%x, count=%d\n", __FUNCTION__,
        is_read ? "true" : "false", is_write ? "true" : "false", dev_id, cfg, count);

    if (is_read) {
    5450:	18ffe004 	addi	r3,r3,-128
    5454:	1800780e 	bge	r3,zero,5638 <pkt_legacy+0x23c>

static inline void legacy_pkt_read(uint8_t dev_id, uint8_t count,
                                   struct pkt_buf *b)
{

    switch (dev_id) {
    5458:	10803fcc 	andi	r2,r2,255
    545c:	00c00404 	movi	r3,16
    5460:	10c01126 	beq	r2,r3,54a8 <pkt_legacy+0xac>
    5464:	00c00c04 	movi	r3,48
    5468:	10c01426 	beq	r2,r3,54bc <pkt_legacy+0xc0>
    546c:	1001031e 	bne	r2,zero,587c <pkt_legacy+0x480>
    static enum config_param last_param = CONFIG_UNKNOWN;

    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];

    param = lookup_param(b->req[PAYLOAD_IDX]);
    5470:	81000083 	ldbu	r4,2(r16)

static uint64_t perform_config_read(enum config_param param)
{
    uint64_t payload;

    switch (param) {
    5474:	05800034 	movhi	r22,0
            payload = perform_config_read(param);
            last_param = param;
        }

        /* Copy address offset from request to response buffer */
        *resp_data++ = *req_data++ - config_params[param].start;
    5478:	05c00034 	movhi	r23,0
    static enum config_param last_param = CONFIG_UNKNOWN;

    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];

    param = lookup_param(b->req[PAYLOAD_IDX]);
    547c:	00053b00 	call	53b0 <lookup_param>
    5480:	8829883a 	mov	r20,r17
    static uint8_t n = 0;
    static uint64_t payload = 0;
    static enum config_param param = CONFIG_UNKNOWN;
    static enum config_param last_param = CONFIG_UNKNOWN;

    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    5484:	84800084 	addi	r18,r16,2
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];
    5488:	84c00484 	addi	r19,r16,18

    param = lookup_param(b->req[PAYLOAD_IDX]);
    548c:	d0a00415 	stw	r2,-32752(gp)
    5490:	840004c4 	addi	r16,r16,19

    for (i = 0; i < count; i++) {
    5494:	0023883a 	mov	r17,zero

static uint64_t perform_config_read(enum config_param param)
{
    uint64_t payload;

    switch (param) {
    5498:	054002c4 	movi	r21,11
    549c:	b5954404 	addi	r22,r22,21776
            payload = perform_config_read(param);
            last_param = param;
        }

        /* Copy address offset from request to response buffer */
        *resp_data++ = *req_data++ - config_params[param].start;
    54a0:	bddbe004 	addi	r23,r23,28544
    54a4:	00000c06 	br	54d8 <pkt_legacy+0xdc>
{

    switch (dev_id) {
        case NIOS_PKT_LEGACY_DEV_LMS:
            DBG("%s: Performing LMS6 read.\n", __FUNCTION__);
            b->resp[ADDR_IDX] = b->req[ADDR_IDX];
    54a8:	81000083 	ldbu	r4,2(r16)
    54ac:	81000485 	stb	r4,18(r16)
            b->resp[DATA_IDX] = lms6_read(b->req[ADDR_IDX]);
    54b0:	21003fcc 	andi	r4,r4,255
    54b4:	00048240 	call	4824 <lms6_read>
    54b8:	00000406 	br	54cc <pkt_legacy+0xd0>
            break;

        case NIOS_PKT_LEGACY_DEV_SI5338:
            DBG("%s: Performing SI5338 read.\n", __FUNCTION__);
            b->resp[ADDR_IDX] = b->req[ADDR_IDX];
    54bc:	81000083 	ldbu	r4,2(r16)
    54c0:	81000485 	stb	r4,18(r16)
            b->resp[DATA_IDX] = si5338_read(b->req[ADDR_IDX]);
    54c4:	21003fcc 	andi	r4,r4,255
    54c8:	000484c0 	call	484c <si5338_read>
    54cc:	808004c5 	stb	r2,19(r16)
    54d0:	0000ea06 	br	587c <pkt_legacy+0x480>
    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];

    param = lookup_param(b->req[PAYLOAD_IDX]);

    for (i = 0; i < count; i++) {
    54d4:	8c400044 	addi	r17,r17,1
    54d8:	a0803fcc 	andi	r2,r20,255
    54dc:	88c03fcc 	andi	r3,r17,255
    54e0:	10c0e626 	beq	r2,r3,587c <pkt_legacy+0x480>

        /* Reset if we're at the beggining of a requst, or if it appears
         * that we got a different request while in the middle of the previous
         * series of accesses. */
        if (n == 0 || (param != last_param)) {
    54e4:	d0e01403 	ldbu	r3,-32688(gp)
    54e8:	d0a00417 	ldw	r2,-32752(gp)
    54ec:	18000226 	beq	r3,zero,54f8 <pkt_legacy+0xfc>
    54f0:	d0e00317 	ldw	r3,-32756(gp)
    54f4:	10c03426 	beq	r2,r3,55c8 <pkt_legacy+0x1cc>
            DBG("Resetting read state for param=%d with n=%d\n", param, n);
            n = 0;
    54f8:	d0201405 	stb	zero,-32688(gp)

static uint64_t perform_config_read(enum config_param param)
{
    uint64_t payload;

    switch (param) {
    54fc:	a8802936 	bltu	r21,r2,55a4 <pkt_legacy+0x1a8>
    5500:	100490ba 	slli	r2,r2,2
    5504:	1585883a 	add	r2,r2,r22
    5508:	10800017 	ldw	r2,0(r2)
    550c:	1000683a 	jmp	r2
    5510:	00005548 	cmpgei	zero,zero,341
    5514:	00005550 	cmplti	zero,zero,341
    5518:	00005558 	cmpnei	zero,zero,341
    551c:	00005560 	cmpeqi	zero,zero,341
    5520:	0000556c 	andhi	zero,zero,341
    5524:	000055b0 	cmpltui	zero,zero,342
    5528:	0000557c 	xorhi	zero,zero,341
    552c:	00005584 	movi	zero,342
    5530:	00005540 	call	554 <__alt_mem_ram-0x3aac>
    5534:	00005540 	call	554 <__alt_mem_ram-0x3aac>
    5538:	00005590 	cmplti	zero,zero,342
    553c:	0000559c 	xori	zero,zero,342
            break;

        case CONFIG_VCTXCO:
            /* TODO Implement VCTCXO trim DAC read */
            DBG("%s: Attempted VCTCXO read.\n", __FUNCTION__);
            payload = 0x00;
    5540:	0005883a 	mov	r2,zero
    5544:	00001b06 	br	55b4 <pkt_legacy+0x1b8>
    5548:	00a41014 	movui	r2,36928
    554c:	00001106 	br	5594 <pkt_legacy+0x198>
            payload = control_reg_read();
            break;

        case CONFIG_IQ_CORR_RX_GAIN:
            DBG("%s: Performing RX IQ gain read.\n", __FUNCTION__);
            payload = iqbal_get_gain(BLADERF_MODULE_RX);
    5550:	0009883a 	mov	r4,zero
    5554:	00000306 	br	5564 <pkt_legacy+0x168>
            break;

        case CONFIG_IQ_CORR_RX_PHASE:
            DBG("%s: Performing RX IQ phase read.\n", __FUNCTION__);
            payload = iqbal_get_phase(BLADERF_MODULE_RX);
    5558:	0009883a 	mov	r4,zero
    555c:	00000406 	br	5570 <pkt_legacy+0x174>
            break;

        case CONFIG_IQ_CORR_TX_GAIN:
            DBG("%s: Performing TX IQ gain read.\n", __FUNCTION__);
            payload = iqbal_get_gain(BLADERF_MODULE_TX);
    5560:	01000044 	movi	r4,1
    5564:	0004aa00 	call	4aa0 <iqbal_get_gain>
    5568:	00000206 	br	5574 <pkt_legacy+0x178>
            break;

        case CONFIG_IQ_CORR_TX_PHASE:
            DBG("%s: Performing TX IQ phase read.\n", __FUNCTION__);
            payload = iqbal_get_phase(BLADERF_MODULE_TX);
    556c:	01000044 	movi	r4,1
    5570:	0004ae00 	call	4ae0 <iqbal_get_phase>
    5574:	10bfffcc 	andi	r2,r2,65535
    5578:	00000e06 	br	55b4 <pkt_legacy+0x1b8>
            payload = fpga_version();
            break;

        case CONFIG_RX_TIMESTAMP:
            DBG("%s: Performing RX timestamp read.\n", __FUNCTION__);
            payload = time_tamer_read(BLADERF_MODULE_RX);
    557c:	0009883a 	mov	r4,zero
    5580:	00000106 	br	5588 <pkt_legacy+0x18c>
            break;

        case CONFIG_TX_TIMESTAMP:
            DBG("%s: Performing TX timestamp read.\n", __FUNCTION__);
            payload = time_tamer_read(BLADERF_MODULE_TX);
    5584:	01000044 	movi	r4,1
    5588:	0004b5c0 	call	4b5c <time_tamer_read>
    558c:	00000a06 	br	55b8 <pkt_legacy+0x1bc>
    IOWR_ALTERA_AVALON_PIO_DATA(CONTROL_BASE, value);
}

static inline uint32_t expansion_port_read(void)
{
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE);
    5590:	00a42c14 	movui	r2,37040
    5594:	10800037 	ldwio	r2,0(r2)
    5598:	00000606 	br	55b4 <pkt_legacy+0x1b8>
    IOWR_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE, value);
}

INLINE uint32_t expansion_port_get_direction()
{
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_DIR_BASE);
    559c:	00a42814 	movui	r2,37024
    55a0:	003ffc06 	br	5594 <pkt_legacy+0x198>
            payload = expansion_port_get_direction();
            break;

        default:
            DBG("Invalid config read parameter: %u\n", param);
            payload = (uint64_t) -1;
    55a4:	00bfffc4 	movi	r2,-1
    55a8:	1007883a 	mov	r3,r2
    55ac:	00000206 	br	55b8 <pkt_legacy+0x1bc>
            payload = iqbal_get_phase(BLADERF_MODULE_TX);
            break;

        case CONFIG_FPGA_VERSION:
            DBG("%s: Performing FPGA version read.\n", __FUNCTION__);
            payload = fpga_version();
    55b0:	00818004 	movi	r2,1536
    55b4:	0007883a 	mov	r3,zero
         * that we got a different request while in the middle of the previous
         * series of accesses. */
        if (n == 0 || (param != last_param)) {
            DBG("Resetting read state for param=%d with n=%d\n", param, n);
            n = 0;
            payload = perform_config_read(param);
    55b8:	d0a01215 	stw	r2,-32696(gp)
            last_param = param;
    55bc:	d0a00417 	ldw	r2,-32752(gp)
         * that we got a different request while in the middle of the previous
         * series of accesses. */
        if (n == 0 || (param != last_param)) {
            DBG("Resetting read state for param=%d with n=%d\n", param, n);
            n = 0;
            payload = perform_config_read(param);
    55c0:	d0e01315 	stw	r3,-32692(gp)
            last_param = param;
    55c4:	d0a00315 	stw	r2,-32756(gp)
        }

        /* Copy address offset from request to response buffer */
        *resp_data++ = *req_data++ - config_params[param].start;
    55c8:	d1e00417 	ldw	r7,-32752(gp)

        /* Write read data into response buffer */
        *resp_data++ = (uint8_t) (payload >> (n * 8));
    55cc:	d7201403 	ldbu	fp,-32688(gp)
            payload = perform_config_read(param);
            last_param = param;
        }

        /* Copy address offset from request to response buffer */
        *resp_data++ = *req_data++ - config_params[param].start;
    55d0:	90800003 	ldbu	r2,0(r18)
    55d4:	39cf883a 	add	r7,r7,r7
    55d8:	b9cf883a 	add	r7,r23,r7
    55dc:	38c00003 	ldbu	r3,0(r7)

        /* Write read data into response buffer */
        *resp_data++ = (uint8_t) (payload >> (n * 8));
    55e0:	e1803fcc 	andi	r6,fp,255
    55e4:	300c90fa 	slli	r6,r6,3
    55e8:	d1201217 	ldw	r4,-32696(gp)
    55ec:	d1601317 	ldw	r5,-32692(gp)
            payload = perform_config_read(param);
            last_param = param;
        }

        /* Copy address offset from request to response buffer */
        *resp_data++ = *req_data++ - config_params[param].start;
    55f0:	10c5c83a 	sub	r2,r2,r3
    55f4:	98800005 	stb	r2,0(r19)

        /* Write read data into response buffer */
        *resp_data++ = (uint8_t) (payload >> (n * 8));
    55f8:	d9c00015 	stw	r7,0(sp)
    55fc:	00069140 	call	6914 <__lshrdi3>
    5600:	80800005 	stb	r2,0(r16)

        req_data++;
        n++;

        /* We've finished returning data for this request - reset and quit . */
        if (n >= config_params[param].len) {
    5604:	d9c00017 	ldw	r7,0(sp)

        /* Write read data into response buffer */
        *resp_data++ = (uint8_t) (payload >> (n * 8));

        req_data++;
        n++;
    5608:	e7000044 	addi	fp,fp,1
    560c:	d7201405 	stb	fp,-32688(gp)

        /* We've finished returning data for this request - reset and quit . */
        if (n >= config_params[param].len) {
    5610:	38800043 	ldbu	r2,1(r7)
    5614:	e7003fcc 	andi	fp,fp,255
    5618:	9cc00084 	addi	r19,r19,2
    561c:	94800084 	addi	r18,r18,2
    5620:	84000084 	addi	r16,r16,2
    5624:	e0bfab36 	bltu	fp,r2,54d4 <pkt_legacy+0xd8>
            n = 0;
            param = CONFIG_UNKNOWN;
    5628:	00800304 	movi	r2,12
        req_data++;
        n++;

        /* We've finished returning data for this request - reset and quit . */
        if (n >= config_params[param].len) {
            n = 0;
    562c:	d0201405 	stb	zero,-32688(gp)
            param = CONFIG_UNKNOWN;
    5630:	d0a00415 	stw	r2,-32752(gp)
    5634:	00009106 	br	587c <pkt_legacy+0x480>
    DBG("%s: read=%s, write=%s, dev_id=0x%x, cfg=%x, count=%d\n", __FUNCTION__,
        is_read ? "true" : "false", is_write ? "true" : "false", dev_id, cfg, count);

    if (is_read) {
        legacy_pkt_read(dev_id, count, b);
    } else if (is_write) {
    5638:	20009026 	beq	r4,zero,587c <pkt_legacy+0x480>

static inline void legacy_pkt_write(uint8_t dev_id, uint8_t count,
                                   struct pkt_buf *b)

{
    switch (dev_id) {
    563c:	10803fcc 	andi	r2,r2,255
    5640:	00c00404 	movi	r3,16
    5644:	10c00426 	beq	r2,r3,5658 <pkt_legacy+0x25c>
    5648:	00c00c04 	movi	r3,48
    564c:	10c00626 	beq	r2,r3,5668 <pkt_legacy+0x26c>
    5650:	10008a1e 	bne	r2,zero,587c <pkt_legacy+0x480>
    5654:	00000b06 	br	5684 <pkt_legacy+0x288>
        case NIOS_PKT_LEGACY_DEV_LMS:
            lms6_write(b->req[ADDR_IDX], b->req[DATA_IDX]);
    5658:	814000c3 	ldbu	r5,3(r16)
    565c:	81000083 	ldbu	r4,2(r16)
    5660:	00048380 	call	4838 <lms6_write>
    5664:	00000306 	br	5674 <pkt_legacy+0x278>
            b->resp[ADDR_IDX] = b->req[ADDR_IDX];
            b->resp[DATA_IDX] = 0;
            break;

        case NIOS_PKT_LEGACY_DEV_SI5338:
            si5338_write(b->req[ADDR_IDX], b->req[DATA_IDX]);
    5668:	814000c3 	ldbu	r5,3(r16)
    566c:	81000083 	ldbu	r4,2(r16)
    5670:	00048ec0 	call	48ec <si5338_write>

            b->resp[ADDR_IDX] = b->req[ADDR_IDX];
    5674:	80800083 	ldbu	r2,2(r16)
            b->resp[DATA_IDX] = 0;
    5678:	800004c5 	stb	zero,19(r16)
            break;

        case NIOS_PKT_LEGACY_DEV_SI5338:
            si5338_write(b->req[ADDR_IDX], b->req[DATA_IDX]);

            b->resp[ADDR_IDX] = b->req[ADDR_IDX];
    567c:	80800485 	stb	r2,18(r16)
    5680:	00007e06 	br	587c <pkt_legacy+0x480>
    static enum config_param last_param = CONFIG_UNKNOWN;

    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];

    param = lookup_param(b->req[PAYLOAD_IDX]);
    5684:	81000083 	ldbu	r4,2(r16)
    static uint64_t payload = 0;
    static uint8_t n = 0;
    static enum config_param param = CONFIG_UNKNOWN;
    static enum config_param last_param = CONFIG_UNKNOWN;

    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    5688:	84800084 	addi	r18,r16,2
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];
    568c:	84c00484 	addi	r19,r16,18

    param = lookup_param(b->req[PAYLOAD_IDX]);
    5690:	00053b00 	call	53b0 <lookup_param>

    /* Reset if we're at the beggining of a requst, or if it appears
     * that we got a different request while in the middle of the previous
     * series of accesses. */
    if (n == 0 || (param != last_param)) {
    5694:	d0e01103 	ldbu	r3,-32700(gp)
    static enum config_param last_param = CONFIG_UNKNOWN;

    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];

    param = lookup_param(b->req[PAYLOAD_IDX]);
    5698:	d0a00215 	stw	r2,-32760(gp)

    /* Reset if we're at the beggining of a requst, or if it appears
     * that we got a different request while in the middle of the previous
     * series of accesses. */
    if (n == 0 || (param != last_param)) {
    569c:	18000226 	beq	r3,zero,56a8 <pkt_legacy+0x2ac>
    56a0:	d0e00117 	ldw	r3,-32764(gp)
    56a4:	10c00326 	beq	r2,r3,56b4 <pkt_legacy+0x2b8>
        DBG("Resetting write state for param=%d with n=%d\n", param, n);
        payload = 0;
    56a8:	d0200f15 	stw	zero,-32708(gp)
    56ac:	d0201015 	stw	zero,-32704(gp)
        n = 0;
    56b0:	d0201105 	stb	zero,-32700(gp)
    56b4:	d1201103 	ldbu	r4,-32700(gp)
    }

    for (i = 0; i < count && n < config_params[param].len; i++) {
    56b8:	02000034 	movhi	r8,0
    56bc:	1095883a 	add	r10,r2,r2
    56c0:	421be004 	addi	r8,r8,28544
    56c4:	d1e00f17 	ldw	r7,-32708(gp)
    56c8:	d1a01017 	ldw	r6,-32704(gp)
    56cc:	8923883a 	add	r17,r17,r4
    56d0:	4291883a 	add	r8,r8,r10
    56d4:	824004c4 	addi	r9,r16,19
    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];

    param = lookup_param(b->req[PAYLOAD_IDX]);

    for (i = 0; i < count; i++) {
    56d8:	0007883a 	mov	r3,zero
    56dc:	840000c4 	addi	r16,r16,3
        DBG("Resetting write state for param=%d with n=%d\n", param, n);
        payload = 0;
        n = 0;
    }

    for (i = 0; i < count && n < config_params[param].len; i++) {
    56e0:	8c403fcc 	andi	r17,r17,255
    56e4:	43000044 	addi	r12,r8,1
    56e8:	21403fcc 	andi	r5,r4,255
    56ec:	89400c1e 	bne	r17,r5,5720 <pkt_legacy+0x324>
    56f0:	18c03fcc 	andi	r3,r3,255
    56f4:	18000326 	beq	r3,zero,5704 <pkt_legacy+0x308>
    56f8:	d1e00f15 	stw	r7,-32708(gp)
    56fc:	d1a01015 	stw	r6,-32704(gp)
    5700:	d1201105 	stb	r4,-32700(gp)
        req_data++;
        n++;
    }

    /* We aggregated all the data we need - perform the write and reset */
    if (n >= config_params[param].len) {
    5704:	00c00034 	movhi	r3,0
    5708:	18dbe004 	addi	r3,r3,28544
    570c:	1a87883a 	add	r3,r3,r10
    5710:	18c00043 	ldbu	r3,1(r3)
    5714:	d1201103 	ldbu	r4,-32700(gp)
    5718:	20c05636 	bltu	r4,r3,5874 <pkt_legacy+0x478>
    571c:	00001a06 	br	5788 <pkt_legacy+0x38c>
        DBG("Resetting write state for param=%d with n=%d\n", param, n);
        payload = 0;
        n = 0;
    }

    for (i = 0; i < count && n < config_params[param].len; i++) {
    5720:	62c00003 	ldbu	r11,0(r12)
    5724:	23400044 	addi	r13,r4,1
    5728:	2ac0122e 	bgeu	r5,r11,5774 <pkt_legacy+0x378>
        /* Copy over address offset into response, and zero out data*/
        *resp_data++ = *req_data++ - config_params[param].start;
    572c:	91000003 	ldbu	r4,0(r18)
    5730:	40c00003 	ldbu	r3,0(r8)
        *resp_data++ = 0;

        /* Shift data into our aggregated payload word */
        payload |= (*req_data) << (n * 8);
    5734:	280a90fa 	slli	r5,r5,3
    5738:	9cc00084 	addi	r19,r19,2
        n = 0;
    }

    for (i = 0; i < count && n < config_params[param].len; i++) {
        /* Copy over address offset into response, and zero out data*/
        *resp_data++ = *req_data++ - config_params[param].start;
    573c:	20c9c83a 	sub	r4,r4,r3
    5740:	993fff85 	stb	r4,-2(r19)
        *resp_data++ = 0;
    5744:	48000005 	stb	zero,0(r9)

        /* Shift data into our aggregated payload word */
        payload |= (*req_data) << (n * 8);
    5748:	80c00003 	ldbu	r3,0(r16)
    574c:	94800084 	addi	r18,r18,2
    5750:	4a400084 	addi	r9,r9,2
    5754:	194a983a 	sll	r5,r3,r5
    5758:	84000084 	addi	r16,r16,2
    575c:	6809883a 	mov	r4,r13
    5760:	2807d7fa 	srai	r3,r5,31
    5764:	394eb03a 	or	r7,r7,r5
    5768:	30ccb03a 	or	r6,r6,r3
    576c:	00c00044 	movi	r3,1
    5770:	003fdd06 	br	56e8 <pkt_legacy+0x2ec>
    5774:	18c03fcc 	andi	r3,r3,255
    5778:	183fe226 	beq	r3,zero,5704 <pkt_legacy+0x308>
    577c:	d1e00f15 	stw	r7,-32708(gp)
    5780:	d1a01015 	stw	r6,-32704(gp)
    5784:	d1201105 	stb	r4,-32700(gp)
    }
}

static inline void perform_config_write(enum config_param p, uint64_t payload)
{
    switch (p) {
    5788:	00c002c4 	movi	r3,11
        n++;
    }

    /* We aggregated all the data we need - perform the write and reset */
    if (n >= config_params[param].len) {
        perform_config_write(param, payload);
    578c:	d4200f17 	ldw	r16,-32708(gp)
    }
}

static inline void perform_config_write(enum config_param p, uint64_t payload)
{
    switch (p) {
    5790:	18803536 	bltu	r3,r2,5868 <pkt_legacy+0x46c>
    5794:	100490ba 	slli	r2,r2,2
    5798:	00c00034 	movhi	r3,0
    579c:	18d5eb04 	addi	r3,r3,22444
    57a0:	10c5883a 	add	r2,r2,r3
    57a4:	10800017 	ldw	r2,0(r2)
    57a8:	1000683a 	jmp	r2
    57ac:	000057dc 	xori	zero,zero,351
    57b0:	000057e4 	muli	zero,zero,351
    57b4:	000057f0 	cmpltui	zero,zero,351
    57b8:	000057fc 	xorhi	zero,zero,351
    57bc:	0000580c 	andi	zero,zero,352
    57c0:	00005868 	cmpgeui	zero,zero,353
    57c4:	0000581c 	xori	zero,zero,352
    57c8:	00005824 	muli	zero,zero,352
    57cc:	00005830 	cmpltui	zero,zero,352
    57d0:	0000584c 	andi	zero,zero,353
    57d4:	00005858 	cmpnei	zero,zero,353
    57d8:	00005860 	cmpeqi	zero,zero,353
    return IORD_ALTERA_AVALON_PIO_DATA(CONTROL_BASE);
}

static inline void control_reg_write(uint32_t value)
{
    IOWR_ALTERA_AVALON_PIO_DATA(CONTROL_BASE, value);
    57dc:	00a41014 	movui	r2,36928
    57e0:	00002006 	br	5864 <pkt_legacy+0x468>
        case CONFIG_CONTROL_REG:
            control_reg_write((uint32_t) payload);
            break;

        case CONFIG_IQ_CORR_RX_GAIN:
            iqbal_set_gain(BLADERF_MODULE_RX, (uint16_t) payload);
    57e4:	817fffcc 	andi	r5,r16,65535
    57e8:	0009883a 	mov	r4,zero
    57ec:	00000506 	br	5804 <pkt_legacy+0x408>
            break;

        case CONFIG_IQ_CORR_RX_PHASE:
            iqbal_set_phase(BLADERF_MODULE_RX, (uint16_t) payload);
    57f0:	817fffcc 	andi	r5,r16,65535
    57f4:	0009883a 	mov	r4,zero
    57f8:	00000606 	br	5814 <pkt_legacy+0x418>
            break;

        case CONFIG_IQ_CORR_TX_GAIN:
            iqbal_set_gain(BLADERF_MODULE_TX, (uint16_t) payload);
    57fc:	817fffcc 	andi	r5,r16,65535
    5800:	01000044 	movi	r4,1
    5804:	0004ab80 	call	4ab8 <iqbal_set_gain>
    5808:	00001706 	br	5868 <pkt_legacy+0x46c>
            break;

        case CONFIG_IQ_CORR_TX_PHASE:
            iqbal_set_phase(BLADERF_MODULE_TX, (uint16_t) payload);
    580c:	817fffcc 	andi	r5,r16,65535
    5810:	01000044 	movi	r4,1
    5814:	0004afc0 	call	4afc <iqbal_set_phase>
    5818:	00001306 	br	5868 <pkt_legacy+0x46c>

INLINE void time_tamer_reset(bladerf_module m)
{
    /* A single write is sufficient to clear the timestamp counter */
    if (m == BLADERF_MODULE_RX) {
        IOWR_8DIRECT(RX_TAMER_BASE, 0, 0);
    581c:	00a45814 	movui	r2,37216
    5820:	00000106 	br	5828 <pkt_legacy+0x42c>
    } else {
        IOWR_8DIRECT(TX_TAMER_BASE, 0, 0);
    5824:	00a45014 	movui	r2,37184
    5828:	10000025 	stbio	zero,0(r2)
    582c:	00000e06 	br	5868 <pkt_legacy+0x46c>
             * yielding writes for these specific commands:
             *
             * Command 0x28: Set device to write-through mode
             * Command 0x08: Write value to channel 0
             */
            vctcxo_trim_dac_write(0x28, 0);
    5830:	000b883a 	mov	r5,zero
    5834:	01000a04 	movi	r4,40
    5838:	00049780 	call	4978 <vctcxo_trim_dac_write>
            vctcxo_trim_dac_write(0x08, (uint16_t) payload);
    583c:	817fffcc 	andi	r5,r16,65535
    5840:	01000204 	movi	r4,8
    5844:	00049780 	call	4978 <vctcxo_trim_dac_write>
    5848:	00000706 	br	5868 <pkt_legacy+0x46c>
            break;

        case CONFIG_XB200_SYNTH:
            adf4351_write((uint32_t) payload);
    584c:	8009883a 	mov	r4,r16
    5850:	0004a4c0 	call	4a4c <adf4351_write>
    5854:	00000406 	br	5868 <pkt_legacy+0x46c>
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE);
}

INLINE void expansion_port_write(uint32_t value)
{
    IOWR_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE, value);
    5858:	00a42c14 	movui	r2,37040
    585c:	00000106 	br	5864 <pkt_legacy+0x468>
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_DIR_BASE);
}

INLINE void expansion_port_set_direction(uint32_t dir)
{
    IOWR_ALTERA_AVALON_PIO_DATA(XB_GPIO_DIR_BASE, dir);
    5860:	00a42814 	movui	r2,37024
    5864:	14000035 	stwio	r16,0(r2)

    /* We aggregated all the data we need - perform the write and reset */
    if (n >= config_params[param].len) {
        perform_config_write(param, payload);
        n = 0;
        param = CONFIG_UNKNOWN;
    5868:	00800304 	movi	r2,12
    }

    /* We aggregated all the data we need - perform the write and reset */
    if (n >= config_params[param].len) {
        perform_config_write(param, payload);
        n = 0;
    586c:	d0201105 	stb	zero,-32700(gp)
        param = CONFIG_UNKNOWN;
    5870:	d0a00215 	stw	r2,-32760(gp)
    }

    last_param = param;
    5874:	d0a00217 	ldw	r2,-32760(gp)
    5878:	d0a00115 	stw	r2,-32764(gp)
    } else if (is_write) {
        legacy_pkt_write(dev_id, count, b);
    } else {
        DBG("Config word did not have R/W: 0x%x\n", cfg);
    }
}
    587c:	dfc00a17 	ldw	ra,40(sp)
    5880:	df000917 	ldw	fp,36(sp)
    5884:	ddc00817 	ldw	r23,32(sp)
    5888:	dd800717 	ldw	r22,28(sp)
    588c:	dd400617 	ldw	r21,24(sp)
    5890:	dd000517 	ldw	r20,20(sp)
    5894:	dcc00417 	ldw	r19,16(sp)
    5898:	dc800317 	ldw	r18,12(sp)
    589c:	dc400217 	ldw	r17,8(sp)
    58a0:	dc000117 	ldw	r16,4(sp)
    58a4:	dec00b04 	addi	sp,sp,44
    58a8:	f800283a 	ret

000058ac <reset_queue>:
/* The retune interrupt may fire while this call is occuring, so we should
 * perform these operations in an order that minimizes the race window, and
 * does not cause the race to be problematic. It's fine if the last retune
 * occurs before we can cancel it. */
static void reset_queue(struct queue *q)
{
    58ac:	defffc04 	addi	sp,sp,-16
    58b0:	dc800215 	stw	r18,8(sp)
    58b4:	dc400115 	stw	r17,4(sp)
    58b8:	dc000015 	stw	r16,0(sp)
    58bc:	dfc00315 	stw	ra,12(sp)
    58c0:	2021883a 	mov	r16,r4
    unsigned int i;

    q->count = 0;
    58c4:	20000005 	stb	zero,0(r4)

    for (i = 0; i < RETUNE_QUEUE_MAX; i++) {
    58c8:	0023883a 	mov	r17,zero
    58cc:	04800404 	movi	r18,16
        q->entries[i].state = ENTRY_STATE_INVALID;
    58d0:	8809883a 	mov	r4,r17
    58d4:	01400604 	movi	r5,24
    58d8:	0006b080 	call	6b08 <__mulsi3>
    58dc:	8085883a 	add	r2,r16,r2
    58e0:	10800104 	addi	r2,r2,4
    58e4:	10000015 	stw	zero,0(r2)
{
    unsigned int i;

    q->count = 0;

    for (i = 0; i < RETUNE_QUEUE_MAX; i++) {
    58e8:	8c400044 	addi	r17,r17,1
    58ec:	8cbff81e 	bne	r17,r18,58d0 <reset_queue+0x24>
        q->entries[i].state = ENTRY_STATE_INVALID;
    }

    q->rem_idx = q->ins_idx = 0;
    58f0:	80000045 	stb	zero,1(r16)
    58f4:	80000085 	stb	zero,2(r16)
}
    58f8:	dfc00317 	ldw	ra,12(sp)
    58fc:	dc800217 	ldw	r18,8(sp)
    5900:	dc400117 	ldw	r17,4(sp)
    5904:	dc000017 	ldw	r16,0(sp)
    5908:	dec00404 	addi	sp,sp,16
    590c:	f800283a 	ret

00005910 <retune_isr>:
}

/* Get the state of the next item in the retune queue */
static inline struct queue_entry * peek_next_retune(struct queue *q)
{
    if (q->count == 0) {
    5910:	20800003 	ldbu	r2,0(r4)
    5914:	10001c26 	beq	r2,zero,5988 <retune_isr+0x78>

    q->rem_idx = q->ins_idx = 0;
}

static inline void retune_isr(struct queue *q)
{
    5918:	defffd04 	addi	sp,sp,-12
    591c:	dc000015 	stw	r16,0(sp)
    5920:	dfc00215 	stw	ra,8(sp)
    5924:	dc400115 	stw	r17,4(sp)
static inline struct queue_entry * peek_next_retune(struct queue *q)
{
    if (q->count == 0) {
        return NULL;
    } else {
        return &q->entries[q->rem_idx];
    5928:	24400083 	ldbu	r17,2(r4)
    592c:	2021883a 	mov	r16,r4
    5930:	01400604 	movi	r5,24
    5934:	8809883a 	mov	r4,r17
    5938:	0006b080 	call	6b08 <__mulsi3>
    593c:	10c00104 	addi	r3,r2,4
    5940:	80c7883a 	add	r3,r16,r3
}

static inline void retune_isr(struct queue *q)
{
    struct queue_entry *e = peek_next_retune(q);
    if (e != NULL) {
    5944:	18000c26 	beq	r3,zero,5978 <retune_isr+0x68>
        if (e->state == ENTRY_STATE_SCHEDULED) {
    5948:	8085883a 	add	r2,r16,r2
    594c:	10800104 	addi	r2,r2,4
    5950:	10c00017 	ldw	r3,0(r2)
    5954:	00800084 	movi	r2,2
    5958:	1880071e 	bne	r3,r2,5978 <retune_isr+0x68>
            e->state = ENTRY_STATE_READY;
    595c:	01400604 	movi	r5,24
    5960:	8809883a 	mov	r4,r17
    5964:	0006b080 	call	6b08 <__mulsi3>
    5968:	8085883a 	add	r2,r16,r2
    596c:	10800104 	addi	r2,r2,4
    5970:	00c000c4 	movi	r3,3
    5974:	10c00015 	stw	r3,0(r2)
        } else {
            INCREMENT_ERROR_COUNT();
        }
    }
}
    5978:	dfc00217 	ldw	ra,8(sp)
    597c:	dc400117 	ldw	r17,4(sp)
    5980:	dc000017 	ldw	r16,0(sp)
    5984:	dec00304 	addi	sp,sp,12
    5988:	f800283a 	ret

0000598c <retune_tx>:
}

static void retune_tx(void *context)
{
	/* Handle the ISR */
    retune_isr(&tx_queue);
    598c:	01000034 	movhi	r4,0
    /* Clear the interrupt */
    timer_tamer_clear_interrupt(BLADERF_MODULE_RX);
}

static void retune_tx(void *context)
{
    5990:	deffff04 	addi	sp,sp,-4
	/* Handle the ISR */
    retune_isr(&tx_queue);
    5994:	211c0004 	addi	r4,r4,28672
    /* Clear the interrupt */
    timer_tamer_clear_interrupt(BLADERF_MODULE_RX);
}

static void retune_tx(void *context)
{
    5998:	dfc00015 	stw	ra,0(sp)
	/* Handle the ISR */
    retune_isr(&tx_queue);
    599c:	00059100 	call	5910 <retune_isr>
INLINE void timer_tamer_clear_interrupt(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
        IOWR_8DIRECT(RX_TAMER_BASE, 8, 1) ;
    } else {
        IOWR_8DIRECT(TX_TAMER_BASE, 8, 1) ;
    59a0:	00a45214 	movui	r2,37192
    59a4:	00c00044 	movi	r3,1
    59a8:	10c00025 	stbio	r3,0(r2)

    /* Clear the interrupt */
    timer_tamer_clear_interrupt(BLADERF_MODULE_TX);
}
    59ac:	dfc00017 	ldw	ra,0(sp)
    59b0:	dec00104 	addi	sp,sp,4
    59b4:	f800283a 	ret

000059b8 <retune_rx>:

#ifndef BLADERF_NIOS_PC_SIMULATION
static void retune_rx(void *context)
{
	/* Handle the ISR */
    retune_isr(&rx_queue);
    59b8:	01000034 	movhi	r4,0
}


#ifndef BLADERF_NIOS_PC_SIMULATION
static void retune_rx(void *context)
{
    59bc:	deffff04 	addi	sp,sp,-4
	/* Handle the ISR */
    retune_isr(&rx_queue);
    59c0:	211c6104 	addi	r4,r4,29060
}


#ifndef BLADERF_NIOS_PC_SIMULATION
static void retune_rx(void *context)
{
    59c4:	dfc00015 	stw	ra,0(sp)
	/* Handle the ISR */
    retune_isr(&rx_queue);
    59c8:	00059100 	call	5910 <retune_isr>
}

INLINE void timer_tamer_clear_interrupt(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
        IOWR_8DIRECT(RX_TAMER_BASE, 8, 1) ;
    59cc:	00a45a14 	movui	r2,37224
    59d0:	00c00044 	movi	r3,1
    59d4:	10c00025 	stbio	r3,0(r2)

    /* Clear the interrupt */
    timer_tamer_clear_interrupt(BLADERF_MODULE_RX);
}
    59d8:	dfc00017 	ldw	ra,0(sp)
    59dc:	dec00104 	addi	sp,sp,4
    59e0:	f800283a 	ret

000059e4 <perform_work>:
}

/* Get the state of the next item in the retune queue */
static inline struct queue_entry * peek_next_retune(struct queue *q)
{
    if (q->count == 0) {
    59e4:	20800003 	ldbu	r2,0(r4)
    59e8:	10004326 	beq	r2,zero,5af8 <perform_work+0x114>
    ) ;
#endif
}

static inline void perform_work(struct queue *q, bladerf_module module)
{
    59ec:	defffc04 	addi	sp,sp,-16
    59f0:	dc400115 	stw	r17,4(sp)
    59f4:	dc000015 	stw	r16,0(sp)
    59f8:	dfc00315 	stw	ra,12(sp)
    59fc:	dc800215 	stw	r18,8(sp)
static inline struct queue_entry * peek_next_retune(struct queue *q)
{
    if (q->count == 0) {
        return NULL;
    } else {
        return &q->entries[q->rem_idx];
    5a00:	24800083 	ldbu	r18,2(r4)
    5a04:	2021883a 	mov	r16,r4
    5a08:	2823883a 	mov	r17,r5
    5a0c:	9009883a 	mov	r4,r18
    5a10:	01400604 	movi	r5,24
    5a14:	0006b080 	call	6b08 <__mulsi3>
    5a18:	10c00104 	addi	r3,r2,4
    5a1c:	80c7883a 	add	r3,r16,r3

static inline void perform_work(struct queue *q, bladerf_module module)
{
    struct queue_entry *e = peek_next_retune(q);

    if (e == NULL) {
    5a20:	18003026 	beq	r3,zero,5ae4 <perform_work+0x100>
        return;
    }

    switch (e->state) {
    5a24:	8087883a 	add	r3,r16,r2
    5a28:	18c00104 	addi	r3,r3,4
    5a2c:	19000017 	ldw	r4,0(r3)
    5a30:	01400044 	movi	r5,1
    5a34:	21400326 	beq	r4,r5,5a44 <perform_work+0x60>
    5a38:	00c000c4 	movi	r3,3
    5a3c:	20c01126 	beq	r4,r3,5a84 <perform_work+0xa0>
    5a40:	00002806 	br	5ae4 <perform_work+0x100>
        case ENTRY_STATE_NEW:
            e->state = ENTRY_STATE_SCHEDULED;
    5a44:	00800084 	movi	r2,2
            tamer_schedule(module, e->timestamp);
    5a48:	9009883a 	mov	r4,r18
        return;
    }

    switch (e->state) {
        case ENTRY_STATE_NEW:
            e->state = ENTRY_STATE_SCHEDULED;
    5a4c:	18800015 	stw	r2,0(r3)
            tamer_schedule(module, e->timestamp);
    5a50:	01400604 	movi	r5,24
    5a54:	0006b080 	call	6b08 <__mulsi3>
    5a58:	8085883a 	add	r2,r16,r2
    5a5c:	10800504 	addi	r2,r2,20
    5a60:	11400017 	ldw	r5,0(r2)
    5a64:	11800117 	ldw	r6,4(r2)
    5a68:	8809883a 	mov	r4,r17

        default:
            INCREMENT_ERROR_COUNT();
            break;
    }
}
    5a6c:	dfc00317 	ldw	ra,12(sp)
    5a70:	dc800217 	ldw	r18,8(sp)
    5a74:	dc400117 	ldw	r17,4(sp)
    5a78:	dc000017 	ldw	r16,0(sp)
    5a7c:	dec00404 	addi	sp,sp,16
    }

    switch (e->state) {
        case ENTRY_STATE_NEW:
            e->state = ENTRY_STATE_SCHEDULED;
            tamer_schedule(module, e->timestamp);
    5a80:	00047081 	jmpi	4708 <tamer_schedule>
            break;

        case ENTRY_STATE_READY:

            /* Perform our retune */
            if (lms_set_precalculated_frequency(NULL, module, &e->freq)) {
    5a84:	11800204 	addi	r6,r2,8
    5a88:	818d883a 	add	r6,r16,r6
    5a8c:	880b883a 	mov	r5,r17
    5a90:	0009883a 	mov	r4,zero
    5a94:	00064a00 	call	64a0 <lms_set_precalculated_frequency>
    5a98:	1000091e 	bne	r2,zero,5ac0 <perform_work+0xdc>
                INCREMENT_ERROR_COUNT();
            } else {
                bool low_band = (e->freq.flags & LMS_FREQ_FLAGS_LOW_BAND) != 0;
    5a9c:	01400604 	movi	r5,24
    5aa0:	9009883a 	mov	r4,r18
    5aa4:	0006b080 	call	6b08 <__mulsi3>
    5aa8:	8085883a 	add	r2,r16,r2
                if (band_select(NULL, module, low_band)) {
    5aac:	11800403 	ldbu	r6,16(r2)
    5ab0:	880b883a 	mov	r5,r17
    5ab4:	0009883a 	mov	r4,zero
    5ab8:	3180004c 	andi	r6,r6,1
    5abc:	0005f300 	call	5f30 <band_select>
 * or QUEUE_EMPTY if there was nothing to dequeue */
static inline uint8_t dequeue_retune(struct queue *q, struct queue_entry *e)
{
    uint8_t ret;

    if (q->count == 0) {
    5ac0:	80c00003 	ldbu	r3,0(r16)
    5ac4:	18803fcc 	andi	r2,r3,255
    5ac8:	10000626 	beq	r2,zero,5ae4 <perform_work+0x100>

    if (e != NULL) {
        memcpy(&e, &q->entries[q->rem_idx], sizeof(e[0]));
    }

    q->rem_idx = (q->rem_idx + 1) & (RETUNE_QUEUE_MAX - 1);
    5acc:	80800083 	ldbu	r2,2(r16)

    q->count--;
    5ad0:	18ffffc4 	addi	r3,r3,-1
    5ad4:	80c00005 	stb	r3,0(r16)

    if (e != NULL) {
        memcpy(&e, &q->entries[q->rem_idx], sizeof(e[0]));
    }

    q->rem_idx = (q->rem_idx + 1) & (RETUNE_QUEUE_MAX - 1);
    5ad8:	10800044 	addi	r2,r2,1
    5adc:	108003cc 	andi	r2,r2,15
    5ae0:	80800085 	stb	r2,2(r16)

        default:
            INCREMENT_ERROR_COUNT();
            break;
    }
}
    5ae4:	dfc00317 	ldw	ra,12(sp)
    5ae8:	dc800217 	ldw	r18,8(sp)
    5aec:	dc400117 	ldw	r17,4(sp)
    5af0:	dc000017 	ldw	r16,0(sp)
    5af4:	dec00404 	addi	sp,sp,16
    5af8:	f800283a 	ret

00005afc <pkt_retune_init>:
#endif


void pkt_retune_init()
{
    reset_queue(&rx_queue);
    5afc:	01000034 	movhi	r4,0
}
#endif


void pkt_retune_init()
{
    5b00:	defffe04 	addi	sp,sp,-8
    reset_queue(&rx_queue);
    5b04:	211c6104 	addi	r4,r4,29060
}
#endif


void pkt_retune_init()
{
    5b08:	dfc00115 	stw	ra,4(sp)
    reset_queue(&rx_queue);
    5b0c:	00058ac0 	call	58ac <reset_queue>
    reset_queue(&tx_queue);
    5b10:	01000034 	movhi	r4,0
    5b14:	211c0004 	addi	r4,r4,28672
    5b18:	00058ac0 	call	58ac <reset_queue>

#ifndef BLADERF_NIOS_PC_SIMULATION

    /* Register RX Time Tamer ISR */
    alt_ic_isr_register(
    5b1c:	01800034 	movhi	r6,0
    5b20:	d8000015 	stw	zero,0(sp)
    5b24:	000f883a 	mov	r7,zero
    5b28:	31966e04 	addi	r6,r6,22968
    5b2c:	014000c4 	movi	r5,3
    5b30:	0009883a 	mov	r4,zero
    5b34:	0006b780 	call	6b78 <alt_ic_isr_register>
        NULL,
        NULL
    ) ;

    /* Register TX Time Tamer ISR */
    alt_ic_isr_register(
    5b38:	01800034 	movhi	r6,0
    5b3c:	d8000015 	stw	zero,0(sp)
    5b40:	000f883a 	mov	r7,zero
    5b44:	31966304 	addi	r6,r6,22924
    5b48:	01400084 	movi	r5,2
    5b4c:	0009883a 	mov	r4,zero
    5b50:	0006b780 	call	6b78 <alt_ic_isr_register>
        retune_tx,
        NULL,
        NULL
    ) ;
#endif
}
    5b54:	dfc00117 	ldw	ra,4(sp)
    5b58:	dec00204 	addi	sp,sp,8
    5b5c:	f800283a 	ret

00005b60 <pkt_retune_work>:
    }
}

void pkt_retune_work(void)
{
    perform_work(&rx_queue, BLADERF_MODULE_RX);
    5b60:	01000034 	movhi	r4,0
            break;
    }
}

void pkt_retune_work(void)
{
    5b64:	deffff04 	addi	sp,sp,-4
    perform_work(&rx_queue, BLADERF_MODULE_RX);
    5b68:	000b883a 	mov	r5,zero
    5b6c:	211c6104 	addi	r4,r4,29060
            break;
    }
}

void pkt_retune_work(void)
{
    5b70:	dfc00015 	stw	ra,0(sp)
    perform_work(&rx_queue, BLADERF_MODULE_RX);
    5b74:	00059e40 	call	59e4 <perform_work>
    perform_work(&tx_queue, BLADERF_MODULE_TX);
    5b78:	01000034 	movhi	r4,0
    5b7c:	01400044 	movi	r5,1
    5b80:	211c0004 	addi	r4,r4,28672
}
    5b84:	dfc00017 	ldw	ra,0(sp)
    5b88:	dec00104 	addi	sp,sp,4
}

void pkt_retune_work(void)
{
    perform_work(&rx_queue, BLADERF_MODULE_RX);
    perform_work(&tx_queue, BLADERF_MODULE_TX);
    5b8c:	00059e41 	jmpi	59e4 <perform_work>

00005b90 <pkt_retune>:
}

void pkt_retune(struct pkt_buf *b)
{
    5b90:	defff304 	addi	sp,sp,-52
    5b94:	dc000315 	stw	r16,12(sp)
    5b98:	2021883a 	mov	r16,r4
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 2]) << 16);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 3]) << 24);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 4]) << 32);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 5]) << 40);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 6]) << 48);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 7]) << 56);
    5b9c:	80800083 	ldbu	r2,2(r16)
    5ba0:	dd400815 	stw	r21,32(sp)
    5ba4:	854000c3 	ldbu	r21,3(r16)
    5ba8:	dc400415 	stw	r17,16(sp)
    5bac:	dfc00c15 	stw	ra,48(sp)
    5bb0:	df000b15 	stw	fp,44(sp)
    5bb4:	ddc00a15 	stw	r23,40(sp)
    5bb8:	dd800915 	stw	r22,36(sp)
    5bbc:	dd000715 	stw	r20,28(sp)
    5bc0:	dcc00615 	stw	r19,24(sp)
    5bc4:	dc800515 	stw	r18,20(sp)
    5bc8:	21000043 	ldbu	r4,1(r4)
    5bcc:	1004923a 	slli	r2,r2,8
    5bd0:	a82a943a 	slli	r21,r21,16
    5bd4:	844001c3 	ldbu	r17,7(r16)
    5bd8:	1106b03a 	or	r3,r2,r4
    5bdc:	a8c4b03a 	or	r2,r21,r3
    5be0:	85400103 	ldbu	r21,4(r16)
    5be4:	81000143 	ldbu	r4,5(r16)
    5be8:	8822943a 	slli	r17,r17,16
    5bec:	a82a963a 	slli	r21,r21,24
    5bf0:	a8aab03a 	or	r21,r21,r2
    5bf4:	80800183 	ldbu	r2,6(r16)
    5bf8:	1004923a 	slli	r2,r2,8
    5bfc:	1106b03a 	or	r3,r2,r4
    5c00:	88c4b03a 	or	r2,r17,r3
    5c04:	84400203 	ldbu	r17,8(r16)

    *nint  = buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 0] << 1;
    *nint |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 1] >> 7;
    5c08:	80c00243 	ldbu	r3,9(r16)
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 2]) << 16);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 3]) << 24);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 4]) << 32);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 5]) << 40);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 6]) << 48);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 7]) << 56);
    5c0c:	8822963a 	slli	r17,r17,24

    *nint  = buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 0] << 1;
    *nint |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 1] >> 7;
    5c10:	18c7883a 	add	r3,r3,r3
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 2]) << 16);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 3]) << 24);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 4]) << 32);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 5]) << 40);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 6]) << 48);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 7]) << 56);
    5c14:	88a2b03a 	or	r17,r17,r2

    *nint  = buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 0] << 1;
    *nint |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 1] >> 7;
    5c18:	80800283 	ldbu	r2,10(r16)
    5c1c:	11003fcc 	andi	r4,r2,255
    5c20:	2008d1fa 	srli	r4,r4,7

    *nfrac  = (buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 1] & 0x7f) << 16;
    *nfrac |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 2] << 8;
    *nfrac |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 3];
    5c24:	10801fcc 	andi	r2,r2,127
    5c28:	1004943a 	slli	r2,r2,16
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 5]) << 40);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 6]) << 48);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 7]) << 56);

    *nint  = buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 0] << 1;
    *nint |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 1] >> 7;
    5c2c:	1906b03a 	or	r3,r3,r4
    5c30:	d8c0008d 	sth	r3,2(sp)

    *nfrac  = (buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 1] & 0x7f) << 16;
    *nfrac |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 2] << 8;
    *nfrac |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 3];
    5c34:	80c002c3 	ldbu	r3,11(r16)
    5c38:	1808923a 	slli	r4,r3,8
    5c3c:	80c00303 	ldbu	r3,12(r16)
    5c40:	20c6b03a 	or	r3,r4,r3
    5c44:	1884b03a 	or	r2,r3,r2
    5c48:	d8800115 	stw	r2,4(sp)

    *freqsel = buf[NIOS_PKT_RETUNE_IDX_FREQSEL] & 0x3f;
    5c4c:	80800343 	ldbu	r2,13(r16)
    5c50:	10c00fcc 	andi	r3,r2,63
    5c54:	d8c00005 	stb	r3,0(sp)

    *module = -1;

    if (buf[NIOS_PKT_RETUNE_IDX_FREQSEL] & FLAG_TX) {
    5c58:	10c03fcc 	andi	r3,r2,255
    5c5c:	18c0201c 	xori	r3,r3,128
    5c60:	18ffe004 	addi	r3,r3,-128
    5c64:	18000616 	blt	r3,zero,5c80 <pkt_retune+0xf0>
        *module = BLADERF_MODULE_TX;
    } else if (buf[NIOS_PKT_RETUNE_IDX_FREQSEL] & FLAG_RX) {
    5c68:	14803fcc 	andi	r18,r2,255
    5c6c:	9024d1ba 	srli	r18,r18,6
    5c70:	9480005c 	xori	r18,r18,1
    5c74:	9480004c 	andi	r18,r18,1
    5c78:	04a5c83a 	sub	r18,zero,r18
    5c7c:	00000106 	br	5c84 <pkt_retune+0xf4>
    *freqsel = buf[NIOS_PKT_RETUNE_IDX_FREQSEL] & 0x3f;

    *module = -1;

    if (buf[NIOS_PKT_RETUNE_IDX_FREQSEL] & FLAG_TX) {
        *module = BLADERF_MODULE_TX;
    5c80:	04800044 	movi	r18,1
    } else if (buf[NIOS_PKT_RETUNE_IDX_FREQSEL] & FLAG_RX) {
        *module = BLADERF_MODULE_RX;
    }

    *low_band = (buf[NIOS_PKT_RETUNE_IDX_BANDSEL] & FLAG_LOW_BAND) != 0;
    5c84:	81800383 	ldbu	r6,14(r16)
    *quick_tune = (buf[NIOS_PKT_RETUNE_IDX_BANDSEL] & FLAG_QUICK_TUNE) != 0;
    *vcocap = buf[NIOS_PKT_RETUNE_IDX_BANDSEL] & 0x3f;
    5c88:	30c00fcc 	andi	r3,r6,63
                           &f.nint, &f.nfrac, &f.freqsel, &f.vcocap,
                           &low_band, &quick_tune);

    f.vcocap_result = 0xff;

    if (low_band) {
    5c8c:	35803fcc 	andi	r22,r6,255
    5c90:	d8c00045 	stb	r3,1(sp)
    5c94:	b580201c 	xori	r22,r22,128

    nios_pkt_retune_unpack(b->req, &module, &timestamp,
                           &f.nint, &f.nfrac, &f.freqsel, &f.vcocap,
                           &low_band, &quick_tune);

    f.vcocap_result = 0xff;
    5c98:	00ffffc4 	movi	r3,-1
    5c9c:	d8c00245 	stb	r3,9(sp)

    if (low_band) {
    5ca0:	b5bfe004 	addi	r22,r22,-128
    5ca4:	3080100c 	andi	r2,r6,64
    5ca8:	b000030e 	bge	r22,zero,5cb8 <pkt_retune+0x128>
        f.flags = LMS_FREQ_FLAGS_LOW_BAND;
    5cac:	00c00044 	movi	r3,1
    5cb0:	d8c00205 	stb	r3,8(sp)
    5cb4:	00000106 	br	5cbc <pkt_retune+0x12c>
    } else {
        f.flags = 0;
    5cb8:	d8000205 	stb	zero,8(sp)
    }

    if (quick_tune) {
    5cbc:	10000326 	beq	r2,zero,5ccc <pkt_retune+0x13c>
        f.flags |= LMS_FREQ_FLAGS_FORCE_VCOCAP;
    5cc0:	d8800203 	ldbu	r2,8(sp)
    5cc4:	10800094 	ori	r2,r2,2
    5cc8:	d8800205 	stb	r2,8(sp)
    }

    start_time = time_tamer_read(module);
    5ccc:	9009883a 	mov	r4,r18
    5cd0:	0004b5c0 	call	4b5c <time_tamer_read>
    5cd4:	1027883a 	mov	r19,r2

    if (timestamp == NIOS_PKT_RETUNE_NOW) {
    5cd8:	ac44b03a 	or	r2,r21,r17

    if (quick_tune) {
        f.flags |= LMS_FREQ_FLAGS_FORCE_VCOCAP;
    }

    start_time = time_tamer_read(module);
    5cdc:	1829883a 	mov	r20,r3

    if (timestamp == NIOS_PKT_RETUNE_NOW) {
    5ce0:	10000f1e 	bne	r2,zero,5d20 <pkt_retune+0x190>
        /* Fire off this retune operation now */
        switch (module) {
    5ce4:	00800044 	movi	r2,1
    5ce8:	14805e36 	bltu	r2,r18,5e64 <pkt_retune+0x2d4>
            case BLADERF_MODULE_RX:
            case BLADERF_MODULE_TX:
                status = lms_set_precalculated_frequency(NULL, module, &f);
    5cec:	d80d883a 	mov	r6,sp
    5cf0:	900b883a 	mov	r5,r18
    5cf4:	0009883a 	mov	r4,zero
    5cf8:	00064a00 	call	64a0 <lms_set_precalculated_frequency>
                if (status != 0) {
    5cfc:	1000881e 	bne	r2,zero,5f20 <pkt_retune+0x390>
                    goto out;
                }

                flags |= NIOS_PKT_RETUNERESP_FLAG_TSVTUNE_VALID;

                status = band_select(NULL, module, low_band);
    5d00:	b00cd7fa 	srli	r6,r22,31
    5d04:	900b883a 	mov	r5,r18
    5d08:	0009883a 	mov	r4,zero
    5d0c:	0005f300 	call	5f30 <band_select>
    5d10:	1023883a 	mov	r17,r2
                status = lms_set_precalculated_frequency(NULL, module, &f);
                if (status != 0) {
                    goto out;
                }

                flags |= NIOS_PKT_RETUNERESP_FLAG_TSVTUNE_VALID;
    5d14:	054000c4 	movi	r21,3

                status = band_select(NULL, module, low_band);
                if (status != 0) {
    5d18:	1000821e 	bne	r2,zero,5f24 <pkt_retune+0x394>
    5d1c:	00005306 	br	5e6c <pkt_retune+0x2dc>
            default:
                INCREMENT_ERROR_COUNT();
                status = -1;
        }

    } else if (timestamp == NIOS_PKT_RETUNE_CLEAR_QUEUE) {
    5d20:	00bfffc4 	movi	r2,-1
    5d24:	a8800d1e 	bne	r21,r2,5d5c <pkt_retune+0x1cc>
    5d28:	8d400c1e 	bne	r17,r21,5d5c <pkt_retune+0x1cc>
        switch (module) {
    5d2c:	90000526 	beq	r18,zero,5d44 <pkt_retune+0x1b4>
    5d30:	00800044 	movi	r2,1
    5d34:	9080491e 	bne	r18,r2,5e5c <pkt_retune+0x2cc>
                reset_queue(&rx_queue);
                status = 0;
                break;

            case BLADERF_MODULE_TX:
                reset_queue(&tx_queue);
    5d38:	01000034 	movhi	r4,0
    5d3c:	211c0004 	addi	r4,r4,28672
    5d40:	00000206 	br	5d4c <pkt_retune+0x1bc>
        }

    } else if (timestamp == NIOS_PKT_RETUNE_CLEAR_QUEUE) {
        switch (module) {
            case BLADERF_MODULE_RX:
                reset_queue(&rx_queue);
    5d44:	01000034 	movhi	r4,0
    5d48:	211c6104 	addi	r4,r4,29060
                status = 0;
                break;

            case BLADERF_MODULE_TX:
                reset_queue(&tx_queue);
    5d4c:	00058ac0 	call	58ac <reset_queue>
    uint64_t end_time;
    uint64_t duration = 0;
    bool low_band;
    bool quick_tune;

    flags = NIOS_PKT_RETUNERESP_FLAG_SUCCESS;
    5d50:	05400084 	movi	r21,2
                status = 0;
                break;

            case BLADERF_MODULE_TX:
                reset_queue(&tx_queue);
                status = 0;
    5d54:	0023883a 	mov	r17,zero
                break;
    5d58:	00004406 	br	5e6c <pkt_retune+0x2dc>
                status = -1;
        }
    } else {
        uint8_t queue_size;

        switch (module) {
    5d5c:	90000326 	beq	r18,zero,5d6c <pkt_retune+0x1dc>
    5d60:	00800044 	movi	r2,1
    5d64:	90801826 	beq	r18,r2,5dc8 <pkt_retune+0x238>
    5d68:	00003e06 	br	5e64 <pkt_retune+0x2d4>
                                     const struct lms_freq *f,
                                     uint64_t timestamp)
{
    uint8_t ret;

    if (q->count >= RETUNE_QUEUE_MAX) {
    5d6c:	05800034 	movhi	r22,0
    5d70:	b59c6104 	addi	r22,r22,29060
    5d74:	b0800003 	ldbu	r2,0(r22)
    5d78:	00c003c4 	movi	r3,15
    5d7c:	18803936 	bltu	r3,r2,5e64 <pkt_retune+0x2d4>
        return QUEUE_FULL;
    }

    memcpy(&q->entries[q->ins_idx].freq, f, sizeof(f[0]));
    5d80:	b1000043 	ldbu	r4,1(r22)
    5d84:	01400604 	movi	r5,24
    5d88:	0006b080 	call	6b08 <__mulsi3>
    5d8c:	10800204 	addi	r2,r2,8
    5d90:	01800304 	movi	r6,12
    5d94:	d80b883a 	mov	r5,sp
    5d98:	b089883a 	add	r4,r22,r2
    5d9c:	0006b300 	call	6b30 <memcpy>

    q->entries[q->ins_idx].state = ENTRY_STATE_NEW;
    5da0:	b5c00043 	ldbu	r23,1(r22)
    5da4:	01400604 	movi	r5,24
    5da8:	bf003fcc 	andi	fp,r23,255
    5dac:	e009883a 	mov	r4,fp
    5db0:	0006b080 	call	6b08 <__mulsi3>
    5db4:	b085883a 	add	r2,r22,r2
    5db8:	10800104 	addi	r2,r2,4
    5dbc:	00c00044 	movi	r3,1
    5dc0:	10c00015 	stw	r3,0(r2)
    5dc4:	00001506 	br	5e1c <pkt_retune+0x28c>
                                     const struct lms_freq *f,
                                     uint64_t timestamp)
{
    uint8_t ret;

    if (q->count >= RETUNE_QUEUE_MAX) {
    5dc8:	05800034 	movhi	r22,0
    5dcc:	b59c0004 	addi	r22,r22,28672
    5dd0:	b0800003 	ldbu	r2,0(r22)
    5dd4:	00c003c4 	movi	r3,15
    5dd8:	18802236 	bltu	r3,r2,5e64 <pkt_retune+0x2d4>
        return QUEUE_FULL;
    }

    memcpy(&q->entries[q->ins_idx].freq, f, sizeof(f[0]));
    5ddc:	b1000043 	ldbu	r4,1(r22)
    5de0:	01400604 	movi	r5,24
    5de4:	0006b080 	call	6b08 <__mulsi3>
    5de8:	10800204 	addi	r2,r2,8
    5dec:	01800304 	movi	r6,12
    5df0:	d80b883a 	mov	r5,sp
    5df4:	b089883a 	add	r4,r22,r2
    5df8:	0006b300 	call	6b30 <memcpy>

    q->entries[q->ins_idx].state = ENTRY_STATE_NEW;
    5dfc:	b5c00043 	ldbu	r23,1(r22)
    5e00:	01400604 	movi	r5,24
    5e04:	bf003fcc 	andi	fp,r23,255
    5e08:	e009883a 	mov	r4,fp
    5e0c:	0006b080 	call	6b08 <__mulsi3>
    5e10:	b085883a 	add	r2,r22,r2
    5e14:	10800104 	addi	r2,r2,4
    5e18:	14800015 	stw	r18,0(r2)
    q->entries[q->ins_idx].timestamp = timestamp;
    5e1c:	01400604 	movi	r5,24
    5e20:	e009883a 	mov	r4,fp
    5e24:	0006b080 	call	6b08 <__mulsi3>
    5e28:	b085883a 	add	r2,r22,r2
    5e2c:	10800504 	addi	r2,r2,20
    5e30:	14400115 	stw	r17,4(r2)
    5e34:	15400015 	stw	r21,0(r2)

    q->ins_idx = (q->ins_idx + 1) & (RETUNE_QUEUE_MAX - 1);

    q->count++;
    5e38:	b0800003 	ldbu	r2,0(r22)
    memcpy(&q->entries[q->ins_idx].freq, f, sizeof(f[0]));

    q->entries[q->ins_idx].state = ENTRY_STATE_NEW;
    q->entries[q->ins_idx].timestamp = timestamp;

    q->ins_idx = (q->ins_idx + 1) & (RETUNE_QUEUE_MAX - 1);
    5e3c:	bdc00044 	addi	r23,r23,1
    5e40:	bdc003cc 	andi	r23,r23,15

    q->count++;
    5e44:	10800044 	addi	r2,r2,1
                INCREMENT_ERROR_COUNT();
                queue_size = QUEUE_FULL;

        }

        if (queue_size == QUEUE_FULL) {
    5e48:	14403fcc 	andi	r17,r2,255
    5e4c:	8c403fe0 	cmpeqi	r17,r17,255
    memcpy(&q->entries[q->ins_idx].freq, f, sizeof(f[0]));

    q->entries[q->ins_idx].state = ENTRY_STATE_NEW;
    q->entries[q->ins_idx].timestamp = timestamp;

    q->ins_idx = (q->ins_idx + 1) & (RETUNE_QUEUE_MAX - 1);
    5e50:	b5c00045 	stb	r23,1(r22)

    q->count++;
    5e54:	b0800005 	stb	r2,0(r22)
                INCREMENT_ERROR_COUNT();
                queue_size = QUEUE_FULL;

        }

        if (queue_size == QUEUE_FULL) {
    5e58:	0463c83a 	sub	r17,zero,r17
    uint64_t end_time;
    uint64_t duration = 0;
    bool low_band;
    bool quick_tune;

    flags = NIOS_PKT_RETUNERESP_FLAG_SUCCESS;
    5e5c:	05400084 	movi	r21,2
    5e60:	00000206 	br	5e6c <pkt_retune+0x2dc>
    5e64:	05400084 	movi	r21,2
                queue_size = QUEUE_FULL;

        }

        if (queue_size == QUEUE_FULL) {
            status = -1;
    5e68:	047fffc4 	movi	r17,-1
        } else {
            status = 0;
        }
    }

    end_time = time_tamer_read(module);
    5e6c:	9009883a 	mov	r4,r18
    5e70:	0004b5c0 	call	4b5c <time_tamer_read>
    duration = end_time - start_time;
    5e74:	14e7c83a 	sub	r19,r2,r19
    5e78:	14c5803a 	cmpltu	r2,r2,r19
    5e7c:	1d07c83a 	sub	r3,r3,r20
    5e80:	1887c83a 	sub	r3,r3,r2

out:
    if (status != 0) {
    5e84:	88000226 	beq	r17,zero,5e90 <pkt_retune+0x300>
        flags &= ~(NIOS_PKT_RETUNERESP_FLAG_SUCCESS);
    5e88:	00bfff44 	movi	r2,-3
    5e8c:	156a703a 	and	r21,r2,r21
static inline void nios_pkt_retune_resp_pack(uint8_t *buf,
                                             uint64_t duration,
                                             uint8_t vcocap,
                                             uint8_t flags)
{
    buf[NIOS_PKT_RETUNERESP_IDX_MAGIC] = NIOS_PKT_RETUNE_MAGIC;
    5e90:	00801504 	movi	r2,84
    5e94:	80800405 	stb	r2,16(r16)

    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 0] =  duration        & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    5e98:	9804d23a 	srli	r2,r19,8
                                             uint8_t vcocap,
                                             uint8_t flags)
{
    buf[NIOS_PKT_RETUNERESP_IDX_MAGIC] = NIOS_PKT_RETUNE_MAGIC;

    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 0] =  duration        & 0xff;
    5e9c:	84c00445 	stb	r19,17(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 4] = (duration >> 32) & 0xff;
    5ea0:	80c00545 	stb	r3,21(r16)
                                             uint8_t flags)
{
    buf[NIOS_PKT_RETUNERESP_IDX_MAGIC] = NIOS_PKT_RETUNE_MAGIC;

    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 0] =  duration        & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    5ea4:	80800485 	stb	r2,18(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    5ea8:	9804d43a 	srli	r2,r19,16
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    5eac:	9826d63a 	srli	r19,r19,24
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 6] = (duration >> 48) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 7] = (duration >> 56) & 0xff;

    buf[NIOS_PKT_RETUNERESP_IDX_VCOCAP] = vcocap;

    buf[NIOS_PKT_RETUNERESP_IDX_FLAGS] = flags;
    5eb0:	85400685 	stb	r21,26(r16)
{
    buf[NIOS_PKT_RETUNERESP_IDX_MAGIC] = NIOS_PKT_RETUNE_MAGIC;

    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 0] =  duration        & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    5eb4:	808004c5 	stb	r2,19(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 4] = (duration >> 32) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 5] = (duration >> 40) & 0xff;
    5eb8:	1804d23a 	srli	r2,r3,8
    buf[NIOS_PKT_RETUNERESP_IDX_MAGIC] = NIOS_PKT_RETUNE_MAGIC;

    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 0] =  duration        & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    5ebc:	84c00505 	stb	r19,20(r16)

    buf[NIOS_PKT_RETUNERESP_IDX_VCOCAP] = vcocap;

    buf[NIOS_PKT_RETUNERESP_IDX_FLAGS] = flags;

    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 0] = 0x00;
    5ec0:	800006c5 	stb	zero,27(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 0] =  duration        & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 4] = (duration >> 32) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 5] = (duration >> 40) & 0xff;
    5ec4:	80800585 	stb	r2,22(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 6] = (duration >> 48) & 0xff;
    5ec8:	1804d43a 	srli	r2,r3,16
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 7] = (duration >> 56) & 0xff;
    5ecc:	1806d63a 	srli	r3,r3,24
    buf[NIOS_PKT_RETUNERESP_IDX_VCOCAP] = vcocap;

    buf[NIOS_PKT_RETUNERESP_IDX_FLAGS] = flags;

    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 0] = 0x00;
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 1] = 0x00;
    5ed0:	80000705 	stb	zero,28(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 4] = (duration >> 32) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 5] = (duration >> 40) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 6] = (duration >> 48) & 0xff;
    5ed4:	808005c5 	stb	r2,23(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 7] = (duration >> 56) & 0xff;

    buf[NIOS_PKT_RETUNERESP_IDX_VCOCAP] = vcocap;
    5ed8:	d8800243 	ldbu	r2,9(sp)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 4] = (duration >> 32) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 5] = (duration >> 40) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 6] = (duration >> 48) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 7] = (duration >> 56) & 0xff;
    5edc:	80c00605 	stb	r3,24(r16)

    buf[NIOS_PKT_RETUNERESP_IDX_FLAGS] = flags;

    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 0] = 0x00;
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 1] = 0x00;
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 2] = 0x00;
    5ee0:	80000745 	stb	zero,29(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 4] = (duration >> 32) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 5] = (duration >> 40) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 6] = (duration >> 48) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 7] = (duration >> 56) & 0xff;

    buf[NIOS_PKT_RETUNERESP_IDX_VCOCAP] = vcocap;
    5ee4:	80800645 	stb	r2,25(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_FLAGS] = flags;

    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 0] = 0x00;
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 1] = 0x00;
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 2] = 0x00;
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 3] = 0x00;
    5ee8:	80000785 	stb	zero,30(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 4] = 0x00;
    5eec:	800007c5 	stb	zero,31(r16)
    }

    nios_pkt_retune_resp_pack(b->resp, duration, f.vcocap_result, flags);
}
    5ef0:	dfc00c17 	ldw	ra,48(sp)
    5ef4:	df000b17 	ldw	fp,44(sp)
    5ef8:	ddc00a17 	ldw	r23,40(sp)
    5efc:	dd800917 	ldw	r22,36(sp)
    5f00:	dd400817 	ldw	r21,32(sp)
    5f04:	dd000717 	ldw	r20,28(sp)
    5f08:	dcc00617 	ldw	r19,24(sp)
    5f0c:	dc800517 	ldw	r18,20(sp)
    5f10:	dc400417 	ldw	r17,16(sp)
    5f14:	dc000317 	ldw	r16,12(sp)
    5f18:	dec00d04 	addi	sp,sp,52
    5f1c:	f800283a 	ret
    uint64_t end_time;
    uint64_t duration = 0;
    bool low_band;
    bool quick_tune;

    flags = NIOS_PKT_RETUNERESP_FLAG_SUCCESS;
    5f20:	05400084 	movi	r21,2
                queue_size = QUEUE_FULL;

        }

        if (queue_size == QUEUE_FULL) {
            status = -1;
    5f24:	0027883a 	mov	r19,zero
    5f28:	0007883a 	mov	r3,zero
    5f2c:	003fd606 	br	5e88 <pkt_retune+0x2f8>

00005f30 <band_select>:
#include <stdint.h>
#include "band_select.h"
#include "lms.h"

int band_select(struct bladerf *dev, bladerf_module module, bool low_band)
{
    5f30:	defffd04 	addi	sp,sp,-12
    int status;
    uint32_t gpio;
    const uint32_t band = low_band ? 2 : 1;
    5f34:	31803fcc 	andi	r6,r6,255
#include <stdint.h>
#include "band_select.h"
#include "lms.h"

int band_select(struct bladerf *dev, bladerf_module module, bool low_band)
{
    5f38:	dc400115 	stw	r17,4(sp)
    5f3c:	dc000015 	stw	r16,0(sp)
    5f40:	dfc00215 	stw	ra,8(sp)
    5f44:	2823883a 	mov	r17,r5
    int status;
    uint32_t gpio;
    const uint32_t band = low_band ? 2 : 1;
    5f48:	3020c03a 	cmpne	r16,r6,zero

    log_debug("Selecting %s band.\n", low_band ? "low" : "high");

    status = lms_select_band(dev, module, low_band);
    5f4c:	00064080 	call	6408 <lms_select_band>
    if (status != 0) {
    5f50:	1000101e 	bne	r2,zero,5f94 <band_select+0x64>
    5f54:	84000044 	addi	r16,r16,1
#include <stdbool.h>


static inline uint32_t control_reg_read(void)
{
    return IORD_ALTERA_AVALON_PIO_DATA(CONTROL_BASE);
    5f58:	00e41014 	movui	r3,36928
    5f5c:	18800037 	ldwio	r2,0(r3)
    status = CONFIG_GPIO_READ(dev, &gpio);
    if (status != 0) {
        return status;
    }

    gpio &= ~(module == BLADERF_MODULE_TX ? (3 << 3) : (3 << 5));
    5f60:	01000044 	movi	r4,1
    5f64:	89000226 	beq	r17,r4,5f70 <band_select+0x40>
    5f68:	017fe7c4 	movi	r5,-97
    5f6c:	00000106 	br	5f74 <band_select+0x44>
    5f70:	017ff9c4 	movi	r5,-25
    5f74:	2884703a 	and	r2,r5,r2
    gpio |= (module == BLADERF_MODULE_TX ? (band << 3) : (band << 5));
    5f78:	8900021e 	bne	r17,r4,5f84 <band_select+0x54>
    5f7c:	802090fa 	slli	r16,r16,3
    5f80:	00000106 	br	5f88 <band_select+0x58>
    5f84:	8020917a 	slli	r16,r16,5
}

static inline void control_reg_write(uint32_t value)
{
    IOWR_ALTERA_AVALON_PIO_DATA(CONTROL_BASE, value);
    5f88:	80a0b03a 	or	r16,r16,r2
    5f8c:	1c000035 	stwio	r16,0(r3)

    return CONFIG_GPIO_WRITE(dev, gpio);
    5f90:	0005883a 	mov	r2,zero
}
    5f94:	dfc00217 	ldw	ra,8(sp)
    5f98:	dc400117 	ldw	r17,4(sp)
    5f9c:	dc000017 	ldw	r16,0(sp)
    5fa0:	dec00304 	addi	sp,sp,12
    5fa4:	f800283a 	ret

00005fa8 <vtune_low_to_norm>:
}

static int vtune_low_to_norm(struct bladerf *dev, uint8_t base,
                                    uint8_t vcocap, uint8_t vcocap_reg_state,
                                    uint8_t *vtune_low_limit)
{
    5fa8:	defff804 	addi	sp,sp,-32
    5fac:	dcc00315 	stw	r19,12(sp)
    5fb0:	dcc00817 	ldw	r19,32(sp)
    5fb4:	dd400515 	stw	r21,20(sp)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    5fb8:	2d400244 	addi	r21,r5,9

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    5fbc:	29400284 	addi	r5,r5,10
}

static int vtune_low_to_norm(struct bladerf *dev, uint8_t base,
                                    uint8_t vcocap, uint8_t vcocap_reg_state,
                                    uint8_t *vtune_low_limit)
{
    5fc0:	dd800615 	stw	r22,24(sp)
    5fc4:	dc800215 	stw	r18,8(sp)
    5fc8:	dc400115 	stw	r17,4(sp)
    5fcc:	dc000015 	stw	r16,0(sp)
    5fd0:	dfc00715 	stw	ra,28(sp)
    5fd4:	dd000415 	stw	r20,16(sp)
    5fd8:	3023883a 	mov	r17,r6
    5fdc:	382d883a 	mov	r22,r7
    5fe0:	343ffb04 	addi	r16,r6,-20
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    5fe4:	ad403fcc 	andi	r21,r21,255

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    5fe8:	2c803fcc 	andi	r18,r5,255
    unsigned int i;
    uint8_t vtune = 0xff;

    for (i = 0; i < VTUNE_MAX_ITERATIONS; i++) {

        if (vcocap == 0) {
    5fec:	88803fcc 	andi	r2,r17,255
    5ff0:	1000021e 	bne	r2,zero,5ffc <vtune_low_to_norm+0x54>
            *vtune_low_limit = 0;
    5ff4:	98000005 	stb	zero,0(r19)
            log_warning("VCOCAP hit min value.\n");
            return 0;
    5ff8:	00001406 	br	604c <vtune_low_to_norm+0xa4>
        }

        vcocap--;
    5ffc:	8d3fffc4 	addi	r20,r17,-1
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6000:	a58ab03a 	or	r5,r20,r22
    6004:	29403fcc 	andi	r5,r5,255
    6008:	a809883a 	mov	r4,r21
    600c:	00048380 	call	4838 <lms6_write>
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    6010:	01000644 	movi	r4,25
    6014:	0006d780 	call	6d78 <usleep>
    }

    status = LMS_READ(dev, base + 10, vtune);
    6018:	9009883a 	mov	r4,r18
    601c:	00048240 	call	4824 <lms6_read>
        status = get_vtune(dev, base, VTUNE_DELAY_SMALL, &vtune);
        if (status != 0) {
            return status;
        }

        if (vtune == VCO_NORM) {
    6020:	10803fcc 	andi	r2,r2,255
    6024:	1004d1ba 	srli	r2,r2,6
    6028:	1000021e 	bne	r2,zero,6034 <vtune_low_to_norm+0x8c>
            *vtune_low_limit = vcocap + 1;
    602c:	9c400005 	stb	r17,0(r19)
            log_verbose("VTUNE NORM @ VCOCAP=%u\n", vcocap);
            log_verbose("VTUNE LOW @ VCOCAP=%u\n", *vtune_low_limit);
            return 0;
    6030:	00000606 	br	604c <vtune_low_to_norm+0xa4>
{
    int status;
    unsigned int i;
    uint8_t vtune = 0xff;

    for (i = 0; i < VTUNE_MAX_ITERATIONS; i++) {
    6034:	a0803fcc 	andi	r2,r20,255
    6038:	80c03fcc 	andi	r3,r16,255
    603c:	10c00226 	beq	r2,r3,6048 <vtune_low_to_norm+0xa0>
    6040:	a023883a 	mov	r17,r20
    6044:	003fe906 	br	5fec <vtune_low_to_norm+0x44>
            return 0;
        }
    }

    log_error("VTUNE Low->Norm loop failed to converge.\n");
    return BLADERF_ERR_UNEXPECTED;
    6048:	00bfffc4 	movi	r2,-1
}
    604c:	dfc00717 	ldw	ra,28(sp)
    6050:	dd800617 	ldw	r22,24(sp)
    6054:	dd400517 	ldw	r21,20(sp)
    6058:	dd000417 	ldw	r20,16(sp)
    605c:	dcc00317 	ldw	r19,12(sp)
    6060:	dc800217 	ldw	r18,8(sp)
    6064:	dc400117 	ldw	r17,4(sp)
    6068:	dc000017 	ldw	r16,0(sp)
    606c:	dec00804 	addi	sp,sp,32
    6070:	f800283a 	ret

00006074 <vtune_high_to_norm>:
#endif

static int vtune_high_to_norm(struct bladerf *dev, uint8_t base,
                                     uint8_t vcocap, uint8_t vcocap_reg_state,
                                     uint8_t *vtune_high_limit)
{
    6074:	defff804 	addi	sp,sp,-32
    6078:	dcc00315 	stw	r19,12(sp)
    607c:	dcc00817 	ldw	r19,32(sp)
    6080:	dd400515 	stw	r21,20(sp)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6084:	2d400244 	addi	r21,r5,9

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    6088:	29400284 	addi	r5,r5,10
#endif

static int vtune_high_to_norm(struct bladerf *dev, uint8_t base,
                                     uint8_t vcocap, uint8_t vcocap_reg_state,
                                     uint8_t *vtune_high_limit)
{
    608c:	dd800615 	stw	r22,24(sp)
    6090:	dc800215 	stw	r18,8(sp)
    6094:	dc400115 	stw	r17,4(sp)
    6098:	dc000015 	stw	r16,0(sp)
    609c:	dfc00715 	stw	ra,28(sp)
    60a0:	dd000415 	stw	r20,16(sp)
    60a4:	3023883a 	mov	r17,r6
    60a8:	382d883a 	mov	r22,r7
    60ac:	34000504 	addi	r16,r6,20
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    60b0:	ad403fcc 	andi	r21,r21,255

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    60b4:	2c803fcc 	andi	r18,r5,255
    unsigned int i;
    uint8_t vtune = 0xff;

    for (i = 0; i < VTUNE_MAX_ITERATIONS; i++) {

        if (vcocap >= VCOCAP_MAX_VALUE) {
    60b8:	88803fcc 	andi	r2,r17,255
    60bc:	00c00f84 	movi	r3,62
    60c0:	1880042e 	bgeu	r3,r2,60d4 <vtune_high_to_norm+0x60>
            *vtune_high_limit = VCOCAP_MAX_VALUE;
    60c4:	00800fc4 	movi	r2,63
    60c8:	98800005 	stb	r2,0(r19)
            log_warning("%s: VCOCAP hit max value.\n", __FUNCTION__);
            return 0;
    60cc:	0005883a 	mov	r2,zero
    60d0:	00001406 	br	6124 <vtune_high_to_norm+0xb0>
        }

        vcocap++;
    60d4:	8d000044 	addi	r20,r17,1
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    60d8:	a58ab03a 	or	r5,r20,r22
    60dc:	29403fcc 	andi	r5,r5,255
    60e0:	a809883a 	mov	r4,r21
    60e4:	00048380 	call	4838 <lms6_write>
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    60e8:	01000644 	movi	r4,25
    60ec:	0006d780 	call	6d78 <usleep>
    }

    status = LMS_READ(dev, base + 10, vtune);
    60f0:	9009883a 	mov	r4,r18
    60f4:	00048240 	call	4824 <lms6_read>
        status = get_vtune(dev, base, VTUNE_DELAY_SMALL, &vtune);
        if (status != 0) {
            return status;
        }

        if (vtune == VCO_NORM) {
    60f8:	10803fcc 	andi	r2,r2,255
    60fc:	1004d1ba 	srli	r2,r2,6
    6100:	1000021e 	bne	r2,zero,610c <vtune_high_to_norm+0x98>
            *vtune_high_limit = vcocap - 1;
    6104:	9c400005 	stb	r17,0(r19)
            log_verbose("VTUNE NORM @ VCOCAP=%u\n", vcocap);
            log_verbose("VTUNE HIGH @ VCOCAP=%u\n", *vtune_high_limit);
            return 0;
    6108:	00000606 	br	6124 <vtune_high_to_norm+0xb0>
{
    int status;
    unsigned int i;
    uint8_t vtune = 0xff;

    for (i = 0; i < VTUNE_MAX_ITERATIONS; i++) {
    610c:	a0803fcc 	andi	r2,r20,255
    6110:	80c03fcc 	andi	r3,r16,255
    6114:	10c00226 	beq	r2,r3,6120 <vtune_high_to_norm+0xac>
    6118:	a023883a 	mov	r17,r20
    611c:	003fe606 	br	60b8 <vtune_high_to_norm+0x44>
            return 0;
        }
    }

    log_error("VTUNE High->Norm loop failed to converge.\n");
    return BLADERF_ERR_UNEXPECTED;
    6120:	00bfffc4 	movi	r2,-1
}
    6124:	dfc00717 	ldw	ra,28(sp)
    6128:	dd800617 	ldw	r22,24(sp)
    612c:	dd400517 	ldw	r21,20(sp)
    6130:	dd000417 	ldw	r20,16(sp)
    6134:	dcc00317 	ldw	r19,12(sp)
    6138:	dc800217 	ldw	r18,8(sp)
    613c:	dc400117 	ldw	r17,4(sp)
    6140:	dc000017 	ldw	r16,0(sp)
    6144:	dec00804 	addi	sp,sp,32
    6148:	f800283a 	ret

0000614c <wait_for_vtune_value>:

/* Wait for VTUNE to reach HIGH or LOW. NORM is not a valid option here */
static int wait_for_vtune_value(struct bladerf *dev,
                                uint8_t base, uint8_t target_value,
                                uint8_t *vcocap, uint8_t vcocap_reg_state)
{
    614c:	defff704 	addi	sp,sp,-36
    6150:	dd400515 	stw	r21,20(sp)
    6154:	dcc00315 	stw	r19,12(sp)
    6158:	dc800215 	stw	r18,8(sp)
    615c:	dc000015 	stw	r16,0(sp)
    6160:	3025883a 	mov	r18,r6
    6164:	dfc00815 	stw	ra,32(sp)
    6168:	ddc00715 	stw	r23,28(sp)
    616c:	dd800615 	stw	r22,24(sp)
    6170:	dd000415 	stw	r20,16(sp)
    6174:	dc400115 	stw	r17,4(sp)
    uint8_t vtune;
    unsigned int i;
    int status = 0;
    const unsigned int max_retries = 15;
    const uint8_t limit = (target_value == VCO_HIGH) ? 0 : VCOCAP_MAX_VALUE;
    6178:	31803fcc 	andi	r6,r6,255
    617c:	00800084 	movi	r2,2

/* Wait for VTUNE to reach HIGH or LOW. NORM is not a valid option here */
static int wait_for_vtune_value(struct bladerf *dev,
                                uint8_t base, uint8_t target_value,
                                uint8_t *vcocap, uint8_t vcocap_reg_state)
{
    6180:	3827883a 	mov	r19,r7
    6184:	2821883a 	mov	r16,r5
    6188:	dd400903 	ldbu	r21,36(sp)
    uint8_t vtune;
    unsigned int i;
    int status = 0;
    const unsigned int max_retries = 15;
    const uint8_t limit = (target_value == VCO_HIGH) ? 0 : VCOCAP_MAX_VALUE;
    618c:	3080031e 	bne	r6,r2,619c <wait_for_vtune_value+0x50>
    6190:	002d883a 	mov	r22,zero
    int8_t inc = (target_value == VCO_HIGH) ? -1 : 1;
    6194:	053fffc4 	movi	r20,-1
    6198:	00000206 	br	61a4 <wait_for_vtune_value+0x58>
{
    uint8_t vtune;
    unsigned int i;
    int status = 0;
    const unsigned int max_retries = 15;
    const uint8_t limit = (target_value == VCO_HIGH) ? 0 : VCOCAP_MAX_VALUE;
    619c:	05800fc4 	movi	r22,63
    int8_t inc = (target_value == VCO_HIGH) ? -1 : 1;
    61a0:	05000044 	movi	r20,1

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    61a4:	84400284 	addi	r17,r16,10
    uint8_t vtune;
    unsigned int i;
    int status = 0;
    const unsigned int max_retries = 15;
    const uint8_t limit = (target_value == VCO_HIGH) ? 0 : VCOCAP_MAX_VALUE;
    int8_t inc = (target_value == VCO_HIGH) ? -1 : 1;
    61a8:	05c003c4 	movi	r23,15

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    61ac:	8c403fcc 	andi	r17,r17,255
        status = get_vtune(dev, base, 0, &vtune);
        if (status != 0) {
            return status;
        }

        if (vtune == target_value) {
    61b0:	94803fcc 	andi	r18,r18,255

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    61b4:	8809883a 	mov	r4,r17
    61b8:	00048240 	call	4824 <lms6_read>
        status = get_vtune(dev, base, 0, &vtune);
        if (status != 0) {
            return status;
        }

        if (vtune == target_value) {
    61bc:	10803fcc 	andi	r2,r2,255
    61c0:	1004d1ba 	srli	r2,r2,6
    61c4:	90801726 	beq	r18,r2,6224 <wait_for_vtune_value+0xd8>
            return 0;
        } else {
            log_verbose("VTUNE was %s. Waiting and retrying...\n",
                        vtune_str(vtune));

            VTUNE_BUSY_WAIT(10);
    61c8:	01000284 	movi	r4,10
    61cc:	bdffffc4 	addi	r23,r23,-1
    61d0:	0006d780 	call	6d78 <usleep>
    const uint8_t limit = (target_value == VCO_HIGH) ? 0 : VCOCAP_MAX_VALUE;
    int8_t inc = (target_value == VCO_HIGH) ? -1 : 1;

    assert(target_value == VCO_HIGH || target_value == VCO_LOW);

    for (i = 0; i < max_retries; i++) {
    61d4:	b83ff71e 	bne	r23,zero,61b4 <wait_for_vtune_value+0x68>
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    61d8:	84000244 	addi	r16,r16,9
    }

    log_debug("Timed out while waiting for VTUNE=%s. Walking VCOCAP...\n",
               vtune_str(target_value));

    while (*vcocap != limit) {
    61dc:	b5803fcc 	andi	r22,r22,255
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    61e0:	84003fcc 	andi	r16,r16,255
    }

    log_debug("Timed out while waiting for VTUNE=%s. Walking VCOCAP...\n",
               vtune_str(target_value));

    while (*vcocap != limit) {
    61e4:	99400003 	ldbu	r5,0(r19)
    61e8:	28803fcc 	andi	r2,r5,255
    61ec:	15800d26 	beq	r2,r22,6224 <wait_for_vtune_value+0xd8>
        *vcocap += inc;
    61f0:	a14b883a 	add	r5,r20,r5
    61f4:	99400005 	stb	r5,0(r19)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    61f8:	2d4ab03a 	or	r5,r5,r21
    61fc:	29403fcc 	andi	r5,r5,255
    6200:	8009883a 	mov	r4,r16
    6204:	00048380 	call	4838 <lms6_write>
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    6208:	01000644 	movi	r4,25
    620c:	0006d780 	call	6d78 <usleep>
    }

    status = LMS_READ(dev, base + 10, vtune);
    6210:	8809883a 	mov	r4,r17
    6214:	00048240 	call	4824 <lms6_read>
        }

        status = get_vtune(dev, base, VTUNE_DELAY_SMALL, &vtune);
        if (status != 0) {
            return status;
        } else if (vtune == target_value) {
    6218:	10803fcc 	andi	r2,r2,255
    621c:	1004d1ba 	srli	r2,r2,6
    6220:	90bff01e 	bne	r18,r2,61e4 <wait_for_vtune_value+0x98>
#   ifdef ERROR_ON_NO_VTUNE_LIMIT
        return BLADERF_ERR_UNEXPECTED;
#   else
        return 0;
#   endif
}
    6224:	0005883a 	mov	r2,zero
    6228:	dfc00817 	ldw	ra,32(sp)
    622c:	ddc00717 	ldw	r23,28(sp)
    6230:	dd800617 	ldw	r22,24(sp)
    6234:	dd400517 	ldw	r21,20(sp)
    6238:	dd000417 	ldw	r20,16(sp)
    623c:	dcc00317 	ldw	r19,12(sp)
    6240:	dc800217 	ldw	r18,8(sp)
    6244:	dc400117 	ldw	r17,4(sp)
    6248:	dc000017 	ldw	r16,0(sp)
    624c:	dec00904 	addi	sp,sp,36
    6250:	f800283a 	ret

00006254 <lms_select_lna>:
}
#endif

/* Select which LNA to enable */
int lms_select_lna(struct bladerf *dev, lms_lna lna)
{
    6254:	defffd04 	addi	sp,sp,-12
    6258:	dc400115 	stw	r17,4(sp)
    int status;
    uint8_t data;

    status = LMS_READ(dev, 0x75, &data);
    625c:	04401d44 	movi	r17,117
}
#endif

/* Select which LNA to enable */
int lms_select_lna(struct bladerf *dev, lms_lna lna)
{
    6260:	dc000015 	stw	r16,0(sp)
    int status;
    uint8_t data;

    status = LMS_READ(dev, 0x75, &data);
    6264:	8809883a 	mov	r4,r17
}
#endif

/* Select which LNA to enable */
int lms_select_lna(struct bladerf *dev, lms_lna lna)
{
    6268:	2821883a 	mov	r16,r5
    626c:	dfc00215 	stw	ra,8(sp)
    }

    data &= ~(3 << 4);
    data |= ((lna & 3) << 4);

    return LMS_WRITE(dev, 0x75, data);
    6270:	840000cc 	andi	r16,r16,3
int lms_select_lna(struct bladerf *dev, lms_lna lna)
{
    int status;
    uint8_t data;

    status = LMS_READ(dev, 0x75, &data);
    6274:	00048240 	call	4824 <lms6_read>
    }

    data &= ~(3 << 4);
    data |= ((lna & 3) << 4);

    return LMS_WRITE(dev, 0x75, data);
    6278:	800a913a 	slli	r5,r16,4
    627c:	108033cc 	andi	r2,r2,207
    6280:	8809883a 	mov	r4,r17
    6284:	114ab03a 	or	r5,r2,r5
    6288:	00048380 	call	4838 <lms6_write>
}
    628c:	0005883a 	mov	r2,zero
    6290:	dfc00217 	ldw	ra,8(sp)
    6294:	dc400117 	ldw	r17,4(sp)
    6298:	dc000017 	ldw	r16,0(sp)
    629c:	dec00304 	addi	sp,sp,12
    62a0:	f800283a 	ret

000062a4 <lms_select_pa>:
    return status;
}
#endif

int lms_select_pa(struct bladerf *dev, lms_pa pa)
{
    62a4:	defffe04 	addi	sp,sp,-8
    int status;
    uint8_t data;

    status = LMS_READ(dev, 0x44, &data);
    62a8:	01001104 	movi	r4,68
    return status;
}
#endif

int lms_select_pa(struct bladerf *dev, lms_pa pa)
{
    62ac:	dc000015 	stw	r16,0(sp)
    62b0:	dfc00115 	stw	ra,4(sp)
    62b4:	2821883a 	mov	r16,r5
    int status;
    uint8_t data;

    status = LMS_READ(dev, 0x44, &data);
    62b8:	00048240 	call	4824 <lms6_read>

    /* Disable PA1, PA2, and AUX PA - we'll enable as requested below. */
    data &= ~0x1C;
    62bc:	00fff8c4 	movi	r3,-29

    /* AUX PA powered down */
    data |= (1 << 1);

    switch (pa) {
    62c0:	01000044 	movi	r4,1
    uint8_t data;

    status = LMS_READ(dev, 0x44, &data);

    /* Disable PA1, PA2, and AUX PA - we'll enable as requested below. */
    data &= ~0x1C;
    62c4:	10c6703a 	and	r3,r2,r3

    /* AUX PA powered down */
    data |= (1 << 1);

    switch (pa) {
    62c8:	81000a26 	beq	r16,r4,62f4 <lms_select_pa+0x50>
    62cc:	80000626 	beq	r16,zero,62e8 <lms_select_pa+0x44>
    62d0:	00800084 	movi	r2,2
    62d4:	80800926 	beq	r16,r2,62fc <lms_select_pa+0x58>
    62d8:	008000c4 	movi	r2,3
    62dc:	80800926 	beq	r16,r2,6304 <lms_select_pa+0x60>
        case PA_NONE:
            break;

        default:
            assert(!"Invalid PA selection");
            status = BLADERF_ERR_INVAL;
    62e0:	00bfff44 	movi	r2,-3
    62e4:	00000c06 	br	6318 <lms_select_pa+0x74>
    62e8:	00fff844 	movi	r3,-31
    62ec:	188a703a 	and	r5,r3,r2
    data |= (1 << 1);

    switch (pa) {
        case PA_AUX:
            data &= ~(1 << 1);  /* Power up the AUX PA */
            break;
    62f0:	00000506 	br	6308 <lms_select_pa+0x64>

        case PA_1:
            data |= (2 << 2);   /* PA_EN[2:0] = 010 - Enable PA1 */
    62f4:	19400294 	ori	r5,r3,10
            break;
    62f8:	00000306 	br	6308 <lms_select_pa+0x64>

        case PA_2:
            data |= (4 << 2);   /* PA_EN[2:0] = 100 - Enable PA2 */
    62fc:	19400494 	ori	r5,r3,18
            break;
    6300:	00000106 	br	6308 <lms_select_pa+0x64>

    /* Disable PA1, PA2, and AUX PA - we'll enable as requested below. */
    data &= ~0x1C;

    /* AUX PA powered down */
    data |= (1 << 1);
    6304:	19400094 	ori	r5,r3,2
            assert(!"Invalid PA selection");
            status = BLADERF_ERR_INVAL;
    }

    if (status == 0) {
        status = LMS_WRITE(dev, 0x44, data);
    6308:	29403fcc 	andi	r5,r5,255
    630c:	01001104 	movi	r4,68
    6310:	00048380 	call	4838 <lms6_write>
    6314:	0005883a 	mov	r2,zero
    }

    return status;

};
    6318:	dfc00117 	ldw	ra,4(sp)
    631c:	dc000017 	ldw	r16,0(sp)
    6320:	dec00204 	addi	sp,sp,8
    6324:	f800283a 	ret

00006328 <lms_get_loopback_mode>:
    return 0;
}
#endif

int lms_get_loopback_mode(struct bladerf *dev, bladerf_loopback *loopback)
{
    6328:	defffc04 	addi	sp,sp,-16
    632c:	dc800215 	stw	r18,8(sp)
    int status;
    uint8_t lben_lbrfen, loopbben;


    status = LMS_READ(dev, 0x08, &lben_lbrfen);
    6330:	04800204 	movi	r18,8
    6334:	9009883a 	mov	r4,r18
    return 0;
}
#endif

int lms_get_loopback_mode(struct bladerf *dev, bladerf_loopback *loopback)
{
    6338:	dfc00315 	stw	ra,12(sp)
    633c:	dc400115 	stw	r17,4(sp)
    6340:	dc000015 	stw	r16,0(sp)
    6344:	2821883a 	mov	r16,r5
    int status;
    uint8_t lben_lbrfen, loopbben;


    status = LMS_READ(dev, 0x08, &lben_lbrfen);
    6348:	00048240 	call	4824 <lms6_read>
    if (status != 0) {
        return status;
    }

    status = LMS_READ(dev, 0x46, &loopbben);
    634c:	01001184 	movi	r4,70
{
    int status;
    uint8_t lben_lbrfen, loopbben;


    status = LMS_READ(dev, 0x08, &lben_lbrfen);
    6350:	1023883a 	mov	r17,r2
    if (status != 0) {
        return status;
    }

    status = LMS_READ(dev, 0x46, &loopbben);
    6354:	00048240 	call	4824 <lms6_read>
    if (status != 0) {
        return status;
    }

    switch (lben_lbrfen & 0x7) {
    6358:	88c001cc 	andi	r3,r17,7
    635c:	01400084 	movi	r5,2
    6360:	19400626 	beq	r3,r5,637c <lms_get_loopback_mode+0x54>
    6364:	010000c4 	movi	r4,3
    6368:	19000626 	beq	r3,r4,6384 <lms_get_loopback_mode+0x5c>
    636c:	01800044 	movi	r6,1
    6370:	1980061e 	bne	r3,r6,638c <lms_get_loopback_mode+0x64>
        case LBRFEN_LNA1:
            *loopback = BLADERF_LB_RF_LNA1;
    6374:	00800184 	movi	r2,6
    6378:	00001b06 	br	63e8 <lms_get_loopback_mode+0xc0>
            return 0;

        case LBRFEN_LNA2:
            *loopback = BLADERF_LB_RF_LNA2;
    637c:	008001c4 	movi	r2,7
    6380:	00001906 	br	63e8 <lms_get_loopback_mode+0xc0>
            return 0;

        case LBRFEN_LNA3:
            *loopback = BLADERF_LB_RF_LNA3;
    6384:	84800015 	stw	r18,0(r16)
            return 0;
    6388:	00001806 	br	63ec <lms_get_loopback_mode+0xc4>

        default:
            break;
    }

    switch (lben_lbrfen & LBEN_MASK) {
    638c:	8c401c0c 	andi	r17,r17,112
    6390:	00c00804 	movi	r3,32
    6394:	88c00326 	beq	r17,r3,63a4 <lms_get_loopback_mode+0x7c>
    6398:	00c01004 	movi	r3,64
    639c:	88c00926 	beq	r17,r3,63c4 <lms_get_loopback_mode+0x9c>
    63a0:	00001006 	br	63e4 <lms_get_loopback_mode+0xbc>
        case LBEN_VGA2IN:
            if (loopbben & LOOPBBEN_TXLPF) {
    63a4:	10c0010c 	andi	r3,r2,4
    63a8:	18000226 	beq	r3,zero,63b4 <lms_get_loopback_mode+0x8c>
                *loopback = BLADERF_LB_BB_TXLPF_RXVGA2;
    63ac:	81400015 	stw	r5,0(r16)
                return 0;
    63b0:	00000e06 	br	63ec <lms_get_loopback_mode+0xc4>
            } else if (loopbben & LOOPBBEN_TXVGA) {
    63b4:	1080020c 	andi	r2,r2,8
    63b8:	10000a26 	beq	r2,zero,63e4 <lms_get_loopback_mode+0xbc>
                *loopback = BLADERF_LB_BB_TXVGA1_RXVGA2;
    63bc:	81000015 	stw	r4,0(r16)
                return 0;
    63c0:	00000a06 	br	63ec <lms_get_loopback_mode+0xc4>
            }
            break;

        case LBEN_LPFIN:
            if (loopbben & LOOPBBEN_TXLPF) {
    63c4:	10c0010c 	andi	r3,r2,4
    63c8:	18000226 	beq	r3,zero,63d4 <lms_get_loopback_mode+0xac>
                *loopback = BLADERF_LB_BB_TXLPF_RXLPF;
    63cc:	00800104 	movi	r2,4
    63d0:	00000506 	br	63e8 <lms_get_loopback_mode+0xc0>
                return 0;
            } else if (loopbben & LOOPBBEN_TXVGA) {
    63d4:	1080020c 	andi	r2,r2,8
    63d8:	10000226 	beq	r2,zero,63e4 <lms_get_loopback_mode+0xbc>
                *loopback = BLADERF_LB_BB_TXVGA1_RXLPF;
    63dc:	00800144 	movi	r2,5
    63e0:	00000106 	br	63e8 <lms_get_loopback_mode+0xc0>

        default:
            break;
    }

    *loopback = BLADERF_LB_NONE;
    63e4:	00800244 	movi	r2,9
    63e8:	80800015 	stw	r2,0(r16)
    return 0;
}
    63ec:	0005883a 	mov	r2,zero
    63f0:	dfc00317 	ldw	ra,12(sp)
    63f4:	dc800217 	ldw	r18,8(sp)
    63f8:	dc400117 	ldw	r17,4(sp)
    63fc:	dc000017 	ldw	r16,0(sp)
    6400:	dec00404 	addi	sp,sp,16
    6404:	f800283a 	ret

00006408 <lms_select_band>:

    return status;
}

int lms_select_band(struct bladerf *dev, bladerf_module module, bool low_band)
{
    6408:	defffb04 	addi	sp,sp,-20
    640c:	dc400215 	stw	r17,8(sp)
    6410:	2823883a 	mov	r17,r5
static inline int is_loopback_enabled(struct bladerf *dev)
{
    bladerf_loopback loopback;
    int status;

    status = lms_get_loopback_mode(dev, &loopback);
    6414:	d80b883a 	mov	r5,sp

    return status;
}

int lms_select_band(struct bladerf *dev, bladerf_module module, bool low_band)
{
    6418:	dc800315 	stw	r18,12(sp)
    641c:	dc000115 	stw	r16,4(sp)
    6420:	dfc00415 	stw	ra,16(sp)
    6424:	2025883a 	mov	r18,r4
    6428:	3021883a 	mov	r16,r6
static inline int is_loopback_enabled(struct bladerf *dev)
{
    bladerf_loopback loopback;
    int status;

    status = lms_get_loopback_mode(dev, &loopback);
    642c:	00063280 	call	6328 <lms_get_loopback_mode>
    if (status != 0) {
    6430:	1000021e 	bne	r2,zero,643c <lms_select_band+0x34>
        return status;
    }

    return loopback != BLADERF_LB_NONE;
    6434:	d8800017 	ldw	r2,0(sp)
    6438:	10800258 	cmpnei	r2,r2,9
    int status;

    /* If loopback mode disabled, avoid changing the PA or LNA selection,
     * as these need to remain are powered down or disabled */
    status = is_loopback_enabled(dev);
    if (status < 0) {
    643c:	10001216 	blt	r2,zero,6488 <lms_select_band+0x80>
        return status;
    } else if (status > 0) {
    6440:	1000101e 	bne	r2,zero,6484 <lms_select_band+0x7c>
        return 0;
    }

    if (module == BLADERF_MODULE_TX) {
    6444:	00800044 	movi	r2,1
    6448:	81803fcc 	andi	r6,r16,255
    644c:	8880071e 	bne	r17,r2,646c <lms_select_band+0x64>
        lms_pa pa = low_band ? PA_1 : PA_2;
    6450:	3000021e 	bne	r6,zero,645c <lms_select_band+0x54>
    6454:	01400084 	movi	r5,2
    6458:	00000106 	br	6460 <lms_select_band+0x58>
    645c:	880b883a 	mov	r5,r17
        status = lms_select_pa(dev, pa);
    6460:	9009883a 	mov	r4,r18
    6464:	00062a40 	call	62a4 <lms_select_pa>
    6468:	00000706 	br	6488 <lms_select_band+0x80>
    } else {
        lms_lna lna = low_band ? LNA_1 : LNA_2;
    646c:	300cc03a 	cmpne	r6,r6,zero
        status = lms_select_lna(dev, lna);
    6470:	01400084 	movi	r5,2
    6474:	298bc83a 	sub	r5,r5,r6
    6478:	9009883a 	mov	r4,r18
    647c:	00062540 	call	6254 <lms_select_lna>
    6480:	00000106 	br	6488 <lms_select_band+0x80>
     * as these need to remain are powered down or disabled */
    status = is_loopback_enabled(dev);
    if (status < 0) {
        return status;
    } else if (status > 0) {
        return 0;
    6484:	0005883a 	mov	r2,zero
        lms_lna lna = low_band ? LNA_1 : LNA_2;
        status = lms_select_lna(dev, lna);
    }

    return status;
}
    6488:	dfc00417 	ldw	ra,16(sp)
    648c:	dc800317 	ldw	r18,12(sp)
    6490:	dc400217 	ldw	r17,8(sp)
    6494:	dc000117 	ldw	r16,4(sp)
    6498:	dec00504 	addi	sp,sp,20
    649c:	f800283a 	ret

000064a0 <lms_set_precalculated_frequency>:
}
#endif

int lms_set_precalculated_frequency(struct bladerf *dev, bladerf_module mod,
                                    struct lms_freq *f)
{
    64a0:	defff004 	addi	sp,sp,-64
    64a4:	dd800c15 	stw	r22,48(sp)
    64a8:	dc400715 	stw	r17,28(sp)
    64ac:	dc000615 	stw	r16,24(sp)
    64b0:	dfc00f15 	stw	ra,60(sp)
    64b4:	df000e15 	stw	fp,56(sp)
    64b8:	ddc00d15 	stw	r23,52(sp)
    64bc:	dd400b15 	stw	r21,44(sp)
    64c0:	dd000a15 	stw	r20,40(sp)
    64c4:	dcc00915 	stw	r19,36(sp)
    64c8:	dc800815 	stw	r18,32(sp)
    64cc:	202d883a 	mov	r22,r4
    64d0:	2821883a 	mov	r16,r5
    64d4:	3023883a 	mov	r17,r6
    /* Select the base address based on which PLL we are configuring */
    const uint8_t base = (mod == BLADERF_MODULE_RX) ? 0x20 : 0x10;
    64d8:	28000226 	beq	r5,zero,64e4 <lms_set_precalculated_frequency+0x44>
    64dc:	04800404 	movi	r18,16
    64e0:	00000106 	br	64e8 <lms_set_precalculated_frequency+0x48>
    64e4:	04800804 	movi	r18,32
    const uint8_t pll_base =
        have_cap(dev, BLADERF_CAP_ATOMIC_NINT_NFRAC_WRITE) ?
            (base | 0x80) : base;
#   endif

    f->vcocap_result = 0xff;
    64e8:	00bfffc4 	movi	r2,-1

    /* Turn on the DSMs */
    status = LMS_READ(dev, 0x09, &data);
    64ec:	01000244 	movi	r4,9
    const uint8_t pll_base =
        have_cap(dev, BLADERF_CAP_ATOMIC_NINT_NFRAC_WRITE) ?
            (base | 0x80) : base;
#   endif

    f->vcocap_result = 0xff;
    64f0:	88800245 	stb	r2,9(r17)

    /* Turn on the DSMs */
    status = LMS_READ(dev, 0x09, &data);
    64f4:	00048240 	call	4824 <lms6_read>
    if (status == 0) {
        data |= 0x05;
        status = LMS_WRITE(dev, 0x09, data);
    64f8:	10800154 	ori	r2,r2,5
    64fc:	11403fcc 	andi	r5,r2,255
    6500:	01000244 	movi	r4,9
    }

    /* Write the initial vcocap estimate first to allow for adequate time for
     * VTUNE to stabilize. We need to be sure to keep the upper bits of
     * this register and perform a RMW, as bit 7 is VOVCOREG[0]. */
    status = LMS_READ(dev, base + 9, &vcocap_reg_state);
    6504:	95000244 	addi	r20,r18,9

    /* Turn on the DSMs */
    status = LMS_READ(dev, 0x09, &data);
    if (status == 0) {
        data |= 0x05;
        status = LMS_WRITE(dev, 0x09, data);
    6508:	00048380 	call	4838 <lms6_write>
    }

    /* Write the initial vcocap estimate first to allow for adequate time for
     * VTUNE to stabilize. We need to be sure to keep the upper bits of
     * this register and perform a RMW, as bit 7 is VOVCOREG[0]. */
    status = LMS_READ(dev, base + 9, &vcocap_reg_state);
    650c:	a5003fcc 	andi	r20,r20,255
    6510:	a009883a 	mov	r4,r20
    6514:	00048240 	call	4824 <lms6_read>
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6518:	89400043 	ldbu	r5,1(r17)
    status = LMS_READ(dev, base + 9, &vcocap_reg_state);
    if (status != 0) {
        goto error;
    }

    vcocap_reg_state &= ~(0x3f);
    651c:	04fff004 	movi	r19,-64
    6520:	14e6703a 	and	r19,r2,r19
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6524:	994ab03a 	or	r5,r19,r5
    6528:	29403fcc 	andi	r5,r5,255
    652c:	a009883a 	mov	r4,r20
    6530:	00048380 	call	4838 <lms6_write>
    int status, dsm_status;

    /* Utilize atomic writes to the PLL registers, if possible. This
     * "multiwrite" is indicated by the MSB being set. */
#   ifdef BLADERF_NIOS_BUILD
    const uint8_t pll_base = base | 0x80;
    6534:	057fe004 	movi	r21,-128
    int status;
    uint8_t regval;
    uint8_t selout;
    uint8_t addr;

    if (module == BLADERF_MODULE_TX) {
    6538:	00800044 	movi	r2,1
    int status, dsm_status;

    /* Utilize atomic writes to the PLL registers, if possible. This
     * "multiwrite" is indicated by the MSB being set. */
#   ifdef BLADERF_NIOS_BUILD
    const uint8_t pll_base = base | 0x80;
    653c:	956ab03a 	or	r21,r18,r21
    status = LMS_READ(dev, base + 9, &vcocap_reg_state);
    if (status != 0) {
        goto error;
    }

    vcocap_reg_state &= ~(0x3f);
    6540:	982f883a 	mov	r23,r19
    status = write_vcocap(dev, base, f->vcocap, vcocap_reg_state);
    if (status != 0) {
        goto error;
    }

    status = write_pll_config(dev, mod, f->freqsel,
    6544:	8f000003 	ldbu	fp,0(r17)
                              (f->flags & LMS_FREQ_FLAGS_LOW_BAND) != 0);
    6548:	89c00203 	ldbu	r7,8(r17)
    int status;
    uint8_t regval;
    uint8_t selout;
    uint8_t addr;

    if (module == BLADERF_MODULE_TX) {
    654c:	80800226 	beq	r16,r2,6558 <lms_set_precalculated_frequency+0xb8>
        addr = 0x15;
    } else {
        addr = 0x25;
    6550:	01800944 	movi	r6,37
    6554:	00000106 	br	655c <lms_set_precalculated_frequency+0xbc>
    uint8_t regval;
    uint8_t selout;
    uint8_t addr;

    if (module == BLADERF_MODULE_TX) {
        addr = 0x15;
    6558:	01800544 	movi	r6,21
    } else {
        addr = 0x25;
    }

    status = LMS_READ(dev, addr, &regval);
    655c:	31803fcc 	andi	r6,r6,255
    6560:	3009883a 	mov	r4,r6
    6564:	d9800515 	stw	r6,20(sp)
    6568:	d9c00415 	stw	r7,16(sp)
    656c:	00048240 	call	4824 <lms6_read>
    6570:	1011883a 	mov	r8,r2
static inline int is_loopback_enabled(struct bladerf *dev)
{
    bladerf_loopback loopback;
    int status;

    status = lms_get_loopback_mode(dev, &loopback);
    6574:	d9400104 	addi	r5,sp,4
    6578:	b009883a 	mov	r4,r22
    657c:	da000315 	stw	r8,12(sp)
    6580:	00063280 	call	6328 <lms_get_loopback_mode>
    6584:	1021883a 	mov	r16,r2
    if (status != 0) {
    6588:	d9800517 	ldw	r6,20(sp)
    658c:	d9c00417 	ldw	r7,16(sp)
    6590:	da000317 	ldw	r8,12(sp)
    6594:	1000021e 	bne	r2,zero,65a0 <lms_set_precalculated_frequency+0x100>
        return status;
    }

    return loopback != BLADERF_LB_NONE;
    6598:	dc000117 	ldw	r16,4(sp)
    659c:	84000258 	cmpnei	r16,r16,9
    if (status != 0) {
        return status;
    }

    status = is_loopback_enabled(dev);
    if (status < 0) {
    65a0:	8000ca16 	blt	r16,zero,68cc <lms_set_precalculated_frequency+0x42c>
    65a4:	e0c03fcc 	andi	r3,fp,255
        return status;
    }

    if (status == 0) {
    65a8:	8000041e 	bne	r16,zero,65bc <lms_set_precalculated_frequency+0x11c>
        /* Loopback not enabled - update the PLL output buffer. */
        selout = low_band ? 1 : 2;
    65ac:	3940004c 	andi	r5,r7,1
    65b0:	00800084 	movi	r2,2
    65b4:	114bc83a 	sub	r5,r2,r5
    65b8:	00000106 	br	65c0 <lms_set_precalculated_frequency+0x120>
        regval = (freqsel << 2) | selout;
    } else {
        /* Loopback is enabled - don't touch PLL output buffer. */
        regval = (regval & ~0xfc) | (freqsel << 2);
    65bc:	414000cc 	andi	r5,r8,3
    65c0:	18c7883a 	add	r3,r3,r3
    65c4:	18c7883a 	add	r3,r3,r3
    65c8:	28cab03a 	or	r5,r5,r3
    }

    return LMS_WRITE(dev, addr, regval);
    65cc:	3009883a 	mov	r4,r6
    65d0:	29403fcc 	andi	r5,r5,255
    65d4:	00048380 	call	4838 <lms6_write>
    if (status != 0) {
        goto error;
    }

    data = f->nint >> 1;
    status = LMS_WRITE(dev, pll_base + 0, data);
    65d8:	8940008b 	ldhu	r5,2(r17)
    65dc:	a9003fcc 	andi	r4,r21,255
    65e0:	280ad07a 	srli	r5,r5,1
    65e4:	29403fcc 	andi	r5,r5,255
    65e8:	00048380 	call	4838 <lms6_write>
    if (status != 0) {
        goto error;
    }

    data = ((f->nint & 1) << 7) | ((f->nfrac >> 16) & 0x7f);
    status = LMS_WRITE(dev, pll_base + 1, data);
    65ec:	88800083 	ldbu	r2,2(r17)
    65f0:	8940018b 	ldhu	r5,6(r17)
    65f4:	a9000044 	addi	r4,r21,1
    65f8:	100491fa 	slli	r2,r2,7
    65fc:	29401fcc 	andi	r5,r5,127
    6600:	21003fcc 	andi	r4,r4,255
    6604:	288ab03a 	or	r5,r5,r2
    6608:	29403fcc 	andi	r5,r5,255
    660c:	00048380 	call	4838 <lms6_write>
    if (status != 0) {
        goto error;
    }

    data = ((f->nfrac >> 8) & 0xff);
    status = LMS_WRITE(dev, pll_base + 2, data);
    6610:	89400143 	ldbu	r5,5(r17)
    6614:	a9000084 	addi	r4,r21,2
    6618:	21003fcc 	andi	r4,r4,255
    661c:	00048380 	call	4838 <lms6_write>
    if (status != 0) {
        goto error;
    }

    data = (f->nfrac & 0xff);
    status = LMS_WRITE(dev, pll_base + 3, data);
    6620:	89400103 	ldbu	r5,4(r17)
    6624:	a90000c4 	addi	r4,r21,3
    6628:	21003fcc 	andi	r4,r4,255
    662c:	00048380 	call	4838 <lms6_write>
        goto error;
    }

    /* Perform tuning algorithm unless we've been instructed to just use
     * the VCOCAP hint as-is. */
    if (f->flags & LMS_FREQ_FLAGS_FORCE_VCOCAP) {
    6630:	88800203 	ldbu	r2,8(r17)
    6634:	88c00043 	ldbu	r3,1(r17)
    6638:	1080008c 	andi	r2,r2,2
    663c:	10000326 	beq	r2,zero,664c <lms_set_precalculated_frequency+0x1ac>
        f->vcocap_result = f->vcocap;
    6640:	88c00245 	stb	r3,9(r17)
    if (status != 0) {
        goto error;
    }

    data = (f->nfrac & 0xff);
    status = LMS_WRITE(dev, pll_base + 3, data);
    6644:	0021883a 	mov	r16,zero
    6648:	0000a006 	br	68cc <lms_set_precalculated_frequency+0x42c>
    uint8_t vtune_high_limit; /* Where VCOCAP puts use into VTUNE HIGH region */
    uint8_t vtune_low_limit;  /* Where VCOCAP puts use into VTUNE HIGH region */

    RESET_BUSY_WAIT_COUNT();

    vtune_high_limit = VCOCAP_MAX_VALUE;
    664c:	00800fc4 	movi	r2,63
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    6650:	01000c84 	movi	r4,50
    RESET_BUSY_WAIT_COUNT();

    vtune_high_limit = VCOCAP_MAX_VALUE;
    vtune_low_limit = 0;

    status = get_vtune(dev, base, VTUNE_DELAY_LARGE, &vtune);
    6654:	95403fcc 	andi	r21,r18,255

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    6658:	94800284 	addi	r18,r18,10
static int tune_vcocap(struct bladerf *dev, uint8_t vcocap_est,
                       uint8_t base, uint8_t vcocap_reg_state,
                       uint8_t *vcocap_result)
{
    int status;
    uint8_t vcocap = vcocap_est;
    665c:	d8c00245 	stb	r3,9(sp)
    uint8_t vtune_high_limit; /* Where VCOCAP puts use into VTUNE HIGH region */
    uint8_t vtune_low_limit;  /* Where VCOCAP puts use into VTUNE HIGH region */

    RESET_BUSY_WAIT_COUNT();

    vtune_high_limit = VCOCAP_MAX_VALUE;
    6660:	d8800205 	stb	r2,8(sp)
    vtune_low_limit = 0;
    6664:	d8000105 	stb	zero,4(sp)

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    6668:	94803fcc 	andi	r18,r18,255
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    666c:	0006d780 	call	6d78 <usleep>
    }

    status = LMS_READ(dev, base + 10, vtune);
    6670:	9009883a 	mov	r4,r18
    6674:	00048240 	call	4824 <lms6_read>
    *vtune >>= 6;
    6678:	10803fcc 	andi	r2,r2,255
    status = get_vtune(dev, base, VTUNE_DELAY_LARGE, &vtune);
    if (status != 0) {
        return status;
    }

    switch (vtune) {
    667c:	1038d1ba 	srli	fp,r2,6
    6680:	00800044 	movi	r2,1
    6684:	e0802b26 	beq	fp,r2,6734 <lms_set_precalculated_frequency+0x294>
    6688:	e0000a26 	beq	fp,zero,66b4 <lms_set_precalculated_frequency+0x214>
    668c:	00800084 	movi	r2,2
    6690:	e080311e 	bne	fp,r2,6758 <lms_set_precalculated_frequency+0x2b8>
        case VCO_HIGH:
            log_verbose("Estimate HIGH: Walking down to NORM.\n");
            status = vtune_high_to_norm(dev, base, vcocap, vcocap_reg_state,
    6694:	d9800243 	ldbu	r6,9(sp)
    6698:	d8800204 	addi	r2,sp,8
    669c:	99c03fcc 	andi	r7,r19,255
    66a0:	d8800015 	stw	r2,0(sp)
    66a4:	a80b883a 	mov	r5,r21
    66a8:	b009883a 	mov	r4,r22
    66ac:	00060740 	call	6074 <vtune_high_to_norm>
    66b0:	00002706 	br	6750 <lms_set_precalculated_frequency+0x2b0>
                                        &vtune_high_limit);
            break;

        case VCO_NORM:
            log_verbose("Estimate NORM: Walking up to HIGH.\n");
            status = vtune_norm_to_high(dev, base, vcocap, vcocap_reg_state,
    66b4:	d8c00243 	ldbu	r3,9(sp)
        status = get_vtune(dev, base, VTUNE_DELAY_SMALL, &vtune);
        if (status != 0) {
            return status;
        }

        if (vtune == VCO_HIGH) {
    66b8:	01c00084 	movi	r7,2
    66bc:	19bffb04 	addi	r6,r3,-20
{
    int status;
    unsigned int i;
    uint8_t vtune = 0xff;

    for (i = 0; i < VTUNE_MAX_ITERATIONS; i++) {
    66c0:	31803fcc 	andi	r6,r6,255

        if (vcocap == 0) {
    66c4:	18803fcc 	andi	r2,r3,255
    66c8:	1000021e 	bne	r2,zero,66d4 <lms_set_precalculated_frequency+0x234>
            *vtune_high_limit = 0;
    66cc:	d8000205 	stb	zero,8(sp)
    66d0:	00002106 	br	6758 <lms_set_precalculated_frequency+0x2b8>
            log_warning("%s: VCOCAP hit min value.\n", __FUNCTION__);
            return 0;
        }

        vcocap--;
    66d4:	1c3fffc4 	addi	r16,r3,-1
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    66d8:	85cab03a 	or	r5,r16,r23
            *vtune_high_limit = 0;
            log_warning("%s: VCOCAP hit min value.\n", __FUNCTION__);
            return 0;
        }

        vcocap--;
    66dc:	8007883a 	mov	r3,r16
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    66e0:	29403fcc 	andi	r5,r5,255
    66e4:	a009883a 	mov	r4,r20
    66e8:	d8c00315 	stw	r3,12(sp)
    66ec:	d9800515 	stw	r6,20(sp)
    66f0:	d9c00415 	stw	r7,16(sp)
    66f4:	00048380 	call	4838 <lms6_write>
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    66f8:	01000644 	movi	r4,25
    66fc:	0006d780 	call	6d78 <usleep>
    }

    status = LMS_READ(dev, base + 10, vtune);
    6700:	9009883a 	mov	r4,r18
    6704:	00048240 	call	4824 <lms6_read>
        status = get_vtune(dev, base, VTUNE_DELAY_SMALL, &vtune);
        if (status != 0) {
            return status;
        }

        if (vtune == VCO_HIGH) {
    6708:	10803fcc 	andi	r2,r2,255
    670c:	1004d1ba 	srli	r2,r2,6
    6710:	d9c00417 	ldw	r7,16(sp)
    6714:	d8c00317 	ldw	r3,12(sp)
    6718:	d9800517 	ldw	r6,20(sp)
    671c:	11c0021e 	bne	r2,r7,6728 <lms_set_precalculated_frequency+0x288>
            *vtune_high_limit = vcocap;
    6720:	dc000205 	stb	r16,8(sp)
    6724:	00000c06 	br	6758 <lms_set_precalculated_frequency+0x2b8>
{
    int status;
    unsigned int i;
    uint8_t vtune = 0xff;

    for (i = 0; i < VTUNE_MAX_ITERATIONS; i++) {
    6728:	84003fcc 	andi	r16,r16,255
    672c:	343fe51e 	bne	r6,r16,66c4 <lms_set_precalculated_frequency+0x224>
    6730:	00006506 	br	68c8 <lms_set_precalculated_frequency+0x428>
                                        &vtune_high_limit);
            break;

        case VCO_LOW:
            log_verbose("Estimate LOW: Walking down to NORM.\n");
            status = vtune_low_to_norm(dev, base, vcocap, vcocap_reg_state,
    6734:	d9800243 	ldbu	r6,9(sp)
    6738:	d8800104 	addi	r2,sp,4
    673c:	99c03fcc 	andi	r7,r19,255
    6740:	d8800015 	stw	r2,0(sp)
    6744:	a80b883a 	mov	r5,r21
    6748:	b009883a 	mov	r4,r22
    674c:	0005fa80 	call	5fa8 <vtune_low_to_norm>
    6750:	1021883a 	mov	r16,r2
                                       &vtune_low_limit);
            break;
    }

    if (status != 0) {
    6754:	10005d1e 	bne	r2,zero,68cc <lms_set_precalculated_frequency+0x42c>
        return status;
    } else if (vtune_high_limit != VCOCAP_MAX_VALUE) {
    6758:	d8800203 	ldbu	r2,8(sp)
    675c:	01000fc4 	movi	r4,63
    6760:	10c03fcc 	andi	r3,r2,255
    6764:	19001f26 	beq	r3,r4,67e4 <lms_set_precalculated_frequency+0x344>
        /* We determined our VTUNE HIGH limit. Try to force ourselves to the
         * LOW limit and then walk back up to norm from there.
         *
         * Reminder - There's an inverse relationship between VTUNE and VCOCAP
         */
        switch (vtune) {
    6768:	e0000226 	beq	fp,zero,6774 <lms_set_precalculated_frequency+0x2d4>
    676c:	01000084 	movi	r4,2
    6770:	e100551e 	bne	fp,r4,68c8 <lms_set_precalculated_frequency+0x428>
            case VCO_HIGH:
            case VCO_NORM:
                if ( ((int) vtune_high_limit + VCOCAP_MAX_LOW_HIGH) < VCOCAP_MAX_VALUE) {
    6774:	01000c84 	movi	r4,50
    6778:	20c00216 	blt	r4,r3,6784 <lms_set_precalculated_frequency+0x2e4>
                    vcocap = vtune_high_limit + VCOCAP_MAX_LOW_HIGH;
    677c:	10800304 	addi	r2,r2,12
    6780:	00000106 	br	6788 <lms_set_precalculated_frequency+0x2e8>
                } else {
                    vcocap = VCOCAP_MAX_VALUE;
    6784:	00800fc4 	movi	r2,63
    6788:	d8800245 	stb	r2,9(sp)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    678c:	d9400243 	ldbu	r5,9(sp)
    6790:	a009883a 	mov	r4,r20
        if (status != 0) {
            return status;
        }

        log_verbose("Waiting for VTUNE LOW @ VCOCAP=%u,\n", vcocap);
        status = wait_for_vtune_value(dev, base, VCO_LOW,
    6794:	9dc03fcc 	andi	r23,r19,255
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6798:	994ab03a 	or	r5,r19,r5
    679c:	29403fcc 	andi	r5,r5,255
    67a0:	00048380 	call	4838 <lms6_write>
        if (status != 0) {
            return status;
        }

        log_verbose("Waiting for VTUNE LOW @ VCOCAP=%u,\n", vcocap);
        status = wait_for_vtune_value(dev, base, VCO_LOW,
    67a4:	d9c00244 	addi	r7,sp,9
    67a8:	ddc00015 	stw	r23,0(sp)
    67ac:	01800044 	movi	r6,1
    67b0:	a80b883a 	mov	r5,r21
    67b4:	b009883a 	mov	r4,r22
    67b8:	000614c0 	call	614c <wait_for_vtune_value>
    67bc:	1021883a 	mov	r16,r2
                                      &vcocap, vcocap_reg_state);

        if (status == 0) {
    67c0:	1000421e 	bne	r2,zero,68cc <lms_set_precalculated_frequency+0x42c>
            log_verbose("Walking VTUNE LOW to NORM from VCOCAP=%u,\n", vcocap);
            status = vtune_low_to_norm(dev, base, vcocap, vcocap_reg_state,
    67c4:	d9800243 	ldbu	r6,9(sp)
    67c8:	d8800104 	addi	r2,sp,4
    67cc:	d8800015 	stw	r2,0(sp)
    67d0:	b80f883a 	mov	r7,r23
    67d4:	a80b883a 	mov	r5,r21
    67d8:	b009883a 	mov	r4,r22
    67dc:	0005fa80 	call	5fa8 <vtune_low_to_norm>
    67e0:	00001f06 	br	6860 <lms_set_precalculated_frequency+0x3c0>
        /* We determined our VTUNE LOW limit. Try to force ourselves up to
         * the HIGH limit and then walk down to NORM from there
         *
         * Reminder - There's an inverse relationship between VTUNE and VCOCAP
         */
        switch (vtune) {
    67e4:	00800044 	movi	r2,1
    67e8:	17003736 	bltu	r2,fp,68c8 <lms_set_precalculated_frequency+0x428>
            case VCO_LOW:
            case VCO_NORM:
                if ( ((int) vtune_low_limit - VCOCAP_MAX_LOW_HIGH) > 0) {
    67ec:	d8800103 	ldbu	r2,4(sp)
    67f0:	01000304 	movi	r4,12
    67f4:	10c03fcc 	andi	r3,r2,255
    67f8:	20c0030e 	bge	r4,r3,6808 <lms_set_precalculated_frequency+0x368>
                    vcocap = vtune_low_limit - VCOCAP_MAX_LOW_HIGH;
    67fc:	10bffd04 	addi	r2,r2,-12
    6800:	d8800245 	stb	r2,9(sp)
    6804:	00000106 	br	680c <lms_set_precalculated_frequency+0x36c>
                } else {
                    vcocap = 0;
    6808:	d8000245 	stb	zero,9(sp)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    680c:	d9400243 	ldbu	r5,9(sp)
    6810:	a009883a 	mov	r4,r20
        if (status != 0) {
            return status;
        }

        log_verbose("Waiting for VTUNE HIGH @ VCOCAP=%u\n", vcocap);
        status = wait_for_vtune_value(dev, base, VCO_HIGH,
    6814:	9dc03fcc 	andi	r23,r19,255
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6818:	994ab03a 	or	r5,r19,r5
    681c:	29403fcc 	andi	r5,r5,255
    6820:	00048380 	call	4838 <lms6_write>
        if (status != 0) {
            return status;
        }

        log_verbose("Waiting for VTUNE HIGH @ VCOCAP=%u\n", vcocap);
        status = wait_for_vtune_value(dev, base, VCO_HIGH,
    6824:	d9c00244 	addi	r7,sp,9
    6828:	ddc00015 	stw	r23,0(sp)
    682c:	01800084 	movi	r6,2
    6830:	a80b883a 	mov	r5,r21
    6834:	b009883a 	mov	r4,r22
    6838:	000614c0 	call	614c <wait_for_vtune_value>
    683c:	1021883a 	mov	r16,r2
                                      &vcocap, vcocap_reg_state);

        if (status == 0) {
    6840:	1000221e 	bne	r2,zero,68cc <lms_set_precalculated_frequency+0x42c>
            log_verbose("Walking VTUNE HIGH to NORM from VCOCAP=%u,\n", vcocap);
            status = vtune_high_to_norm(dev, base, vcocap, vcocap_reg_state,
    6844:	d9800243 	ldbu	r6,9(sp)
    6848:	d8800204 	addi	r2,sp,8
    684c:	d8800015 	stw	r2,0(sp)
    6850:	b80f883a 	mov	r7,r23
    6854:	a80b883a 	mov	r5,r21
    6858:	b009883a 	mov	r4,r22
    685c:	00060740 	call	6074 <vtune_high_to_norm>
    6860:	1021883a 	mov	r16,r2
                                        &vtune_high_limit);
        }
    }

    if (status == 0) {
    6864:	1000191e 	bne	r2,zero,68cc <lms_set_precalculated_frequency+0x42c>
        vcocap = vtune_high_limit + (vtune_low_limit - vtune_high_limit) / 2;
    6868:	d9400203 	ldbu	r5,8(sp)
    686c:	d8c00103 	ldbu	r3,4(sp)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6870:	a009883a 	mov	r4,r20
                                        &vtune_high_limit);
        }
    }

    if (status == 0) {
        vcocap = vtune_high_limit + (vtune_low_limit - vtune_high_limit) / 2;
    6874:	28803fcc 	andi	r2,r5,255
    6878:	1885c83a 	sub	r2,r3,r2
    687c:	1006d7fa 	srli	r3,r2,31
    6880:	1885883a 	add	r2,r3,r2
    6884:	1005d07a 	srai	r2,r2,1
    6888:	1145883a 	add	r2,r2,r5
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    688c:	988ab03a 	or	r5,r19,r2
    6890:	29403fcc 	andi	r5,r5,255
                                        &vtune_high_limit);
        }
    }

    if (status == 0) {
        vcocap = vtune_high_limit + (vtune_low_limit - vtune_high_limit) / 2;
    6894:	d8800245 	stb	r2,9(sp)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6898:	00048380 	call	4838 <lms6_write>
        if (status != 0) {
            return status;
        }

        /* Inform the caller of what we converged to */
        *vcocap_result = vcocap;
    689c:	d8800243 	ldbu	r2,9(sp)
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    68a0:	01000644 	movi	r4,25
        if (status != 0) {
            return status;
        }

        /* Inform the caller of what we converged to */
        *vcocap_result = vcocap;
    68a4:	88800245 	stb	r2,9(r17)
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    68a8:	0006d780 	call	6d78 <usleep>
    }

    status = LMS_READ(dev, base + 10, vtune);
    68ac:	9009883a 	mov	r4,r18
    68b0:	00048240 	call	4824 <lms6_read>
            return status;
        }

        PRINT_BUSY_WAIT_INFO();

        if (vtune != VCO_NORM) {
    68b4:	10803fcc 	andi	r2,r2,255
    68b8:	1020d1ba 	srli	r16,r2,6
    68bc:	8020c03a 	cmpne	r16,r16,zero
    68c0:	0421c83a 	sub	r16,zero,r16
    68c4:	00000106 	br	68cc <lms_set_precalculated_frequency+0x42c>
                }
                break;

            default:
                assert(!"Invalid state");
                return BLADERF_ERR_UNEXPECTED;
    68c8:	043fffc4 	movi	r16,-1
                             &f->vcocap_result);
    }

error:
    /* Turn off the DSMs */
    dsm_status = LMS_READ(dev, 0x09, &data);
    68cc:	01000244 	movi	r4,9
    68d0:	00048240 	call	4824 <lms6_read>
    if (dsm_status == 0) {
        data &= ~(0x05);
        dsm_status = LMS_WRITE(dev, 0x09, data);
    68d4:	11403e8c 	andi	r5,r2,250
    68d8:	01000244 	movi	r4,9
    68dc:	00048380 	call	4838 <lms6_write>
    }

    return (status == 0) ? dsm_status : status;
}
    68e0:	8005883a 	mov	r2,r16
    68e4:	dfc00f17 	ldw	ra,60(sp)
    68e8:	df000e17 	ldw	fp,56(sp)
    68ec:	ddc00d17 	ldw	r23,52(sp)
    68f0:	dd800c17 	ldw	r22,48(sp)
    68f4:	dd400b17 	ldw	r21,44(sp)
    68f8:	dd000a17 	ldw	r20,40(sp)
    68fc:	dcc00917 	ldw	r19,36(sp)
    6900:	dc800817 	ldw	r18,32(sp)
    6904:	dc400717 	ldw	r17,28(sp)
    6908:	dc000617 	ldw	r16,24(sp)
    690c:	dec01004 	addi	sp,sp,64
    6910:	f800283a 	ret

00006914 <__lshrdi3>:
    6914:	30000826 	beq	r6,zero,6938 <__lshrdi3+0x24>
    6918:	01c00804 	movi	r7,32
    691c:	398fc83a 	sub	r7,r7,r6
    6920:	01c0080e 	bge	zero,r7,6944 <__lshrdi3+0x30>
    6924:	2188d83a 	srl	r4,r4,r6
    6928:	29c4983a 	sll	r2,r5,r7
    692c:	2986d83a 	srl	r3,r5,r6
    6930:	2084b03a 	or	r2,r4,r2
    6934:	f800283a 	ret
    6938:	2005883a 	mov	r2,r4
    693c:	2807883a 	mov	r3,r5
    6940:	f800283a 	ret
    6944:	01cfc83a 	sub	r7,zero,r7
    6948:	0007883a 	mov	r3,zero
    694c:	29c4d83a 	srl	r2,r5,r7
    6950:	f800283a 	ret

00006954 <__divsi3>:
    6954:	20001b16 	blt	r4,zero,69c4 <__divsi3+0x70>
    6958:	000f883a 	mov	r7,zero
    695c:	28001616 	blt	r5,zero,69b8 <__divsi3+0x64>
    6960:	200d883a 	mov	r6,r4
    6964:	29001a2e 	bgeu	r5,r4,69d0 <__divsi3+0x7c>
    6968:	00800804 	movi	r2,32
    696c:	00c00044 	movi	r3,1
    6970:	00000106 	br	6978 <__divsi3+0x24>
    6974:	10000d26 	beq	r2,zero,69ac <__divsi3+0x58>
    6978:	294b883a 	add	r5,r5,r5
    697c:	10bfffc4 	addi	r2,r2,-1
    6980:	18c7883a 	add	r3,r3,r3
    6984:	293ffb36 	bltu	r5,r4,6974 <__divsi3+0x20>
    6988:	0005883a 	mov	r2,zero
    698c:	18000726 	beq	r3,zero,69ac <__divsi3+0x58>
    6990:	0005883a 	mov	r2,zero
    6994:	31400236 	bltu	r6,r5,69a0 <__divsi3+0x4c>
    6998:	314dc83a 	sub	r6,r6,r5
    699c:	10c4b03a 	or	r2,r2,r3
    69a0:	1806d07a 	srli	r3,r3,1
    69a4:	280ad07a 	srli	r5,r5,1
    69a8:	183ffa1e 	bne	r3,zero,6994 <__divsi3+0x40>
    69ac:	38000126 	beq	r7,zero,69b4 <__divsi3+0x60>
    69b0:	0085c83a 	sub	r2,zero,r2
    69b4:	f800283a 	ret
    69b8:	014bc83a 	sub	r5,zero,r5
    69bc:	39c0005c 	xori	r7,r7,1
    69c0:	003fe706 	br	6960 <__divsi3+0xc>
    69c4:	0109c83a 	sub	r4,zero,r4
    69c8:	01c00044 	movi	r7,1
    69cc:	003fe306 	br	695c <__divsi3+0x8>
    69d0:	00c00044 	movi	r3,1
    69d4:	003fee06 	br	6990 <__divsi3+0x3c>

000069d8 <__modsi3>:
    69d8:	20001716 	blt	r4,zero,6a38 <__modsi3+0x60>
    69dc:	000f883a 	mov	r7,zero
    69e0:	2005883a 	mov	r2,r4
    69e4:	28001216 	blt	r5,zero,6a30 <__modsi3+0x58>
    69e8:	2900162e 	bgeu	r5,r4,6a44 <__modsi3+0x6c>
    69ec:	01800804 	movi	r6,32
    69f0:	00c00044 	movi	r3,1
    69f4:	00000106 	br	69fc <__modsi3+0x24>
    69f8:	30000a26 	beq	r6,zero,6a24 <__modsi3+0x4c>
    69fc:	294b883a 	add	r5,r5,r5
    6a00:	31bfffc4 	addi	r6,r6,-1
    6a04:	18c7883a 	add	r3,r3,r3
    6a08:	293ffb36 	bltu	r5,r4,69f8 <__modsi3+0x20>
    6a0c:	18000526 	beq	r3,zero,6a24 <__modsi3+0x4c>
    6a10:	1806d07a 	srli	r3,r3,1
    6a14:	11400136 	bltu	r2,r5,6a1c <__modsi3+0x44>
    6a18:	1145c83a 	sub	r2,r2,r5
    6a1c:	280ad07a 	srli	r5,r5,1
    6a20:	183ffb1e 	bne	r3,zero,6a10 <__modsi3+0x38>
    6a24:	38000126 	beq	r7,zero,6a2c <__modsi3+0x54>
    6a28:	0085c83a 	sub	r2,zero,r2
    6a2c:	f800283a 	ret
    6a30:	014bc83a 	sub	r5,zero,r5
    6a34:	003fec06 	br	69e8 <__modsi3+0x10>
    6a38:	0109c83a 	sub	r4,zero,r4
    6a3c:	01c00044 	movi	r7,1
    6a40:	003fe706 	br	69e0 <__modsi3+0x8>
    6a44:	00c00044 	movi	r3,1
    6a48:	003ff106 	br	6a10 <__modsi3+0x38>

00006a4c <__udivsi3>:
    6a4c:	200d883a 	mov	r6,r4
    6a50:	2900152e 	bgeu	r5,r4,6aa8 <__udivsi3+0x5c>
    6a54:	28001416 	blt	r5,zero,6aa8 <__udivsi3+0x5c>
    6a58:	00800804 	movi	r2,32
    6a5c:	00c00044 	movi	r3,1
    6a60:	00000206 	br	6a6c <__udivsi3+0x20>
    6a64:	10000e26 	beq	r2,zero,6aa0 <__udivsi3+0x54>
    6a68:	28000516 	blt	r5,zero,6a80 <__udivsi3+0x34>
    6a6c:	294b883a 	add	r5,r5,r5
    6a70:	10bfffc4 	addi	r2,r2,-1
    6a74:	18c7883a 	add	r3,r3,r3
    6a78:	293ffa36 	bltu	r5,r4,6a64 <__udivsi3+0x18>
    6a7c:	18000826 	beq	r3,zero,6aa0 <__udivsi3+0x54>
    6a80:	0005883a 	mov	r2,zero
    6a84:	31400236 	bltu	r6,r5,6a90 <__udivsi3+0x44>
    6a88:	314dc83a 	sub	r6,r6,r5
    6a8c:	10c4b03a 	or	r2,r2,r3
    6a90:	1806d07a 	srli	r3,r3,1
    6a94:	280ad07a 	srli	r5,r5,1
    6a98:	183ffa1e 	bne	r3,zero,6a84 <__udivsi3+0x38>
    6a9c:	f800283a 	ret
    6aa0:	0005883a 	mov	r2,zero
    6aa4:	f800283a 	ret
    6aa8:	00c00044 	movi	r3,1
    6aac:	003ff406 	br	6a80 <__udivsi3+0x34>

00006ab0 <__umodsi3>:
    6ab0:	2005883a 	mov	r2,r4
    6ab4:	2900122e 	bgeu	r5,r4,6b00 <__umodsi3+0x50>
    6ab8:	28001116 	blt	r5,zero,6b00 <__umodsi3+0x50>
    6abc:	01800804 	movi	r6,32
    6ac0:	00c00044 	movi	r3,1
    6ac4:	00000206 	br	6ad0 <__umodsi3+0x20>
    6ac8:	30000c26 	beq	r6,zero,6afc <__umodsi3+0x4c>
    6acc:	28000516 	blt	r5,zero,6ae4 <__umodsi3+0x34>
    6ad0:	294b883a 	add	r5,r5,r5
    6ad4:	31bfffc4 	addi	r6,r6,-1
    6ad8:	18c7883a 	add	r3,r3,r3
    6adc:	293ffa36 	bltu	r5,r4,6ac8 <__umodsi3+0x18>
    6ae0:	18000626 	beq	r3,zero,6afc <__umodsi3+0x4c>
    6ae4:	1806d07a 	srli	r3,r3,1
    6ae8:	11400136 	bltu	r2,r5,6af0 <__umodsi3+0x40>
    6aec:	1145c83a 	sub	r2,r2,r5
    6af0:	280ad07a 	srli	r5,r5,1
    6af4:	183ffb1e 	bne	r3,zero,6ae4 <__umodsi3+0x34>
    6af8:	f800283a 	ret
    6afc:	f800283a 	ret
    6b00:	00c00044 	movi	r3,1
    6b04:	003ff706 	br	6ae4 <__umodsi3+0x34>

00006b08 <__mulsi3>:
    6b08:	0005883a 	mov	r2,zero
    6b0c:	20000726 	beq	r4,zero,6b2c <__mulsi3+0x24>
    6b10:	20c0004c 	andi	r3,r4,1
    6b14:	2008d07a 	srli	r4,r4,1
    6b18:	18000126 	beq	r3,zero,6b20 <__mulsi3+0x18>
    6b1c:	1145883a 	add	r2,r2,r5
    6b20:	294b883a 	add	r5,r5,r5
    6b24:	203ffa1e 	bne	r4,zero,6b10 <__mulsi3+0x8>
    6b28:	f800283a 	ret
    6b2c:	f800283a 	ret

00006b30 <memcpy>:
    6b30:	2005883a 	mov	r2,r4
    6b34:	2007883a 	mov	r3,r4
    6b38:	218d883a 	add	r6,r4,r6
    6b3c:	19800526 	beq	r3,r6,6b54 <memcpy+0x24>
    6b40:	29000003 	ldbu	r4,0(r5)
    6b44:	18c00044 	addi	r3,r3,1
    6b48:	29400044 	addi	r5,r5,1
    6b4c:	193fffc5 	stb	r4,-1(r3)
    6b50:	003ffa06 	br	6b3c <memcpy+0xc>
    6b54:	f800283a 	ret

00006b58 <memset>:
    6b58:	2005883a 	mov	r2,r4
    6b5c:	2007883a 	mov	r3,r4
    6b60:	218d883a 	add	r6,r4,r6
    6b64:	19800326 	beq	r3,r6,6b74 <memset+0x1c>
    6b68:	19400005 	stb	r5,0(r3)
    6b6c:	18c00044 	addi	r3,r3,1
    6b70:	003ffc06 	br	6b64 <memset+0xc>
    6b74:	f800283a 	ret

00006b78 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
    6b78:	0006c041 	jmpi	6c04 <alt_iic_isr_register>

00006b7c <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    6b7c:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    6b80:	00bfff84 	movi	r2,-2
    6b84:	2084703a 	and	r2,r4,r2
    6b88:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
    6b8c:	00c00044 	movi	r3,1
    6b90:	d0a01517 	ldw	r2,-32684(gp)
    6b94:	194a983a 	sll	r5,r3,r5
    6b98:	288ab03a 	or	r5,r5,r2
    6b9c:	d1601515 	stw	r5,-32684(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
    6ba0:	d0a01517 	ldw	r2,-32684(gp)
    6ba4:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    6ba8:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
    6bac:	0005883a 	mov	r2,zero
    6bb0:	f800283a 	ret

00006bb4 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    6bb4:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    6bb8:	00bfff84 	movi	r2,-2
    6bbc:	2084703a 	and	r2,r4,r2
    6bc0:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
    6bc4:	00ffff84 	movi	r3,-2
    6bc8:	d0a01517 	ldw	r2,-32684(gp)
    6bcc:	194a183a 	rol	r5,r3,r5
    6bd0:	288a703a 	and	r5,r5,r2
    6bd4:	d1601515 	stw	r5,-32684(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
    6bd8:	d0a01517 	ldw	r2,-32684(gp)
    6bdc:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    6be0:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
    6be4:	0005883a 	mov	r2,zero
    6be8:	f800283a 	ret

00006bec <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
    6bec:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
    6bf0:	00800044 	movi	r2,1
    6bf4:	1144983a 	sll	r2,r2,r5
    6bf8:	10c4703a 	and	r2,r2,r3
}
    6bfc:	1004c03a 	cmpne	r2,r2,zero
    6c00:	f800283a 	ret

00006c04 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
    6c04:	00c007c4 	movi	r3,31
    6c08:	19401616 	blt	r3,r5,6c64 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    6c0c:	defffe04 	addi	sp,sp,-8
    6c10:	dfc00115 	stw	ra,4(sp)
    6c14:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    6c18:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    6c1c:	00ffff84 	movi	r3,-2
    6c20:	80c6703a 	and	r3,r16,r3
    6c24:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
    6c28:	280490fa 	slli	r2,r5,3
    6c2c:	00c00034 	movhi	r3,0
    6c30:	18dcc204 	addi	r3,r3,29448
    6c34:	1885883a 	add	r2,r3,r2
    6c38:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
    6c3c:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
    6c40:	30000226 	beq	r6,zero,6c4c <alt_iic_isr_register+0x48>
    6c44:	0006b7c0 	call	6b7c <alt_ic_irq_enable>
    6c48:	00000106 	br	6c50 <alt_iic_isr_register+0x4c>
    6c4c:	0006bb40 	call	6bb4 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    6c50:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
    6c54:	dfc00117 	ldw	ra,4(sp)
    6c58:	dc000017 	ldw	r16,0(sp)
    6c5c:	dec00204 	addi	sp,sp,8
    6c60:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
    6c64:	00bffa84 	movi	r2,-22
    6c68:	f800283a 	ret

00006c6c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
    6c6c:	deffff04 	addi	sp,sp,-4
    6c70:	01000034 	movhi	r4,0
    6c74:	01400034 	movhi	r5,0
    6c78:	dfc00015 	stw	ra,0(sp)
    6c7c:	211be704 	addi	r4,r4,28572
    6c80:	295bee04 	addi	r5,r5,28600

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    6c84:	2140061e 	bne	r4,r5,6ca0 <alt_load+0x34>
    6c88:	01000034 	movhi	r4,0
    6c8c:	01400034 	movhi	r5,0
    6c90:	21100804 	addi	r4,r4,16416
    6c94:	29500804 	addi	r5,r5,16416
    6c98:	2140121e 	bne	r4,r5,6ce4 <alt_load+0x78>
    6c9c:	00000b06 	br	6ccc <alt_load+0x60>
    6ca0:	00c00034 	movhi	r3,0
    6ca4:	18dbee04 	addi	r3,r3,28600
    6ca8:	1907c83a 	sub	r3,r3,r4
    6cac:	0005883a 	mov	r2,zero
  {
    while( to != end )
    6cb0:	10fff526 	beq	r2,r3,6c88 <alt_load+0x1c>
    {
      *to++ = *from++;
    6cb4:	114f883a 	add	r7,r2,r5
    6cb8:	39c00017 	ldw	r7,0(r7)
    6cbc:	110d883a 	add	r6,r2,r4
    6cc0:	10800104 	addi	r2,r2,4
    6cc4:	31c00015 	stw	r7,0(r6)
    6cc8:	003ff906 	br	6cb0 <alt_load+0x44>
    6ccc:	01000034 	movhi	r4,0
    6cd0:	01400034 	movhi	r5,0
    6cd4:	211bc404 	addi	r4,r4,28432
    6cd8:	295bc404 	addi	r5,r5,28432

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    6cdc:	2140101e 	bne	r4,r5,6d20 <alt_load+0xb4>
    6ce0:	00000b06 	br	6d10 <alt_load+0xa4>
    6ce4:	00c00034 	movhi	r3,0
    6ce8:	18d05304 	addi	r3,r3,16716
    6cec:	1907c83a 	sub	r3,r3,r4
    6cf0:	0005883a 	mov	r2,zero
  {
    while( to != end )
    6cf4:	10fff526 	beq	r2,r3,6ccc <alt_load+0x60>
    {
      *to++ = *from++;
    6cf8:	114f883a 	add	r7,r2,r5
    6cfc:	39c00017 	ldw	r7,0(r7)
    6d00:	110d883a 	add	r6,r2,r4
    6d04:	10800104 	addi	r2,r2,4
    6d08:	31c00015 	stw	r7,0(r6)
    6d0c:	003ff906 	br	6cf4 <alt_load+0x88>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
    6d10:	0006f000 	call	6f00 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
    6d14:	dfc00017 	ldw	ra,0(sp)
    6d18:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
    6d1c:	0006f041 	jmpi	6f04 <alt_icache_flush_all>
    6d20:	00c00034 	movhi	r3,0
    6d24:	18dbe704 	addi	r3,r3,28572
    6d28:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    6d2c:	0005883a 	mov	r2,zero
  {
    while( to != end )
    6d30:	18bff726 	beq	r3,r2,6d10 <alt_load+0xa4>
    {
      *to++ = *from++;
    6d34:	114f883a 	add	r7,r2,r5
    6d38:	39c00017 	ldw	r7,0(r7)
    6d3c:	110d883a 	add	r6,r2,r4
    6d40:	10800104 	addi	r2,r2,4
    6d44:	31c00015 	stw	r7,0(r6)
    6d48:	003ff906 	br	6d30 <alt_load+0xc4>

00006d4c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    6d4c:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    6d50:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    6d54:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    6d58:	0006d7c0 	call	6d7c <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    6d5c:	0006d9c0 	call	6d9c <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    6d60:	d1a01617 	ldw	r6,-32680(gp)
    6d64:	d1601717 	ldw	r5,-32676(gp)
    6d68:	d1201817 	ldw	r4,-32672(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
    6d6c:	dfc00017 	ldw	ra,0(sp)
    6d70:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    6d74:	00041881 	jmpi	4188 <main>

00006d78 <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
    6d78:	0006e881 	jmpi	6e88 <alt_busy_sleep>

00006d7c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
    6d7c:	deffff04 	addi	sp,sp,-4
    6d80:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2, nios2);
    6d84:	0006f080 	call	6f08 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
    6d88:	00800044 	movi	r2,1
    6d8c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
    6d90:	dfc00017 	ldw	ra,0(sp)
    6d94:	dec00104 	addi	sp,sp,4
    6d98:	f800283a 	ret

00006d9c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    6d9c:	f800283a 	ret

00006da0 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
    6da0:	d8800017 	ldw	r2,0(sp)
    6da4:	da000117 	ldw	r8,4(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
    6da8:	00c00044 	movi	r3,1

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
    6dac:	da400217 	ldw	r9,8(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
    6db0:	194a983a 	sll	r5,r3,r5
int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
  const alt_u8 * write_end = write_data + write_length;
    6db4:	399d883a 	add	r14,r7,r6
  alt_u8 * read_end = read_data + read_length;
    6db8:	409f883a 	add	r15,r8,r2
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
    6dbc:	21400535 	stwio	r5,20(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
    6dc0:	48c0008c 	andi	r3,r9,2
    6dc4:	1800021e 	bne	r3,zero,6dd0 <alt_avalon_spi_command+0x30>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
    6dc8:	00c10004 	movi	r3,1024
    6dcc:	20c00335 	stwio	r3,12(r4)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
    6dd0:	20c00037 	ldwio	r3,0(r4)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
    6dd4:	00c00044 	movi	r3,1
                           alt_u32 flags)
{
  const alt_u8 * write_end = write_data + write_length;
  alt_u8 * read_end = read_data + read_length;

  alt_u32 write_zeros = read_length;
    6dd8:	1015883a 	mov	r10,r2
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    6ddc:	22c00204 	addi	r11,r4,8
      if (write_data < write_end)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
      else if (write_zeros > 0)
      {
        write_zeros--;
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
    6de0:	23000104 	addi	r12,r4,4
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    6de4:	59400037 	ldwio	r5,0(r11)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
    6de8:	2b40100c 	andi	r13,r5,64
    6dec:	2940200c 	andi	r5,r5,128
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
    6df0:	68000126 	beq	r13,zero,6df8 <alt_avalon_spi_command+0x58>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
    6df4:	1800031e 	bne	r3,zero,6e04 <alt_avalon_spi_command+0x64>
    6df8:	283ffa26 	beq	r5,zero,6de4 <alt_avalon_spi_command+0x44>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
    6dfc:	68000e26 	beq	r13,zero,6e38 <alt_avalon_spi_command+0x98>
    6e00:	00001e06 	br	6e7c <alt_avalon_spi_command+0xdc>
    6e04:	00c00c0e 	bge	zero,r3,6e38 <alt_avalon_spi_command+0x98>
    {
      credits--;
    6e08:	18ffffc4 	addi	r3,r3,-1

      if (write_data < write_end)
    6e0c:	3b80052e 	bgeu	r7,r14,6e24 <alt_avalon_spi_command+0x84>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
    6e10:	3b400044 	addi	r13,r7,1
    6e14:	39c00003 	ldbu	r7,0(r7)
    6e18:	61c00035 	stwio	r7,0(r12)
    6e1c:	680f883a 	mov	r7,r13
    6e20:	00000506 	br	6e38 <alt_avalon_spi_command+0x98>
      else if (write_zeros > 0)
    6e24:	50000326 	beq	r10,zero,6e34 <alt_avalon_spi_command+0x94>
      {
        write_zeros--;
    6e28:	52bfffc4 	addi	r10,r10,-1
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
    6e2c:	60000035 	stwio	zero,0(r12)
    6e30:	00000106 	br	6e38 <alt_avalon_spi_command+0x98>
      }
      else
        credits = -1024;
    6e34:	00ff0004 	movi	r3,-1024
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
    6e38:	283fea26 	beq	r5,zero,6de4 <alt_avalon_spi_command+0x44>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
    6e3c:	21400037 	ldwio	r5,0(r4)

      if (read_ignore > 0)
    6e40:	30000226 	beq	r6,zero,6e4c <alt_avalon_spi_command+0xac>
        read_ignore--;
    6e44:	31bfffc4 	addi	r6,r6,-1
    6e48:	00000206 	br	6e54 <alt_avalon_spi_command+0xb4>
      else
        *read_data++ = (alt_u8)rxdata;
    6e4c:	41400005 	stb	r5,0(r8)
    6e50:	42000044 	addi	r8,r8,1
      credits++;
    6e54:	18c00044 	addi	r3,r3,1

      if (read_ignore == 0 && read_data == read_end)
    6e58:	303fe21e 	bne	r6,zero,6de4 <alt_avalon_spi_command+0x44>
    6e5c:	43ffe11e 	bne	r8,r15,6de4 <alt_avalon_spi_command+0x44>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    6e60:	58c00037 	ldwio	r3,0(r11)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
    6e64:	18c0080c 	andi	r3,r3,32
    6e68:	183ffd26 	beq	r3,zero,6e60 <alt_avalon_spi_command+0xc0>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
    6e6c:	4a40004c 	andi	r9,r9,1
    6e70:	4800041e 	bne	r9,zero,6e84 <alt_avalon_spi_command+0xe4>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
    6e74:	20000335 	stwio	zero,12(r4)

  return read_length;
    6e78:	f800283a 	ret
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
    6e7c:	00ffef0e 	bge	zero,r3,6e3c <alt_avalon_spi_command+0x9c>
    6e80:	003fe106 	br	6e08 <alt_avalon_spi_command+0x68>
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);

  return read_length;
}
    6e84:	f800283a 	ret

00006e88 <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
    6e88:	01440034 	movhi	r5,4096
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
    6e8c:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
    6e90:	297fffc4 	addi	r5,r5,-1
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
    6e94:	dc000015 	stw	r16,0(sp)
    6e98:	dfc00115 	stw	ra,4(sp)
    6e9c:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
    6ea0:	0006a4c0 	call	6a4c <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
    6ea4:	10000e26 	beq	r2,zero,6ee0 <alt_busy_sleep+0x58>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
    6ea8:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
    6eac:	013c0034 	movhi	r4,61440
    6eb0:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
    6eb4:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
    6eb8:	21000044 	addi	r4,r4,1
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
    6ebc:	297fffc4 	addi	r5,r5,-1
    6ec0:	283ffe1e 	bne	r5,zero,6ebc <alt_busy_sleep+0x34>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
    6ec4:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
    6ec8:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
    6ecc:	18bffb16 	blt	r3,r2,6ebc <alt_busy_sleep+0x34>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
    6ed0:	802090fa 	slli	r16,r16,3
    6ed4:	843fffc4 	addi	r16,r16,-1
    6ed8:	803ffe1e 	bne	r16,zero,6ed4 <alt_busy_sleep+0x4c>
    6edc:	00000306 	br	6eec <alt_busy_sleep+0x64>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
    6ee0:	802090fa 	slli	r16,r16,3
    6ee4:	843fffc4 	addi	r16,r16,-1
    6ee8:	043ffe16 	blt	zero,r16,6ee4 <alt_busy_sleep+0x5c>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
    6eec:	0005883a 	mov	r2,zero
    6ef0:	dfc00117 	ldw	ra,4(sp)
    6ef4:	dc000017 	ldw	r16,0(sp)
    6ef8:	dec00204 	addi	sp,sp,8
    6efc:	f800283a 	ret

00006f00 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
    6f00:	f800283a 	ret

00006f04 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
    6f04:	f800283a 	ret

00006f08 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
    6f08:	000170fa 	wrctl	ienable,zero
    6f0c:	f800283a 	ret
